Погружение в
ПАТТЕРНЫ
ПРОЕКТИРОВАНИЯ
v2018-1.5
Вместо копирайта
Привет! Меня зовут Александр Швец, я автор
книги Погружения в Паттерны, а также
онлайн курса Погружение в Рефакторинг.
Эта книга предназначена для вашего личного
пользования. Пожалуйста, не передавайте
книгу третьим лицам, за исключением членов
своей семьи. Если вы хотите поделиться книгой с друзьями
или коллегами, то купите и подарите им легальную копию
книги.
Все деньги, вырученные с продаж моих книг и курсов, идут
на развитие Refactoring.Guru. Каждая проданная копия
приближает момент выхода новых курсов и книг.
© Александр Швец, Refactoring.Guru, 2018
? support@refactoring.guru
Посвящаю всё это своей жене, Марии, без которой
я бы не смог закончить книгу ещё лет тридцать.
Содержание
Содержание .............................................................5
Как читать эту книгу...............................................7
ВВЕДЕНИЕ В ООП....................................................8
Вспоминаем ООП........................................................................... 9
Краеугольные камни ООП........................................................13
Отношения между объектами.................................................20
ОСНОВЫ ПАТТЕРНОВ.......................................... 22
Что такое паттерн? ......................................................................23
Зачем знать паттерны................................................................27
ПРИНЦИПЫ ПРОЕКТИРОВАНИЯ ....................... 28
Качества хорошей архитектуры ............................................29
Базовые принципы проектирования .............................34
§ Инкапсулируйте то, что меняется.............................35
§ Программируйте на уровне интерфейса ..............39
§ Предпочитайте композицию наследованию.......44
Принципы SOLID................................................................ 48
§ S: Принцип единой ответственности ......................49
§ O: Принцип открытости/закрытости........................51
§ L: Принцип подстановки Лисков ..............................54
§ I: Принцип разделения интерфейса........................60
§ D: Принцип инверсии зависимостей ......................63
5 Содержание
КАТАЛОГ ПАТТЕРНОВ.......................................... 66
Порождающие паттерны ................................................. 67
§ Фабричный метод...........................................................69
§ Абстрактная фабрика....................................................85
§ Строитель......................................................................... 100
§ Прототип.......................................................................... 118
§ Одиночка......................................................................... 133
Структурные паттерны....................................................142
§ Адаптер ............................................................................ 145
§ Мост................................................................................... 158
§ Компоновщик ................................................................ 174
§ Декоратор ....................................................................... 188
§ Фасад................................................................................ 206
§ Легковес........................................................................... 217
§ Заместитель.................................................................... 231
Поведенческие паттерны...............................................244
§ Цепочка обязанностей............................................... 248
§ Команда ........................................................................... 267
§ Итератор.......................................................................... 287
§ Посредник....................................................................... 302
§ Снимок.............................................................................. 317
§ Наблюдатель.................................................................. 333
§ Состояние........................................................................ 348
§ Стратегия ......................................................................... 364
§ Шаблонный метод ....................................................... 377
§ Посетитель ...................................................................... 390
Заключение......................................................... 406
6 Содержание
Как читать эту книгу?
Эта книга состоит из описания 22-х классических паттернов
проектирования, впервые открытых «Бандой Четырёх»
("Gang of Four" или просто GoF) в 1994 году.
Каждая глава книги посвящена только одному паттерну.
Поэтому, книгу можно читать как последовательно, от края
до края, так и в произвольном порядке, выбирая только
интересные в данный момент паттерны.
Многие паттерны связаны между собой, поэтому вы
сможете с лёгкостью прыгать по связанным темам,
используя ссылки, которых в книге имеется в достатке. В
конце каждой главы приведены отношения текущего
паттерна с остальными. Если вы видите там название
паттерна, до которого ещё не добрались, то попросту
читайте дальше — этот пункт будет повторён в другой главе.
Паттерны проектирования универсальны. Поэтому все
примеры кода в этой книге приведены на псевдокоде, без
привязки к конкретному языку программирования.
Перед изучением паттернов вы можете освежить память,
пройдясь по основным терминам объектного
программирования. Паралельно я расскажу об UMLдиаграммах, которых в этой книге огромное множество.
Если вы уже всё это знаете — смело приступайте к
изучению паттернов.
7 Как читать эту книгу?
ВВЕДЕНИЕ В
ООП
Вспоминаем ООП
Объектно-ориентированное программирование — это
методология программирования, в которой все важные
вещи представлены объектами, каждый из которых
является экземпляром определенного класса, а классы
образуют иерархию наследования.
Объекты, классы
Вы любите котиков? Надеюсь да, потому что я попытаюсь
объяснить все эти вещи на примерах с котами.
Это UML-диаграмма класса. В книге будет много таких диаграмм.
9 ВВЕДЕНИЕ В ООП / Вспоминаем ООП
Итак, у вас есть кот Пушистик. Он является объектом класса
Кот . Все коты имеют одинаковый набор свойств — имя,
пол, возраст, вес, цвет, любимая еда и прочее. Кроме того,
они ведут себя похожим образом: бегают, дышат, спять, едят
и мурчат.
Мурка, кошка вашей подруги, тоже является экземпляром
класса Кот . Она имеет такой же набор поведений и
свойств, что и Пушистик, а отличается от него лишь
значениями этих свойств — она другого пола, имеет другой
окрас, вес и т.д.
Объекты — это экземпляры классов.
Итак, класс — это своеобразный «чертёж», по которому
строятся объекты — экземпляры этого класса.
10 ВВЕДЕНИЕ В ООП / Вспоминаем ООП
Иерархии классов
Идём дальше. У вашего соседа есть собака Жучка. Как
известно, и собаки, и коты имеют много общего — имя, пол,
возраст, цвет есть не только у котов, но и у собак. Да и
бегать, дышать, спать и есть могут не только коты.
Получается, эти свойства и поведения присущи общему
классу Животных .
UML-диаграмма иерархии классов. Все классы на этой диаграмме являются
частью иерархии Животных .
11 ВВЕДЕНИЕ В ООП / Вспоминаем ООП
Такой родительский класс принято называет суперклассом,
а его потомков — подклассами. Подклассы наследуют
свойства и поведения своего родителя, поэтому в них
содержится лишь то, чего нет в суперклассе. Например,
только коты могут мурчать, а собаки — лаять.
Мы можем пойти дальше, и выделить ещё более общий
класс живых Организмов , который будет родительским и
для Животных , и для Рыб . Такую «пирамиду» классов
обычно называют иерархией. Класс Котов унаследует всё
как из Животных , так из Оганизмов .
Классы на UML-диаграмме можно упрощать, если важно показать отношения
между ними.
Следует упомянуть, что подклассы могут переопределять
поведение методов, которые им достались от суперкласса.
При этом, они могут как полностью заменить поведение
метода, так и просто добавить что-то к результату
выполнения родительского метода.
12 ВВЕДЕНИЕ В ООП / Вспоминаем ООП
Краеугольные камни
ООП
ООП имеет четыре главные концепции, которые отличают
его от остальных методологий программирования.
Абстракция
Когда вы пишете программу, используя ООП, вы
представляете её части через объекты реального мира. Но
объекты в программе не повторяют в точности их реальные
аналоги, да и это редко когда нужно. Вместо этого, объекты
программы всего лишь моделируют поведение реальных
объектов, важных в том или ином контексте, а остальные
свойства реального объекта игнорируют.
Так, например, класс Самолёт будет актуален как для
программы тренажёра пилотов, так и для программы
13 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
бронирования авиабилетов, но в первом случае будут
важны детали пилотирования самолёта, а во втором —
лишь расположение и занятость мест внутри самолёта.
Разные модели одного и того же реального объекта.
Абстракция — это модель некоего объекта или явления
реального мира, откидывающая незначительные детали, не
играющие существенной роли в данном контексте.
Инкапсуляция
Когда вы заводите автомобиль, вам достаточно повернуть
ключи зажигания или нажать кнопку. Вам не нужно вручную
соединять провода под капотом, поворачивать коленчатый
вал и поршни, запуская такт двигателя. Все эти детали
скрыты под капотом автомобиля. Вам доступен только
14 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
простой интерфейс — кнопка зажигания, руль и педали.
Таким образом, интерфейс — это публичная часть объекта,
доступная остальным объектам.
Инкапсуляция — это способность объектов скрывать часть
своего состояния и поведения от других объектов,
предоставляя внешнему миру только определённый
интерфейс взаимодействия с собой.
Например, вы можете инкапсулировать что-то внутри
класса, сделав его приватным ( private ) и скрыв доступ к
этому полю или методу для объектов других классов. Более
открытый режим видимости protected сделает это поле
или метод доступным в подклассах.
На идеях абстракции и инкапсуляции построены
механизмы интерфейсов и абстрактных классов/методов
большинства объектных языков программирования.
Многих путает, что словом «интерфейс» называют и
публичную часть объекта, и конструкцию interface
из большинства языков программирования.
В объектном языке программирования, с помощью
интерфейсов (обычно объявляемых через ключевое слово
interface ) можно явно описывать «контракты»
взаимодействия объектов.
15 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
Например, вы создали интерфейс ЛетающийТранспорт с
методом лететь(откуда, куда, пассажиры) , а затем описали
методы класса Аэропорта так, чтобы они принимали любые
объекты с этим интерфейсом. Теперь вы можете быть
уверены, что любой объект, реализующий интерфейс —
будь то Самолёт , Вертолёт или ДрессированныйГрифон ,
сможет работать с Аэропортом .
UML-диаграмма реализации и использования интерфейса.
Вы можете как угодно менять код классов, реализующих
интерфейс, не беспокоясь о том, что Аэропорт перестанет
быть с ними совместимым.
16 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
Наследование
Наследование — это возможность создание новых классов
на основе существующих. Главная польза от наследования
— повторное использование существующего кода. Расплата
за наследование проявляется в том, что подклассы всегда
следуют интерфейсу родительского класса. Вы не можете
исключить из подкласса метод, объявленный в его
родителе.
UML-диаграмма единичного наследования против реализации
множества интерфейсов.
В большинстве объектных языков программирования, класс
может иметь только одного родителя. Но с другой стороны,
класс может реализовывать несколько интерфейсов
одновременно.
17 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
Полиморфизм
Вернёмся к примерам с животными. Практически все
животные умеют издавать звуки, поэтому мы можем
объявить абстрактный метод издания звука в их базовом
классе. Все подклассы должны будут реализовать этот
метод по-своему.
UML-диаграмма единичного наследования против реализации
множества интерфейсов.
Теперь, представьте, что мы поместили нескольких собак и
котов в здоровенный мешок. Затем, мы будем с закрытыми
глазами вытаскивать их по одной из мешка. Вытянув
18 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
зверушку, мы не знаем какого она класса. Но если её
погладить, она точно издаст какой-то звук, зависящий от её
класса.
Здесь программе не известен конкретный класс объекта в
переменной а , но благодаря специальному механизму,
называемому полиморфизмом, будет запущен тот метод
издания звуков, который соответствует реальному классу
объекта.
Полиморфизм — это способность программы выбирать
различные реализации, при вызове операций с одним и
тем же названием.
С другой стороны, полиморфизм — это способность
объектов притворяться чем-то другим. В приведённом выше
примере, собаки и коты «притворялись» абстрактными
животными.
1 bag = [new Cat(), new Dog()];
2
3 foreach (Animal a : bag)
4 a.makeSound()
5
6 // Meow!
7 // Bark!
19 ВВЕДЕНИЕ В ООП / Краеугольные камни ООП
Отношения между
объектами
Кроме наследования и реализации есть ещё несколько
видов отношений между объектами, о которых мы ещё не
говорили.
Ассоциация в UML-диаграммах. Профессор взаимодействует со студентами.
Ассоциация — это когда один объект использует другой,
либо зависит от него. В UML ассоциация обозначается
простой стрелкой, которая направлена в сторону
зависимости. Двустороння ассоциация между объектами
вполне допустима.
Композиция в UML-диаграммах. Университет состоит из кафедр.
Композиция — это отношение «часть-целое» между двумя
объектами, когда один из них включает в себя другой.
Особенность этого отношения заключается в том, что
компонент может существовать только как часть
контейнера. В UML композиция обозначается линией со
стрелкой на одном конце и заполненным ромбом на другом
20 ВВЕДЕНИЕ В ООП / Отношения между объектами
конце. Ромб направлен в сторону контейнера, а стрелка — в
сторону включаемого объекта.
Агрегация в UML-диаграммах. Кафедра содержит профессоров.
Агрегация — это менее строгий вариант композиции, когда
один объект просто имеет ссылку на другой объект. Здесь
контейнер не управляет жизненным циклом компонента.
Компонент может существовать отдельно от контейнера. В
UML агрегация изображается как композиция, но с пустым
ромбом.
21 ВВЕДЕНИЕ В ООП / Отношения между объектами
ОСНОВЫ
ПАТТЕРНОВ
Что такое паттерн?
Паттерн проектирования — это часто встречаемое решение
определённой проблемы при проектировании архитектуры
программ.
В отличие от готовых функций или библиотек, паттерн
нельзя просто взять и скопировать в программу. Паттерн
представляет собой не какой-то конкретный код, а общую
концепцию или пример решения той или иной проблемы,
которое нужно будет подстроить под нужды вашей
программы.
Паттерны часто путают с алгоритмами, ведь оба понятия
описывают типовые решения каких-то известных проблем.
И если алгоритм — это чёткий набор действий, то паттерн
— это высокоуровневое описание решения, реализация
которого может отличаться в двух разных программах.
Если привести аналогии, то алгоритм — это кулинарный
рецепт с чёткими шагами, а паттерн — инженерный чертёж,
на котором нарисовано решение, но не конкретные шаги
его получения.
Из чего состоит паттерн?
Описания паттернов обычно очень формальны и чаще
всего состоят из таких пунктов:
23 ОСНОВЫ ПАТТЕРНОВ / Что такое паттерн?
• проблемы, которую решает паттерн;
• мотивации к решению проблемы способом, который
предлагает паттерн;
• структуры классов, составляющих решение;
• примера на одном из языков программирования;
• особенностей реализации в различных контекстах;
• связей с другими паттернами.
Такой формализм в описании позволяет собрать обширный
каталог паттернов, проверяя все новые паттерны на
состоятельность.
Классификация паттернов
Паттерны отличаются по уровню сложности, детализации и
охвата проектируемой системы. Проводя аналогию со
строительством, вы можете повысить безопасность
перекрёстка, поставив светофор, а можете заменить
перекрёсток целой автомобильной развязкой с
подземными переходами.
Самые низкоуровневые и простые паттерны — идиомы. Они
не очень универсальные, так как применимы только в
рамках одного языка программирования.
Самые универсальные — архитектурные паттерны,
которые можно реализовать практически на любом языке.
24 ОСНОВЫ ПАТТЕРНОВ / Что такое паттерн?
Они нужны для проектирования всей программы, а не
отдельных её элементов.
Кроме этого, паттерны отличаются и предназначением. В
этой книге будут рассмотрены три основные группы
паттернов:
• Порождающие паттерны беспокоятся о гибком создании
объектов без внесения в программу лишних зависимостей.
• Структурные паттерны показывают различные способы
построения связей между объектами.
• Поведенческие паттерны заботятся об эффективной
коммуникации между объектами.
Кто придумал паттерны?
По определению, паттерны не придумывают, а скорее
«открывают». Это не какие-то супер-оригинальные
решения, а наоборот — часто встречающиеся, типовые
решения одной и той же проблемы.
Концепцию паттернов впервые описал Кристофер
Александер1
в книге «Язык шаблонов. Города. Здания.
Строительство». В книге описан «язык» для проектирования
1. A Pattern Language: Towns, Buildings, Construction
(https://refactoring.guru/ru/pattern-language-book).
25 ОСНОВЫ ПАТТЕРНОВ / Что такое паттерн?
окружающей среды, единицы которого — шаблоны (или
паттерны, что ближе к оригинальному термину patterns) —
отвечают на архитектурные вопросы: какой высоты сделать
окна, сколько этажей должно быть в здании, какую площадь
в микрорайоне отвести под деревья и газоны.
Идея показалась заманчивой четвёрке авторов: Эриху
Гамме, Ричарду Хелму, Ральфу Джонсону, Джону Влиссидесу.
В 1995 году они написали книгу «Design Patterns: Elements
of Reusable Object-Oriented Software»1
, в которую вошли 23
паттерна, решающие различные проблемы объектноориентированного дизайна. Название книги было слишком
длинным, чтобы кто-то смог всерьёз его запомнить.
Поэтому вскоре все стали назвать её «book by the gang of
four», то есть «книга от банды четырёх», а затем и вовсе
«GOF book».
С тех пор были найдены десятки других объектных
паттернов. «Паттерновый подход» стал популярен и в
других областях программирования, поэтому сейчас можно
встретить всевозможные паттерны и за пределами
объектного проектирования.
1. Design Patterns: Elements of Reusable Object-Oriented Software
(https://refactoring.guru/ru/gof-book).
26 ОСНОВЫ ПАТТЕРНОВ / Что такое паттерн?
Зачем знать паттерны?
Вы можете вполне успешно работать, не зная ни одного
паттерна. Более того, вы могли уже не раз реализовать
какой-то из паттернов, даже не подозревая об этом.
Но осознанное владение инструментом как раз и отличает
профессионала от любителя. Вы можете забить гвоздь
молотком, а можете и дрелью, если сильно постараетесь. Но
профессионал знает, что главная фишка дрели совсем не в
этом. Итак, зачем же знать паттерны?
• Проверенные решения. Вы тратите меньше времени,
используя готовые решения, вместо повторного
изобретения велосипеда. До некоторых решений вы смогли
бы додуматься и сами, но многие могут быть для вас
открытием.
• Стандартизация кода. Вы делаете меньше просчётов при
проектировании, используя типовые унифицированные
решения, так как все скрытые проблемы в них уже давно
найдены.
• Общий программистский словарь. Вы произносите
название паттерна, вместо того, чтобы час объяснять
другим программистам какой крутой дизайн вы придумали
и какие классы для этого нужны.
27 ОСНОВЫ ПАТТЕРНОВ / Зачем знать паттерны?
ПРИНЦИПЫ
ПРОЕКТИРОВАНИЯ
Качества хорошей
архитектуры
Прежде чем перейти к изучению конкретных паттернов,
давайте поговорим о самом процессе проектирования, о
том к чему надо стремиться и о том, чего надо избегать.
Повторное использование кода
Не секрет, что стоимость и время разработки это наиболее
важные метрики при разработке любых программных
продуктов. Чем меньше оба этих показателя, тем
конкурентнее продукт будет на рынке и тем больше
прибыли получит разработчик.
Повторное использование программной архитектуры и
кода — это один из самых распространённых способов
снижения стоимости разработки. Логика проста: вместо
того, чтобы разрабатывать что-то по втором уразу, почему
бы не использовать прошлые наработки в новом проекте?
Идея выглядит отлично на бумаге, но, к сожалению, не
всякий код можно приспособить к работе в новых условиях.
Слишком тесные связи между компонентами, зависимость
кода от конкретных классов, а не более абстрактных
интерфейсов, вшитые в код операции, которые невозможно
расширить — всё это уменьшает гибкость вашей
архитектуры и препятствует её повторному использованию.
29 Качества хорошей архитектуры
На помощь приходят паттерны проектирования, которые
ценой усложнения кода программы повышают гибкость её
частей, упрощая дальнейшее повторное использование
кода.
Приведу цитату Эрика Гаммы, одного из первооткрывателей
паттернов, о повторном использовании кода и роли
паттернов в нём.
Существует три уровня повторного использования кода. На
самом нижнем уровне находятся классы: полезные
библиотеки классов, контейнеры, а также «команды»
классов вроде контейнеров/итераторов.
Фреймворки стоят на самом верхнем уровне. В них важна
только архитектура. Они определяют ключевые абстракции
для решения некоторых бизнес-задач, представленных в
виде классов и отношений между ними. Возьмите JUnit, это
маленький фреймворк, даже базовый, я бы сказал. В нём
есть всего несколько классов — Test , TestCase и
TestSuite , а также связи между ними. Обычно,
фреймворк имеет гораздо больший охват, чем один класс.
Вы должны вклиниться в фреймворк, расширив какой-то из
его классов. Всё работает по так называемому
голливудскому принципу "не звоните нам, мы сами вам
перезвоним". Фреймворк позволяет вам задать какое-то
своё поведение, а затем сам вызывает его, когда приходит
черёд что-то делать. То же происходит и в JUnit. Он
“
30 Качества хорошей архитектуры / Повторное использование кода
Расширяемость
Изменения часто называют главным врагом программиста.
• Вы придумали идеальную архитектуру интернет-магазина,
но через месяц пришлось добавить интерфейс для заказов
по телефону.
• Вы выпустили видео игру под Windows, но затем
понадобилась поддержка macOS.
обращается к вашему классу, когда нужно выполнить тест,
но всё остальное происходит внутри фреймворка.
Есть ещё средний уровень. Это то, где я вижу паттерны.
Паттерны проектирования и меньше, и более абстрактные,
чем фреймворки. Они, на самом деле, просто описание того,
как парочка классов относится и взаимодействует друг с
другом. Уровень повторного использования повышается,
когда вы двигаетесь в направлении от конкретных классов к
паттернам, а затем к фреймворкам.
Что ещё замечательно в этом среднем уровне так это то, что
паттерны — это менее рискованный способ повторного
использования, чем фреймворки. Разработка фреймворка —
это крайне рисковая и дорогая инвестиция. В то же время,
паттерны позволяют вам повторно использовать идеи и
концепции в отрыве от конкретного кода.
„
31 Качества хорошей архитектуры / Расширяемость
• Вы сделали интерфейсный фреймворк с квадратными
кнопками, но клиенты начали просить круглые.
У каждого программиста есть дюжина таких историй. Есть
несколько причин, почему так происходит.
Во-первых, все мы понимаем проблему лучше в процессе
её решения. Нередко к концу работы над первой версией
программы, мы уже готовы полностью её переписать, так
как стали лучше понимать некоторые аспекты, которые не
были очевидны вначале. Сделав вторую версию, вы
начинаете понимать проблему ещё лучше, вносите ещё
изменения и так далее — процесс не останавливается
никогда, ведь не только ваше понимание, но и сама
проблема может измениться со временем.
Во-вторых, изменения могут прийти извне. У вас есть
идеальный клиент, который с первого раза сформулировал
то, что ему надо, а вы в точности это сделали. Прекрасно!
Но вот, выходит новая версия операционной системы, в
которой ваша программа перестаёт работать. Чертыхаясь,
вы лезете в код, чтобы внести кое-какие изменения.
Можно посмотреть на это с оптимистичной стороны:
если кто-то просит вас что-то изменить в программе,
значит она всё ещё кому-то нужна.
32 Качества хорошей архитектуры / Расширяемость
Вот почему даже мало-мальски опытный программист
проектирует архитектуру и пишет код с учётом будущих
изменений.
33 Качества хорошей архитектуры / Расширяемость
Базовые принципы
проектирования
Что такое хороший дизайн? По каким критериям его
оценивать, и каких правил придерживаться при
разработке? Как обеспечить достаточный уровень гибкости,
связанности, управляемости, стабильности и понятности
кода?
Всё это правильные вопросы, но для каждой программы
ответ будет чуточку отличаться. Давайте рассмотрим
универсальные принципы проектирования, которые
помогут вам формулировать ответы на эти вопросы
самостоятельно.
Кстати, большинство паттернов, приведённых в этой книге,
основанны именно на перечисленных ниже принципах.
34 Базовые принципы
Инкапсулируйте то, что меняется
Определите аспекты программы, класса или метода,
которые меняются чаще всего и отделите их того, что
остаётся постоянным.
Этот принцип преследует единственную цель — уменьшить
последствия, вызываемые изменениями.
Представьте, что ваша программа — это корабль, а
изменения — коварные мины, которые его подстерегают.
Натыкается на мину, корабль заполняется водой и тонет.
Зная это, вы можете разделить корабль на независимые
секции, проходы между которыми можно наглухо
задраивать. Теперь при встрече с миной корабль останется
на плаву. Вода затопит лишь одну секцию, оставив
остальные без изменений.
Изолируя изменчивые части программы в отдельных
модулях, классах или методах, вы уменьшаете количество
кода, который затронут последующие изменения.
Следовательно, вам нужно будет потратить меньше усилий
на то, чтобы привести программу в рабочее состояние,
отладить и протестировать изменившийся код. Где меньше
работы, там меньше стоимость разработки. А где меньше
стоимость, там и преимущество перед конкурентами.
35 Базовые принципы / Инкапсулируйте то, что меняется
Пример инкапсуляции на уровне метода
Представьте, что вы разрабатываете интернет-магазин. Гдето внутри вашего кода может существовать метод
getOrderTotal , который рассчитывает финальную сумму
заказа, учитывая размер налога.
Мы можем предположить, что код вычисления налогов
скорей всего будет часто меняться. Во-первых, логика
начисления налога зависит от страны, штата и даже города,
в котором находится покупатель. К тому же размер налога
не постоянен — власти могут менять его, когда вздумается.
Из-за этих изменений вам постоянно придётся трогать
метод getOrderTotal , который, по правде, не особо
интересуется деталями вычисления налогов.
ДО: правила вычисления налогов смешаны с основным кодом метода.
1 method getOrderTotal(order) is
2 total = 0
3 foreach item in order.lineItems
4 total += item.price * item.quantity
5
6 if (order.country == "US")
7 total -= total * 0.07 // US sales tax
8 else if (order.country == "EU"):
9 total -= total * 0.20 // European VAT
10
11 return total
36 Базовые принципы / Инкапсулируйте то, что меняется
Вы можете перенести логику вычисления налогов в
собственный метод, скрыв детали от оригинального метода.
ПОСЛЕ: размер налога можно получить, вызвав один метод.
Теперь изменения налогов будут изолированы в рамках
одного метода. Более того, если логика вычисления налогов
станет ещё более сложной, вам будет легче извлечь этот
метод в собственный класс.
Пример инкапсуляции на уровне класса
Извлечь логику налогов в собственный класс? Если логика
налогов стала слишком сложной, то почему бы и нет?
1 method getOrderTotal(order) is
2 total = 0
3 foreach item in order.lineItems
4 total += item.price * item.quantity
5
6 total -= total * getTaxAmount(order.country)
7
8 return total
9
10 method getTaxAmount(country) is
11 if (country == "US")
12 return 0.07 // US sales tax
13 else if (country == "EU"):
14 return 0.20 // European VAT
15 else
16 return 0
37 Базовые принципы / Инкапсулируйте то, что меняется
ДО: вычисление налогов в классе заказов.
Объекты заказов станут делегировать вычисление налогов
отдельному объекту-калькулятору налогов.
ПОСЛЕ: вычисление налогов скрыто в классе заказов.
38 Базовые принципы / Инкапсулируйте то, что меняется
Программируйте на уровне интерфейса
Программируйте на уровне интерфейса, а не на
уровне реализации. Код должен зависеть от
абстракций, а не конкретных классов.
Гибкость архитектуры выражает в том, чтобы её можно
было расширять, не ломая существующий код. Для примера
вернёмся к классу котов. Класс Кот , который ест только
сардельки, будет менее гибким, чем тот, что может есть
любую еду. Но при этом, последнего можно будет кормить и
сардельками, ведь они являются едой.
Когда вам нужно наладить взаимодействие между двумя
объектами разных классов, самое простое, что вы можете
сделать, это сделать один класс зависимым от другого. Что
говорить, зачастую, я и сам с этого начинаю. Но есть и
другой, более гибкий, способ.
1. Определите, что именно нужно одному объекту от другого,
какие методы он вызывает.
2. Затем, опишите эти методы в отдельном интерфейсе.
3. Сделайте так, чтобы класс-зависимость следовал этому
интерфейс. Скорей всего, нужно будет только добавить этот
интерфейс в описание класса.
4. Теперь вы можете и сделать второй класс зависимым от
интерфейса, а не конкретного класса.
39 Базовые принципы / Программируйте на уровне интерфейса
До и после извлечения интерфейса.
Код справа более гибкий, чем тот, что слева, но и более сложный.
Проделав всё это вы, скорей всего, не получите
немедленной выгоды. Но зато в будущем, вы сможете
использовать альтернативные реализации классов, не
изменяя использующий их код.
Пример
Давайте рассмотрим ещё один пример, где работа на
уровне интерфейса оказывается выигрышней привязки к
конкретным классам. Представьте, что вы делаете
симулятор софтверной компании. У вас есть различные
40 Базовые принципы / Программируйте на уровне интерфейса
классы работников, которые делают ту или иную работу
внутри компании.
ДО: классы жёстко связаны.
Вначале класс компании жёстко привязан к конкретным
классам работников. Несмотря на то, что каждый тип
работников делает разную работу, мы можем свести их
методы работы к одному виду, выделив для всех классов
общий интерфейс.
Сделав это, мы сможем применить полиморфизм в классе
компании, трактуя всех работников единообразно через
интерфейс Employee .
41 Базовые принципы / Программируйте на уровне интерфейса
ЛУЧШЕ: полиморфизм помог упросить код, но основной код компании всё ещё
зависит от конкретных классов сотрудников.
Тем не менее, класс компании всё ещё остаётся жёстко
привязанным к конкретным классам работников. Это не
очень хорошо, особенно, если предположить, что нам
понадобится реализовать несколько видов компаний. Все
эти компании будут отличаться тем, какие конкретно
работники в них нужны.
Мы можем сделать метод получения сотрудников в базовом
классе компании абстрактным. Конкретные компании
должны будут сами позаботиться о создании объектов
сотрудников. А значит — каждый тип компаний сможет
иметь собственный набор сотрудников.
42 Базовые принципы / Программируйте на уровне интерфейса
ПОСЛЕ: основной код класса компании стал независимым от классов
сотрудников. Конкретных сотрудников создают конкретные классы компаний.
После этого изменения, код класса компании стал
окончательно независимым от конкретных классов. Теперь
мы можем добавлять в программу новые виды работников
и компаний, не внося изменений в основной код базового
класса компаний.
Кстати, вы только что увидели пример одного из паттернов,
а именно — Фабричного метода. Мы ещё вернёмся к нему в
дальнейшем.
43 Базовые принципы / Программируйте на уровне интерфейса
Предпочитайте композицию
наследованию
Наследование — это самый простой и быстрый способ
повторного использования кода между классами. У вас есть
два класса с дублирующимся кодом. Создайте для них
общий базовый класс и перенесите в него общее
поведение. Что может быть проще?
Но у наследования есть и проблемы, которые стают
очевидными только тогда, когда программа обросла
классами и изменить ситуацию уже довольно тяжело. Вот
некоторые их возможных проблем с наследованием.
• Подкласс не может отказаться от интерфейса или
реализации своего родителя. Вы должны будете
реализовать все абстрактные методы родителя, даже если
они не нужны для конкретного подкласса.
• Переопределяя методы родителя, вы должны заботиться о
том, чтобы не сломать базовое поведение суперкласса. Это
важно, ведь подкласс может быть использован в любом
коде, работающим с суперклассом.
• Наследование нарушает инкапсуляцию суперкласса, так как
подклассам доступны детали родителя. Суперклассы могут
сами стать зависимыми от подклассов, например, если
программист вынесет в суперкласс какие-то общие детали
подклассов, чтобы облегчить дальнейшее наследование.
44 Базовые принципы / Предпочитайте композицию наследованию
• Подклассы слишком тесно связаны с родительским
классом. Любое изменение в родителе может сломать
поведение в подклассах.
• Повторное использование кода через наследование может
привести к разрастанию иерархии классов.
У наследования есть альтернатива, называемая
композицией. Если наследование можно выразить словом
«является» (автомобиль является транспортом), то
композицию — словом «содержит» (автомобиль содержит
двигатель).
Этот принцип распространяется и на агрегацию — более
свободный вид композиции, когда два объекта являются
равноправными, и ни один из них не управляет жизненным
циклом другого. Оцените разницу: автомобиль содержит и
водителя, но тот может выйти и пересесть в другой
автомобиль или вообще пойти пешком самостоятельно.
Пример
Предположим, вам нужно смоделировать модельный ряд
автопроизводителя. У вас есть легковые автомобили и
грузовики. Причём, они бывают с электрическим
двигателем, и с двигателем на бензине. К тому же, они
отличаются режимами навигации — есть модели с ручным
управлением и автопилотом.
45 Базовые принципы / Предпочитайте композицию наследованию
НАСЛЕДОВАНИЕ: развитие классов в нескольких плоскостях (тип груза ? тип
двигателя ? тип навигации) приводит к комбинаторному взрыву.
Как видите, каждый такой параметр приводит к умножению
количества классов. Кроме того, возникает проблема
дублирования кода, так как подклассы не могут
наследовать нескольких родителей одновременно.
Решить проблему можно с помощью композиции. Вместо
того, чтобы объекты сами реализовывали то или иное
поведение, они могут делегировать его другим объектам.
Композиция даёт вам и другое преимущество. К примеру,
теперь вы можете заменить тип двигатель автомобиля
прямо во время выполнения программы, подставив в
объект транспорта другой объект двигателя.
46 Базовые принципы / Предпочитайте композицию наследованию
КОМПОЗИЦИЯ: различные виды функциональности выделены в собственные
иерархии классов.
Такая структура свойственна паттерну Стратегия, о
котором мы тоже поговорим в этой книге.
47 Базовые принципы / Предпочитайте композицию наследованию
Принципы SOLID
Рассмотрим ещё пять принципов проектирования, которые
известны как SOLID. Эти принципы были впервые изложены
Робертом Мартином в книге Agile Software Development,
Principles, Patterns, and Practices1
.
Достичь такой лаконичности в названии удалось, используя
небольшую хитрость. Дело в том, что термин SOLID - это
аббревиатура, за каждой буквой которой стоит отдельный
принцип проектирования.
Главная цель этих принципов — повысить гибкость вашей
архитектуры, уменьшить связанность между её
компонентами и облегчить повторное использование кода.
Но, как и всё в этой жизни, соблюдение этих принципов
имеет свою цену. Здесь это в основном выражается в
усложнении кода программы. В реальной жизни, пожалуй,
нет такого кода, в котором бы соблюдались все эти
принципы сразу. Поэтому помните о балансе и не
воспринимайте всё изложенное как догму.
1. Agile Software Development, Principles, Patterns, and Practices
(https://refactoring.guru/ru/principles-book).
48 Принципы SOLID
S
Принцип единой ответственности
ingle Responsibility Principle
У класса должна быть только один мотив для
изменения.
Стремитесь к тому, чтобы каждый класс отвечал только за
одну часть функциональности программы, причём она
должна быть полностью инкапсулирована в этот класс
(читай, скрыта внутри класса).
Принцип единственной ответственности предназначен для
борьбы со сложностью. Когда в вашем приложении всего
200 строк, то дизайн как таковой вообще не нужен.
Достаточно аккуратно написать 5-7 методов и всё будет
хорошо. Проблемы возникают, когда система растёт и
увеличивается в масштабах. Когда класс разрастается, он
просто перестаёт помещаться в голове. Навигация
затрудняется, на глаза попадаются ненужные детали,
связанные с другим аспектом, в результате, количество
понятий начинают превышать мозговой стек, и вы
начинаете терять контроль над кодом.
Если класс делает слишком много вещей сразу, вам
приходится изменять его каждый раз, когда одна из этих
вещей изменяется. При этом есть риск сломать остальные
части класса, которые вы даже не планировали трогать.
49 Принципы SOLID / S: Принцип единой ответственности
Хорошо иметь возможность сосредоточиться на сложных
аспектах системы по отдельности. Но если вам становится
сложно это делать, применяйте принцип единственной
ответственности, разделяя ваши классы на части.
Пример
Класс Employee имеет сразу несколько причин для
изменения. Первая связана с основной задачей класса —
это управлением данными сотрудника. Но есть и вторая:
изменения, связанные с форматированием отчёта для
печати, будут затрагивать класс сотрудников.
ДО: класс сотрудника содержит разнородные поведения.
Проблему можно решить, выделив операцию печати в
отдельный класс.
ПОСЛЕ: лишнее поведение переехало в собственный класс.
50 Принципы SOLID / S: Принцип единой ответственности
O
Принцип открытости/закрытости
pen/closed Principle
Расширяйте классы, но не изменяйте их
первоначальный код.
Стремитесь к тому, чтобы классы были открыты для
расширения, но закрыты для изменения. Главная идея этого
принципа в том, чтобы не ломать существующий код при
внесении изменений в программу.
Класс можно назвать открытым, если он доступен для
расширения. Например, у вас есть возможность расширить
набор его операций или добавить к нему новые поля,
создав собственный подкласс.
В то же время, класс можно назвать закрытым (а лучше
сказать законченным), если он готов для использования
другими классами. Это означает, что интерфейс класса уже
окончательно определён и не будет изменяться в будущем.
Если класс уже был написан, одобрен, протестирован,
возможно, внесён в библиотеку и включён в проект, после
этого пытаться модифицировать его содержимое не
желательно. Вместо этого, вы можете создать подкласс и
расширить в нём базовое поведение, не изменяя код
родительского класса напрямую.
51 Принципы SOLID / O: Принцип открытости/закрытости
Но не стоит следовать этому принципу буквально для
каждого изменения. Если вам нужно исправить ошибку в
исходном классе, просто возьмите и сделайте это. Нет
смысла решать проблему родителя в дочернем классе.
Пример
Класс заказов имеет метод расчёта стоимости доставки,
причём способы доставки «зашиты» непосредственно в сам
метод. Если вам нужно будет добавить новый способ
доставки, то придётся трогать весь класс Order .
ДО: код класса заказа нужно будет изменять при добавлении нового
способа доставки.
Проблему можно решить, если применить паттерн
Стратегия. Для этого нужно выделить способы доставки в
собственные классы с общим интерфейсом.
52 Принципы SOLID / O: Принцип открытости/закрытости
ПОСЛЕ: новые способы доставки можно добавить, не трогая класс заказов.
Теперь при добавлении нового способа доставки нужно
будет реализовать новый класс интерфейса доставки, не
трогая класса заказов. Объект способа доставки в класс
заказа будет подавать клиентский код, который раньше
устанавливал способ доставки простой строкой.
Бонус этого решения в том, что расчёт времени и даты
доставки тоже можно поместить в новые классы, повинуясь
принципу единственной ответственности.
53 Принципы SOLID / O: Принцип открытости/закрытости
L
Принцип подстановки Лисков1
iskov Substitution Principle
Подклассы должны дополнять, а не замещать
поведение базового класса.
Стремитесь создавать подклассы таким образом, чтобы их
объекты можно было бы подставлять вместо объектов
базового класса, не ломая при этом функциональности
клиентского кода.
Принцип подстановки — это ряд проверок, которые
помогают предсказать, останется ли подкласс совместим с
остальным кодом программы, который до этого успешно
работал, используя объекты базового класса. Это особенно
важно при разработке библиотек и фреймворков, когда
ваши классы используются другими людьми, и вы не
можете повлиять на чужой клиентский код, даже если бы
хотели.
В отличие от других принципов, которые определены очень
свободно и имеют массу трактовок, принцип подстановки
имеет ряд формальных требований к подклассам, а точнее
к переопределённым в них методах.
1. Принцип назван в честь Барбары Лисков, которая впервые
сформулировала его 1987 году в работе Data abstraction and hierarchy:
https://refactoring.guru/liskov/dah
54 Принципы SOLID / L: Принцип подстановки Лисков
• Типы параметров метода подкласса должны совпадать или
быть боле абстрактными, чем типы параметров базового
метода. Довольно запутанно? Рассмотрим, как это работает
на примере.
? Базовый класс содержит метод feed(Cat c) , который
умеет кормить домашних котов. Клиентский код это
знает и всегда передаёт в метод кота.
? Хорошо: Вы создали подкласс, и переопределили метод
кормёжки так, чтобы накормить любое животное:
feed(Animal c) . Если подставить этот подкласс в
клиентский код, то ничего страшного не произойдёт.
Клиентский код подаст в метод кота, но метод умеет
кормить всех животных, поэтому накормит и кота.
? Плохо: Вы создали другой подкласс, в котором метод
умеет кормить только бенгальскую породу котов
(подкласс котов): feed(BengalCat t) . Что будет с
клиентским кодом? Он всё так же подаст в метод
обычного кота. Но метод умеет кормить только бенгалов,
поэтому не сможет отработать, сломав клиентский код.
• Тип возвращаемого значения метода подкласса должен
совпадать или быть подтипом возвращаемого значения
базового метода. Здесь всё то же, что и в предыдущем
пункте, но наоборот.
? Базовый метод: buyCat(): Cat . Клиентский код ожидает
на выходе любого домашнего кота.
55 Принципы SOLID / L: Принцип подстановки Лисков
? Хорошо: Метод подкласса: buyCat(): BengalCat .
Клиентский код получит бенгальского кота, который
является домашним котом, поэтому всё будет хорошо.
? Плохо: Метод подкласса: buyCat(): Animal . Клиентский
код сломается, так как это непонятное животное
(возможно, крокодил) не поместится в ящике-переноске
для кота.
Ещё один анти-пример, из мира языков с динамической
типизацией: базовый метод возвращает строку, а
переопределённый метод — число.
• Метод не должен выбрасывать исключения, которые не
свойственны базовому методу. Типы исключений в
переопределённом методе должны совпадать или быть
подтипами исключений, которые выбрасывает базовый
метод. Блоки try-catch в клиентском коде нацелены на
конкретные типы исключений, выбрасываемые базовым
методом. Поэтому неожиданное исключение, выброшенное
подклассом, может проскочить сквозь обработчики
клиентского кода и обрушить программу.
В большинстве современных языков
программирования, особенно строго типизированных
(Java, C# и другие), перечисленные ограничения
встроены прямо в компилятор. Поэтому вы попросту
не сможете собрать программу, нарушив их.
56 Принципы SOLID / L: Принцип подстановки Лисков
• Метод не должен ужесточать _пред_условия. Например,
базовый метод работает с параметром типа int . Если
подкласс требует, чтобы значение этого параметра к тому
же было больше нуля, то это ужесточает предусловия.
Клиентский код, который до этого отлично работал, подавая
в метод негативные числа, теперь сломается при работе с
объектом подкласса.
• Метод не должен ослаблять _пост_условия. Например,
базовый метод требует, чтобы по завершению метода все
подключения к базе данных были бы закрыты, а подкласс
оставляет эти подключения открытыми, чтобы потом
повторно использовать. Но клиентский код базового класса
ничего об этом не знает. Он может завершить программу
сразу после вызова метода, оставив запущенные процессыпризраки в системе.
• Инварианты класса должны остаться без изменений.
Инвариант — это набор условий, при которых объект имеет
смысл. Например, инвариант кота — это наличие четырёх
лап, хвоста, способность мурчать и прочее. Инвариант
может быть описан не только явным контрактом или
проверками в методах класса, но и косвенно, например,
юнит-тестами или клиентским кодом.
Этот пункт проще всего нарушить при наследовании, так
как вы можете попросту не подозревать о каком-то из
условий инварианта сложного класса. Идеальным в этом
57 Принципы SOLID / L: Принцип подстановки Лисков
отношении был бы подкласс, который только вводит новые
методы и поля, не прикасаясь к полям базового класса.
• Подкласс не должен изменять значения приватных полей
базового класса. Этот пункт звучит странно, но в некоторых
языках доступ к приватным полям можно получить через
механизм рефлексии. В некоторых других языках (Python,
JavaScript) и вовсе нет жёсткой защиты приватных полей.
Пример
Чтобы закрыть тему принципа подстановки, давайте
рассмотрим пример неудачной иерархии классов
документов.
ДО: подкласс «обнуляет» работу базового метода.
58 Принципы SOLID / L: Принцип подстановки Лисков
Метод сохранения в подклассе ReadOnlyDocuments
выбросит исключение, если кто-то попытается вызвать его
метод сохранения. Базовый метод не имеет такого
ограничения. Из-за этого, клиентский код вынужден
проверять тип документа при сохранении всех документов.
При этом нарушается ещё и принцип открытости/
закрытости, так как клиентский код начинает зависеть от
конкретного класса, который нельзя заменить на другой, не
внося изменений в клиентский код.
ПОСЛЕ: подкласс расширяет базовый класс новым поведением.
Проблему можно решить, если перепроектировав
иерархию классов. Базовый класс сможет только открывать
документы, но не сохранять их. Подкласс, который теперь
будет называться WritableDocument , расширит поведение
родителя, позволив сохранять документ.
59 Принципы SOLID / L: Принцип подстановки Лисков
I
Принцип разделения интерфейса
nterface Segregation Principle
Клиенты не должны зависеть от методов, которые они
не используют.
Стремитесь к тому, чтобы интерфейсы были достаточно
узкими, чтобы классам не приходилось реализовывать
избыточное поведение.
Принцип разделения интерфейсов говорит о том, что
слишком «толстые» интерфейсы необходимо разделять на
более маленькие и специфические, чтобы клиенты
маленьких интерфейсов знали только о методах, которые
необходимы им в работе. В итоге, при изменении метода
интерфейса не должны меняться клиенты, которые этот
метод не используют.
Наследование позволяет классу иметь только один
суперкласс, но не ограничивает количество интерфейсов,
которые он может реализовать. Большинство объектных
языков программирования позволяют классам
реализовывать сразу несколько интерфейсов, поэтому нет
нужды заталкивать в ваш интерфейс больше поведений,
чем он того требует. Вы всегда можете присвоить классу
сразу несколько интерфейсов поменьше.
60 Принципы SOLID / I: Принцип разделения интерфейса
Пример
Представьте библиотеку для работы с облачными
провайдерами. В первой версии она поддерживала только
с Amazon, имеющий полный набор облачных услуг. Исходя
из них и проектировался интерфейс будущих классов.
Но позже стало ясно, что получившийся интерфейс
облачного провайдера слишком широк, так как есть другие
провайдеры, реализующие только часть из всех возможных
сервисов.
ДО: не все клиенты могут реализовать операции интерфейса.
61 Принципы SOLID / I: Принцип разделения интерфейса
Чтобы не плодить классы с пустой реализацией, раздутый
интерфейс можно разбить на части. Классы, которые были
способны реализовать все операции старого интерфейса
могут реализовать сразу несколько новых частичных
интерфейсов.
ПОСЛЕ: раздутый интерфейс разбит на части.
62 Принципы SOLID / I: Принцип разделения интерфейса
D
Принцип инверсии зависимостей
ependency Inversion Principle
Классы верхних уровней не должны зависеть от
классов нижних уровней. Оба должны зависеть от
абстракций. Абстракции не должны зависеть от
деталей. Детали должны зависеть от абстракций.
Обычно, при проектировании программ можно выделить
два уровня классов.
• Классы нижнего уровня реализуют базовые операции
вроде работы с диском, передачи данных по сети,
подключению к базе данных и прочее.
• Классы высокого уровня содержат сложную бизнес-логику
программы, которая опирается на классы низкого уровня
для осуществления более простых операций.
Зачастую, вы сперва проектируете классы нижнего уровня,
а только потом берётесь за верхний уровень. При таком
подходе классы бизнес-логики становятся зависимыми от
более примитивных низкоуровневых классов. Каждое
изменения в низкоуровневом классе может затронуть
классы бизнес-логики, которые его используют.
Принцип инверсии зависимостей предлагает изменить
направление, в котором происходит проектирование.
63 Принципы SOLID / D: Принцип инверсии зависимостей
1. Для начала вам нужно описать интерфейс низкоуровневых
операций, которые нужны классу бизнес-логики.
2. Это позволит вам убрать зависимость класса бизнес-логики
от конкретного низкоуровневого класса, заменив её
«мягкой» зависимостью от интерфейса.
3. Низкоуровневый класс, в свою очередь, станет зависимый
от интерфейса, определённого бизнес-логикой.
Принцип инверсии зависимостей часто идёт в ногу с
принципом открытости/закрытости: вы сможете расширять
низкоуровневые классы и использовать их вместе с
классами бизнес-логики, не изменяя код последних.
Пример
В этом примере высокоуровневый класс формирования
бюджетных отчётов напрямую использует класс базы
данных для загрузки и сохранения своей информации.
ДО: высокоуровневый класс зависит от низкоуровневого.
64 Принципы SOLID / D: Принцип инверсии зависимостей
Вы можете исправить проблему, создав высокоуровневый
интерфейс для загрузки/сохранения данных и привязать к
нему класс отчётов. Низкоуровневые классы должны
реализовать этот интерфейс, чтобы их объекты можно было
использовать внутри объекта отчётов.
ПОСЛЕ: низкоуровневые классы зависят от высокоуровневой абстракции.
Таким образом, меняется направление зависимости. Если
раньше высокий уровень зависел от низкого, то сейчас всё
наоборот — низкоуровневые классы зависят от
высокоуровневого интерфейса.
65 Принципы SOLID / D: Принцип инверсии зависимостей
КАТАЛОГ
ПАТТЕРНОВ
Порождающие
паттерны
Эти паттерны отвечают за удобное и безопасное создание
новых объектов или даже целых семейств объектов.
Фабричный Метод
Factory Method
Определяет общий интерфейс для создания объектов в
суперклассе, позволяя подклассам изменять тип создаваемых
объектов.
Абстрактная Фабрика
Abstract Factory
Позволяет создавать семейства связанных объектов, не
привязываясь к конкретным классам создаваемых объектов.
67 Порождающие паттерны
Строитель
Builder
Позволяет создавать сложные объекты пошагово. Строитель
даёт возможность использовать один и тот же код
строительства для получения разных представлений объектов.
Прототип
Prototype
Позволяет копировать объекты, не вдаваясь в подробности их
реализации.
Одиночка
Singleton
Гарантирует, что у класса есть только один экземпляр, и
предоставляет к нему глобальную точку доступа.
68 Порождающие паттерны
ФАБРИЧНЫЙ
МЕТОД
Также известен как: Виртуальный конструктор, Factory Method
Фабричный метод — это порождающий паттерн
проектирования, который определяет общий интерфейс для
создания объектов в суперклассе, позволяя подклассам
изменять тип создаваемых объектов.
69 Порождающие паттерны / Фабричный метод
? Проблема
Представьте, что вы создаёте программу управления
грузовыми перевозками. Сперва вы рассчитываете
перевозить товары только на автомобилях. Поэтому весь
ваш код работает с объектами класса Грузовик .
В какой-то момент ваша программа становится настолько
известной, что морские перевозчики выстраиваются в
очередь и просят добавить поддержку морской логистики в
программу.
Добавить новый класс не так то просто, если весь код уже завязан на
конкретные классы.
Отличные новости, правда?! Но как насчёт кода? Большая
часть существующего кода жёстко привязана к классам
Грузовиков . Чтобы добавить в программу классы морских
Судов понадобится перелопатить всю программу. Более
того, если вы потом решите добавить ещё один вид
транспорта, то всю эту работы придётся повторить.
70 Порождающие паттерны / Фабричный метод
В итоге вы получите ужасающий код, наполненный
условными операторами, которые выполняют то или иное
действие, в зависимости от класса транспорта.
? Решение
Паттерн Фабричный метод предлагает создавать объекты
не напрямую, используя оператор new , а через вызов
особого фабричного метода. Не пугайтесь, объекты всё
равно будут создаваться при помощи new , но делать это
будет фабричный метод.
Подклассы могут изменять класс создаваемых объектов.
На первый взгляд, это может показаться бессмысленным
— мы просто переместили вызов из одного конца
программы в другой. Но теперь вы сможете
переопределить фабричный метод в подклассе, чтобы
изменить тип создаваемого продукта.
71 Порождающие паттерны / Фабричный метод
Чтобы эта система работала, все возвращаемые объекты
должны иметь общий интерфейс. Подклассы смогут
производить объекты различных классов, следующих
одному и тому же интерфейсу.
Все объекты-продукты должны иметь общий интерфейс.
Например, классы Грузовик и Судно реализуют
интерфейс Транспорт с методом доставить . Каждый из
этих классов реализует метод по-своему: грузовики везут
грузы по земле, а судна — по морю. Фабричный метод в
классе ДорожнойЛогистики вернёт грузовик, а класс
МорскойЛогистики — судно.
Для клиента фабричного метода нет разницы между этими
объектами, так как он будет трактовать их как некий
абстрактный Транспорт .
72 Порождающие паттерны / Фабричный метод
Покуда все продукты реализуют общий интерфейс, их объекты можно
взаимозаменять в клиентском коде.
Для него будет важно, чтобы объект имел метод доставить ,
а как конкретно он работает — не важно.
? Структура
73 Порождающие паттерны / Фабричный метод
1. Продукт определяет общий интерфейс объектов, которые
может произвести создатель и его подклассы.
2. Конкретные продукты содержат код различных продуктов.
Продукты будут отличаться реализацией, но интерфейс у
них будет общий.
3. Создатель объявляет фабричный метод, создающий
объекты через общий интерфейс продуктов.
Зачастую фабричный метод объявляют абстрактным, чтобы
заставить все подклассы реализовать фабричный метод посвоему. Однако он может возвращать и какой-то продукт по
умолчанию.
Несмотря на название, важно понимать, что создание
продуктов не является единственной и главной функцией
создателя. Обычно он содержит и другой полезный код
работы с продуктом. Аналогия: в большой софтверной
компании может быть центр подготовки программистов, но
основная задача компании — писать код, а не готовить
программистов.
4. Конкретные создатели по-своему реализуют фабричный
метод, производя те или иные конкретные продукты.
Фабричный метод не обязан всё время создавать новые
объекты. Его можно переписать так, чтобы возвращать
существующие объекты из какого-то хранилища или кэша.
74 Порождающие паттерны / Фабричный метод
? Псевдокод
В этом примере Фабричный метод помогает создавать
кросс-платформенные элементы интерфейса, не
привязывая основной код к конкретным классам
элементов.
Фабричный метод объявлен в классе диалогов. Его
подклассы относятся к различным операционным системам.
Благодаря фабричному методу, вам не нужно переписывать
логику диалогов под каждую систему. Подклассы могут
наследовать почти весь код из базового диалога, изменяя
типы кнопок и других элементов, из которых базовый код
строит окна.
Пример кросс-платформенного диалога.
75 Порождающие паттерны / Фабричный метод
Базовый класс диалогов работает с кнопками через их
общий интерфейс. Поэтому, какую вариацию кнопок бы ни
вернул фабричный метод, диалог останется рабочим.
Базовый класс не зависит от конкретных классов кнопок,
оставляя подклассам решение о том, какой тип кнопок
создавать.
Такой подход можно применить и для создания других
элементов интерфейса. Хотя каждый новый тип элементов
будет приближать вас к Абстрактной фабрике.
1 // Паттерн Фабричный Метод применим тогда, когда есть
2 // иерархия классов продуктов.
3 interface Button is
4 method render()
5 method onClick(f)
6
7 class WindowsButton implements Button is
8 method render(a, b) is
9 // Отрисовать кнопку в стиле Windows.
10 method onClick(f) is
11 // Навесить на кнопку нативный обработчик события.
12
13 class HTMLButton implements Button is
14 method render(a, b) is
15 // Вернуть HTML-код кнопки.
16 method onClick(f) is
17 // Навесить на кнопку обработчик события браузера.
18
19
20
76 Порождающие паттерны / Фабричный метод
21 // Базовый класс фабрики. Заметьте, что "фабрика" – это
22 // всего лишь дополнительная роль для класса. Он уже имеет
23 // какую-то бизнес-логику, в которой требуется создание
24 // разнообразных продуктов.
25 class Dialog is
26 method renderWindow() is
27 // Отрисовать остальные элементы интерфейса.
28
29 Button okButton = createButton()
30 okButton.onClick(closeDialog)
31 okButton.render()
32
33 // Мы выносим весь код создания продуктов в особый
34 // Фабричный метод.
35 abstract method createButton()
36
37
38 // Конкретные фабрики переопределяют фабричный метод и
39 // возвращают из него собственные продукты.
40 class WindowsDialog extends Dialog is
41 method createButton() is
42 return new WindowsButton()
43
44 class WebDialog extends Dialog is
45 method createButton() is
46 return new HTMLButton()
47
48
49 class ClientApplication is
50 field dialog: Dialog
51
52 // Приложение создаёт определённую фабрику в зависимости
53 // от конфигурации или окружения.
54 method initialize() is
77 Порождающие паттерны / Фабричный метод
? Применимость
? Когда заранее неизвестны типы и зависимости объектов, с
которыми должен работать ваш код.
? Фабричный метод отделяет код производства продуктов от
остального кода, который эти продукты использует.
Благодаря этому, код производства можно расширять, не
трогая основной код. Так, чтобы добавить поддержку
нового продукта, вам нужно создать новый подкласс и
определить в нём фабричный метод, возвращая оттуда
экземпляр нового продукта.
55 config = readApplicationConfigFile()
56
57 if (config.OS == "Windows") then
58 dialog = new WindowsDialog()
59 else if (config.OS == "Web") then
60 dialog = new WebDialog()
61 else
62 throw new Exception("Error! Unknown operating system.")
63
64 // Весь остальной клиентский код работает с фабрикой и
65 // продуктами только через общий интерфейс, поэтому для
66 // него неважно какая фабрика была создана.
67 method main() is
68 dialog.initialize()
69 dialog.render()
78 Порождающие паттерны / Фабричный метод
? Когда вы хотите дать возможность пользователям
расширять части вашего фреймворка или библиотеки.
? Пользователи могут расширять классы вашего фреймворка
через наследование. Но как сделать так, чтобы фреймворк
создавал объекты из этих новых классов, а не из
стандартных?
Решением будет дать пользователям возможность
расширять не только желаемые компоненты, но и классы,
которые создают эти компоненты. А для этого создающие
классы должны иметь конкретные создающие методы,
которые можно определить.
Например, вы используете готовый UI-фреймворк для
своего приложения. Но вот беда, требуется иметь круглые
кнопки, вместо стандартных прямоугольных. Вы создаёте
класс RoundButton . Но как сказать главному классу
фреймворка ( UIFramework ), чтобы он теперь создавал
круглые кнопки, вместо стандартных.
Для этого вы создаёте подкласс UIWithRoundButtons из
базового класса фреймворка, переопределяете в нём метод
создания кнопки ( createButton ) и вписываете туда
создание своего класса кнопок. Затем, используете
UIWithRoundButtons вместо стандартного UIFramework .
? Когда вы хотите экономить системные ресурсы, повторно
используя уже созданные объекты, вместо создания новых.
79 Порождающие паттерны / Фабричный метод
? Такая проблема обычно возникает при работе с тяжёлыми
ресурсоёмкими объектами, такими как подключение к базе
данных, файловой системе и т.д.
Представьте, сколько действий вам нужно совершить, чтобы
повторно использовать существующие объекты:
1. Сперва вам следует создать общее хранилище, чтобы
хранить вы нём все создаваемые объекты.
2. При запросе нового объекта, нужно будет заглянуть в
хранилище и проверить, есть ли там неиспользуемый
объект.
3. А затем вернуть его клиентскому коду.
4. Но если свободных объектов нет — создать новый, не
забыв добавить его в хранилище.
Весь этот код нужно куда-то поместить, чтобы не засорять
клиентский код.
Самым удобным местом был бы конструктор объекта, ведь
все эти проверки нужны только при создании объектов. Но,
увы, конструктор всегда создаёт новые объекты, он не
может вернуть существующий экземпляр.
Значит, должен другой метод, который бы отдавал как
существующие, так и новые объекты. Им и станет
фабричный метод.
80 Порождающие паттерны / Фабричный метод
? Шаги реализации
1. Приведите все создаваемые продукты к общему
интерфейсу.
2. В классе, который производит продукты, создайте пустой
фабричный метод. В качестве возвращаемого типа укажите
общий интерфейс продукта.
3. Затем, пройдитесь по коду класса и найдите все участки,
создающие продукты. Поочерёдно замените эти участки
вызовами фабричного метода, перенося в него код
создания различных продуктов.
В фабричный метод, возможно, придётся добавить
несколько параметров, контролирующих какой из
продуктов нужно создать.
На этом этапе фабричный метод, скорее всего, будет
выглядеть удручающе. В нём будет жить большой условный
оператор, выбирающий класс создаваемого продукта. Но
не волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и
переопределите в нём фабричный метод. Переместите туда
код создания соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для
существующих подклассов создателя, вы можете подумать
81 Порождающие паттерны / Фабричный метод
о введении параметров в фабричный метод, которые
позволят возвращать различные продукты в пределах
одного подкласса.
Например, у вас есть класс Почта с подклассами
АвиаПочта и НаземнаяПочта , а также классы продуктов
Самолёт , Грузовик и Поезд . Авиа соответствует
Самолётам , но для НаземнойПочты есть сразу два продукта.
Вы могли бы создать новый подкласс почты для поездов, но
проблему можно решить и по-другому. Клиентский код
может передавать в фабричный метод НаземнойПочты
аргумент, контролирующий какой из продуктов будет
создан.
6. Если после всех перемещений фабричный метод стал
пустым, можете сделать его абстрактным. Если в нём что-то
осталось — не беда, это будет его реализацией по
умолчанию.
? Преимущества и недостатки
? Избавляет класс от привязки к конкретным классам
продуктов.
? Выделяет код производства продуктов в одно место,
упрощая поддержку кода.
? Упрощает добавление новых продуктов в программу.
? Реализует принцип открытости/закрытости.
82 Порождающие паттерны / Фабричный метод
? Может привести к созданию больших параллельных
иерархий классов, так как для каждого класса продукта
надо создать свой подкласс создателя.
? Отношения с другими паттернами
• Многие архитектуры начинаются с применения Фабричного
метода (более простого и расширяемого через подклассы)
и эволюционируют в сторону Абстрактной фабрики,
Прототипа или Строителя (более гибких, но и более
сложных).
• Классы Абстрактной фабрики чаще всего реализуются с
помощью Фабричного метода, хотя они могут быть
построены и на основе Прототипа.
• Фабричный метод можно использовать вместе с
Итератором, чтобы подклассы коллекций могли создавать
подходящие им итераторы.
• Прототип не опирается на наследование, но ему нужна
сложная операция инициализации. Фабричный метод
наоборот, построен на наследовании, но не требует
сложной инициализации.
• Фабричный метод можно рассматривать как частный
случай Шаблонного метода. Кроме того, Фабричный метод
83 Порождающие паттерны / Фабричный метод
нередко бывает частью большого класса с Шаблонными
методами.
84 Порождающие паттерны / Фабричный метод
АБСТРАКТНАЯ
ФАБРИКА
Также известен как: Abstract Factory
Абстрактная фабрика — это порождающий паттерн
проектирования, который позволяет создавать семейства
связанных объектов, не привязываясь к конкретным
классам создаваемых объектов.
85 Порождающие паттерны / Абстрактная фабрика
? Проблема
Представьте, что вы пишете симулятор мебельного
магазина. Ваш код содержит:
1. Семейство зависимых продуктов. Скажем, Кресло + Диван
+ Столик .
2. Несколько вариаций этого семейства. Например, продукты
Кресло , Диван и Столик представлены в трёх разных
стилях: Ар-деко , Викторианском и Модерне .
Семейства продуктов и их вариации.
Вам нужен такой способ создавать объекты продуктов,
чтобы они сочетались с другими продуктами того же
86 Порождающие паттерны / Абстрактная фабрика
семейства. Это важно, так как клиенты расстраиваются,
если получают несочетающуюся мебель.
Клиенты расстраиваются, если получают несочетающиеся продукты.
Кроме того, вы не хотите вносить изменения в
существующий код при добавлении новых продуктов или
семейств в программу. Поставщики часто обновляют свои
каталоги, и вам бы не хотелось менять уже написанный код
при получении новых моделей мебели.
? Решение
Для начала, паттерн Абстрактная фабрика предлагает
выделить общие интерфейсы для отдельных продуктов,
составляющих семейства. Так, все вариации кресел получат
общий интерфейс Кресло , все диваны реализуют
интерфейс Диван и так далее.
87 Порождающие паттерны / Абстрактная фабрика
Все вариации одного и того же объекта должны жить в одной иерархии классов.
Далее, вы создаёте «абстрактную фабрику» — общий
интерфейс, который содержит методы создания всех
продуктов семейства (например, создатьКресло ,
создатьДиван и создатьСтолик ). Эти операции должны
возвращать абстрактные типы продуктов, представленные
интерфейсами, которые мы выделили ранее — Кресла ,
Диваны и Столики .
Как насчёт вариаций продуктов? Для каждой вариации
семейства продуктов мы должны создать свою собственную
фабрику, реализовав абстрактный интерфейс. Фабрики
создают продукты одной вариации. Например,
ФабрикаМодерн будет возвращать только
КреслаМодерн , ДиваныМодерн и СтоликиМодерн .
88 Порождающие паттерны / Абстрактная фабрика
Конкретные фабрики соответствуют определённой вариации
семейства продуктов.
Клиентский код должен работать как с фабриками, так и с
продуктами только через их общие интерфейсы. Это
позволит подавать в ваши классы любой тип фабрики и
производить любые продукты, ничего не ломая.
Например, клиентский код просит фабрику сделать стул. Он
не знает какого типа фабрика это была.
Клиентскому коду должно быть всё равно с какой фабрикой работать.
89 Порождающие паттерны / Абстрактная фабрика
Он не знает, получит викторианский или модерновый стул.
Для него важно, чтобы на этом стуле можно сидеть, и чтобы
этот стул отлично смотрелся с диваном той же фабрики.
Осталось прояснить последний момент — кто создаёт
объекты конкретных фабрик, если клиентский код работает
только с интерфейсами фабрик? Обычно программа
создаёт конкретный объект фабрики при запуске, причём
тип фабрики выбирается исходя из параметров окружения
или конфигурации.
? Структура
1. Абстрактные продукты объявляют интерфейсы продуктов,
которые связаны друг с другом по смыслу, но выполняют
разные функции.
90 Порождающие паттерны / Абстрактная фабрика
2. Конкретные продукты — большой набор классов, которые
относятся к различным абстрактным продуктам (кресло/
столик), но имеют одни и те же вариации
(Викториан./Модерн).
3. Абстрактная фабрика объявляет методы создания
различных абстрактных продуктов (кресло/столик).
4. Конкретные фабрики относятся каждая к своей вариации
продуктов (Викториан./Модерн) и реализуют методы
абстрактной фабрики, позволяя создавать все продукты
определённой вариации.
5. Несмотря на то, что конкретные фабрики порождают
конкретные продукты, сигнатуры их методов должны
возвращать соответствующие абстрактные продукты. Это
позволит клиентскому коду, использующему фабрику, не
привязываться к конкретным классам продуктов. Клиент
сможет работать с любыми вариациями продуктов через
абстрактные интерфейсы.
? Псевдокод
В этом примере Абстрактная фабрика создаёт кроссплатформенные элементы интерфейса и следит за тем,
чтобы они соответствовали выбранной операционной
системе.
91 Порождающие паттерны / Абстрактная фабрика
Пример кросс-платформенного графического интерфейса пользователя.
Кросс-платформенная программа может показывать одни и
те же элементы интерфейса, выглядящие чуточку подругому в различных операционных системах. В такой
программе, важно, чтобы все создаваемые элементы всегда
соответствовали текущей операционной системе. Вы бы не
хотели, чтобы программа, запущенная на Windows, вдруг
начала показывать чекбоксы в стиле macOS.
Абстрактная фабрика объявляет список продуктов, которые
может запрашивать клиентский код. Конкретные фабрики
относятся к различным операционным системам и создают
элементы одного и того же вида.
В самом начале, программа определяет, какая из фабрик
соответствует текущей операционке. Затем, создаёт эту
92 Порождающие паттерны / Абстрактная фабрика
фабрику и отдаёт её клиентскому коду. В дальнейшем,
клиент будет работать только с этой фабрикой, чтобы
исключить несовместимость возвращаемых продуктов.
Клиентский код не зависит от конкретных класс фабрик и
элементов интерфейса. Он общается с ними через
абстрактные интерфейсы. Благодаря этому, клиент может
работать любой разновидностью фабрик и элементов
интерфейса.
Чтобы добавить в программу новую вариацию элементов
(например, для поддержки Linux), вам не нужно трогать
клиентский код. Достаточно создать ещё одну фабрику,
производящую эти элементы.
1 // Этот паттерн предполагает, что у вас есть несколько
2 // семейств продуктов, находящихся в отдельных иерархиях
3 // классов (Button/Checkbox). Продукты одного семейства
4 // должны иметь общий интерфейс.
5 interface Button is
6 method paint()
7
8 // Все семейства продуктов имеют одинаковые
9 // вариации (macOS/Windows).
10 class WinButton implements Button is
11 method paint() is
12 // Отрисовать кнопку в стиле Windows.
13
14 class MacButton implements Button is
15 method paint() is
16 // Отрисовать кнопку в стиле macOS.
93 Порождающие паттерны / Абстрактная фабрика
17 interface Checkbox is
18 method paint()
19
20 class WinCheckbox implements Checkbox is
21 method paint() is
22 // Отрисовать чекбокс в стиле Windows.
23
24 class MacCheckbox implements Checkbox is
25 method paint() is
26 // Отрисовать чекбокс в стиле macOS.
27
28
29 // Абстрактная фабрика знает обо всех (абстрактных)
30 // типах продуктов.
31 interface GUIFactory is
32 method createButton():Button
33 method createCheckbox():Checkbox
34
35
36 // Каждая конкретная фабрика знает и создаёт только продукты
37 // своей вариации.
38 class WinFactory implements GUIFactory is
39 method createButton():Button is
40 return new WinButton()
41 method createCheckbox():Checkbox is
42 return new WinCheckbox()
43
44 // Несмотря на то что фабрики оперируют конкретными
45 // классами, их методы возвращают абстрактные типы
46 // продуктов. Благодаря этому, фабрики можно взаимозаменять,
47 // не изменяя клиентский код.
48 class MacFactory implements GUIFactory is
49 method createButton():Button is
50 return new MacButton()
94 Порождающие паттерны / Абстрактная фабрика
51 method createCheckbox():Checkbox is
52 return new MacCheckbox()
53
54
55 // Код, использующий фабрику, не волнует с какой конкретно
56 // фабрикой он работает. Все получатели продуктов работают с
57 // продуктами через абстрактный интерфейс.
58 class Application is
59 private field button: Button
60 constructor Application(factory: GUIFactory) is
61 this.factory = factory
62 method createUI()
63 this.button = factory.createButton()
64 method paint()
65 button.paint()
66
67
68 // Приложение выбирает тип и создаёт конкретные фабрики
69 // динамически исходя из конфигурации или окружения.
70 class ApplicationConfigurator is
71 method main() is
72 config = readApplicationConfigFile()
73
74 if (config.OS == "Windows") then
75 factory = new WinFactory()
76 else if (config.OS == "Web") then
77 factory = new MacFactory()
78 else
79 throw new Exception("Error! Unknown operating system.")
80
81 Application app = new Application(factory)
95 Порождающие паттерны / Абстрактная фабрика
? Применимость
? Когда бизнес-логика программы должна работать с
разными видами связанных друг с другом продуктов, не
завися от конкретных классов продуктов.
? Абстрактная фабрика скрывает от клиентского кода
подробности того, как и какие конкретно объекты будут
созданы. Но при этом клиентский код может работать со
всеми типами создаваемых продуктов, так как их общий
интерфейс был заранее определён.
? Когда в программе уже используется Фабричный метод, но
очередные изменения предполагают введение новых
типов продуктов.
? В хорошей программе, каждый класс отвечает только за
одну вещь. Если класс имеет слишком много фабричных
методов, они способны затуманить его основную функцию.
Поэтому имеет смысл вынести всю логику создания
продуктов в отдельную иерархию классов, применив
абстрактную фабрику.
? Шаги реализации
1. Создайте таблицу соотношений типов продуктов к
вариациям семейств продуктов.
96 Порождающие паттерны / Абстрактная фабрика
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен
иметь фабричные методы для создания каждого из типов
продуктов.
4. Создайте классы конкретных фабрик, реализовав
интерфейс абстрактной фабрики. Этих классов должно быть
столько же, сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она
создавала определённую фабрику и передавала её в
клиентский код.
6. Замените в клиентском коде участки создания продуктов
через конструктор вызовами соответствующих методов
фабрики.
? Преимущества и недостатки
? Гарантирует сочетаемость создаваемых продуктов.
? Избавляет клиентский код от привязки к конкретным
классам продуктов.
? Выделяет код производства продуктов в одно место,
упрощая поддержку кода.
? Упрощает добавление новых продуктов в программу.
? Реализует принцип открытости/закрытости.
97 Порождающие паттерны / Абстрактная фабрика
? Усложняет код программы за счёт множества
дополнительных классов.
? Требует наличия всех типов продуктов в каждой вариации.
? Отношения с другими паттернами
• Многие архитектуры начинаются с применения Фабричного
метода (более простого и расширяемого через подклассы)
и эволюционируют в сторону Абстрактной фабрики,
Прототипа или Строителя (более гибких, но и более
сложных).
• Строитель концентрируется на постройке сложных объектов
шаг за шагом. Абстрактная фабрика специализируется на
создании семейств связанных продуктов. Строитель
возвращает продукт только после выполнения всех шагов, а
Абстрактная фабрика возвращает продукт сразу же.
• Классы Абстрактной фабрики чаще всего реализуются с
помощью Фабричного метода, хотя они могут быть
построены и на основе Прототипа.
• Абстрактная фабрика может быть использована вместо
Фасада для того, чтобы скрыть платформо-зависимые
классы.
98 Порождающие паттерны / Абстрактная фабрика
• Абстрактная фабрика может работать совместно с Мостом.
Это особенно полезно, если у вас есть абстракции, которые
могут работать только с некоторыми из реализаций. В этом
случае фабрика будет определять типы создаваемых
абстракций и реализаций.
• Абстрактная фабрика, Строитель и Прототип могут быть
реализованы при помощи Одиночки.
99 Порождающие паттерны / Абстрактная фабрика
СТРОИТЕЛЬ
Также известен как: Builder
Строитель — это порождающий паттерн проектирования,
который позволяет создавать сложные объекты пошагово.
Строитель даёт возможность использовать один и тот же
код строительства для получения разных представлений
объектов.
100 Порождающие паттерны / Строитель
? Проблема
Представьте сложный объект, требующий кропотливой
пошаговой инициализации множества полей и вложенных
объектов. Код инициализации обычно спрятан внутри
монструозного конструктора с десятком параметров, либо
ещё хуже — распылён по всему клиентскому коду.
Например, давайте подумаем о том, как создать объект
Дом . Чтобы построить стандартный дом, нужно поставить 4
стены, установить двери, вставить пару окон и постелить
крышу. Но что, если вы хотите дом побольше, посветлее, с
бассейном, садом и прочим добром?
Создав кучу подклассов для всех конфигураций объектов, вы можете излишне
усложнить программу.
Самое простое решение — расширить класс Дом , создав
подклассы для всех комбинаций параметров дома.
101 Порождающие паттерны / Строитель
Проблема такого подхода — это громадное количество
классов, которые вам придётся создать. Каждый новый
параметр, вроде цвета обоев или материала кровли,
заставит вас создавать всё больше и больше классов для
перечисления всех возможных вариантов.
Чтобы не плодить подклассы, вы можете подойти к
решению с другой стороны. Вы можете создать гигантский
конструктор Дома , принимающий уйму параметров для
контроля над создаваемым продуктом. Действительно, это
избавит вас от подклассов, но приведёт к другой проблеме.
Конструктор с множеством параметров имеет свой недостаток. Не все
параметры нужны большую часть времени.
Большая часть этих параметров будет простаивать, а
вызовы конструктора будут выглядеть монструозно из-за
длинного списка параметров. К примеру, далеко не каждый
102 Порождающие паттерны / Строитель
дом имеет бассейн, поэтому параметры, связанные с
бассейнами, будут простаивать бесполезно в 99% случаев.
? Решение
Паттерн Строитель предлагает вынести конструирование
объекта за пределы его собственного класса, поручив это
дело отдельным объектам, называемым строителями.
Строитель позволяет создавать сложные объекты пошагово. Промежуточный
результат защищён от стороннего вмешательства.
Паттерн предлагает разбить процесс конструирования
объекта на отдельные шаги (например, построитьСтены ,
вставитьДвери и т.д.) Чтобы создать объект, вам нужно
поочерёдно вызывать методы строителя. Причём не нужно
103 Порождающие паттерны / Строитель
запускать все шаги, а только те, что нужны для
производства объекта определённой конфигурации.
Зачастую, один и тот же шаг строительства может
отличаться для разных вариаций производимых объектов.
Например, деревянный дом потребует строительства стен
из дерева, а каменный — из камня.
В этом случае, вы можете создать несколько классов
строителей, выполняющих одни и те же шаги по-разному.
Используя этих строителей в одном и том же строительном
процессе, вы сможете получать на выходе различные
объекты.
Разные Строители выполнят одну и ту же задачу по-разному.
Например, один строитель делает стены из дерева и стекла,
другой из камня и железа, третий из золота и бриллиантов.
Вызвав одни и те же шаги строительства, в первом случае
вы получите обычный жилой дом, во втором — маленькую
крепость, а в третьем — роскошное жилище. Замечу, код,
104 Порождающие паттерны / Строитель
который вызывает шаги строительства должен работать со
строителями через общий интерфейс, чтобы их можно было
свободно взаимозаменять.
Директор
Вы можете пойти дальше и выделить вызовы методов
строителя в отдельный класс, называемый «Директором». В
этом случае директор будет задавать порядок шагов
строительства, а строитель — выполнять их.
Директор знает, какие шаги должен выполнить объект-Строитель, чтобы
произвести продукт.
Отдельный класс директора не является строго
обязательным. Вы можете вызывать методы строителя и
напрямую из клиентского кода. Тем не менее, директор
105 Порождающие паттерны / Строитель
полезен, если у вас есть несколько способов
конструирования продуктов, отличающихся порядком и
наличием шагов конструирования. В этом случае, вы
сможете объединить всю эту логику в одном классе.
Такая структура классов полностью скроет от клиентского
кода процесс конструирования объектов. Клиенту останется
только привязать желаемого строителя к директору, а затем
получить у строителя готовый результат.
106 Порождающие паттерны / Строитель
? Структура
1. Интерфейс строителя объявляет шаги конструирования
продуктов, общие для всех видов строителей.
107 Порождающие паттерны / Строитель
2. Конкретные строители реализуют строительные шаги,
каждый по-своему. Конкретные строители могут
производить разнородные объекты, не имеющие общего
интерфейса.
3. Продукт — создаваемый объект. Продукты, сделанные
разными строителями, не обязаны иметь общий интерфейс.
4. Директор определяет порядок вызова строительных шагов
для производства той или иной конфигурации объектов.
5. Обычно, Клиент подаёт в конструктор директора уже
готовый объект-строитель, и в дальнейшем данный
директор использует только его. Но возможен и другой
вариант, когда клиент передаёт строителя через параметр
строительного метода директора. В этом случае можно
каждый раз применять разных строителей для
производства различных представлений объектов.
? Псевдокод
В этом примере Строитель используется для пошагового
конструирования автомобилей, а также технических
руководств к ним.
108 Порождающие паттерны / Строитель
Пример пошагового конструирования автомобилей и инструкций к ним.
Автомобиль — это сложный объект, который может быть
сконфигурирован сотней разных способов. Вместо того
чтобы настраивать автомобиль через конструктор, мы
вынесем его сборку в отдельный класс-строитель,
предусмотрев методы для конфигурации всех частей
автомобиля.
109 Порождающие паттерны / Строитель
Клиент может собирать автомобили, работая со строителем
напрямую. Но с другой стороны, он может поручить это
дело директору. Это объект, который знает какие шаги
строителя нужно вызвать, чтобы получить несколько самых
популярных конфигураций автомобилей.
Но к каждому автомобилю нужно ещё и руководство,
совпадающее с его конфигурацией. Для этого мы создадим
ещё один класс строителя, который вместо
конструирования автомобиля, будет печатать страницы
руководства к той детали, которую мы встраиваем в
продукт. Теперь, пропустив оба типа строителей через одни
и те же шаги, мы получим автомобиль и подходящее к нему
руководство пользователя.
Очевидно, что бумажное руководство и железный
автомобиль — это две разных вещи, не имеющих ничего
общего. По этой причине, мы должны получать результат
напрямую от строителей, а не от директора. Иначе, нам
пришлось бы жёстко привязать директора к конкретным
классам автомобилей и руководств.
1 // Строитель может создавать различные продукты, используя
2 // один и тот же процесс строительства.
3 class Car is
4 // Автомобили могут отличаться комплектацией: типом
5 // двигателя, количеством сидейний, могут иметь или не иметь
6 // GPS и систему навигации и т.д. Кроме того, автомобили
7 // могут быть городскими, спортивными или внедорожниками.
110 Порождающие паттерны / Строитель
8 class Manual is
9 // Руководство пользователя для данной конфигурации
10 // автомобиля.
11
12
13 // Интерфейс строителя объявляет все возможные этапы и шаги
14 // конфигурации продукта.
15 interface Builder is
16 method reset()
17 method setSeats(...)
18 method setEngine(...)
19 method setTripComputer(...)
20 method setGPS(...)
21
22 // Все конкретные строители реализуют общий
23 // интерфейс по-своему.
24 class CarBuilder implements Builder is
25 private field car:Car
26 method reset()
27 // Поместить новый объект Car в поле "car".
28 method setSeats(...) is
29 // Установить указанное количество сидений.
30 method setEngine(...) is
31 // Установить поданный двигатель.
32 method setTripComputer(...) is
33 // Установить поданную систему навигации.
34 method setGPS(...) is
35 // Установить или снять GPS.
36 method getResult(): Car is
37 // Вернуть текущий объект автомобиля.
38
39 // В отличие от других создающих паттернов, строители могут
40 // создавать совершенно разные продукты, не имеющие
41 // общего интерфейса.
111 Порождающие паттерны / Строитель
42 class CarManualBuilder implements Builder is
43 private field manual:Manual
44 method reset()
45 // Поместить новый объект Manual в поле "manual".
46 method setSeats(...) is
47 // Описать сколько мест в машине.
48 method setEngine(...) is
49 // Добавить в руководство описание двигателя.
50 method setTripComputer(...) is
51 // Добавить в руководство описание системы навигации.
52 method setGPS(...) is
53 // Добавить в инструкцию инструкцию GPS.
54 method getResult(): Manual is
55 // Вернуть текущий объект руководства.
56
57
58 // Директор знает в какой последовательности заставлять
59 // работать строителя. Он работает с ним через общий
60 // интерфейс строителя. Из-за этого, он может не знать какой
61 // конкретно продукт сейчас строится.
62 class Director is
63 method constructSportsCar(builder: Builder) is
64 builder.reset()
65 builder.setSeats(2)
66 builder.setEngine(new SportEngine())
67 builder.setTripComputer(true)
68 builder.setGPS(true)
69
70
71 // Директор получает объект конкретного строителя от клиента
72 // (приложения). Приложение само знает какой строитель
73 // использовать, чтобы получить нужный продукт.
74 class Application is
75 method makeCar is
112 Порождающие паттерны / Строитель
? Применимость
? Когда вы хотите избавиться от «телескопического
конструктора».
? Допустим, у вас есть один конструктор с десятью
опциональными параметрами. Его неудобно вызывать,
поэтому вы создали ещё десять конструкторов с меньшим
количеством параметров. Всё что они делают — это
переадресуют вызов к главному конструктору, подавая
какие-то значения по умолчанию в качестве опциональных
параметров.
76 director = new Director()
77
78 CarBuilder builder = new CarBuilder()
79 director.constructSportsCar(builder)
80 Car car = builder.getResult()
81
82 CarManualBuilder builder = new CarManualBuilder()
83 director.constructSportsCar(builder)
84
85 // Готовый продукт возвращает строитель, так как
86 // директор чаще всего не знает и не зависит от
87 // конкретных классов строителей и продуктов.
88 Manual manual = builder.getResult()
113 Порождающие паттерны / Строитель
Такого монстра можно создать только в языках, имеющих механизм перегрузки
методов, например С# или Java.
Паттерн Строитель позволяет собирать объекты пошагово,
вызывая только те шаги, которые вам нужны. А значит,
больше не нужно пытаться запихнуть в конструктор все
возможные опции продукта.
? Когда ваш код должен создавать разные представления
какого-то объекта. Например, деревянные и
железобетонные дома.
? Строитель можно применить, если создание нескольких
представлений объекта состоит из одинаковых этапов,
которые отличаются в деталях.
Интерфейс строителей определит все возможные этапы
конструирования. Каждому представлению будет
соответствовать собственный класс-строитель. А порядок
этапов строительства будет задавать класс-директор.
? Когда вам нужно собирать сложные составные объекты,
например, деревья Компоновщика.
1 class Pizza {
2 Pizza(int size) { ... }
3 Pizza(int size, boolean cheese) { ... }
4 Pizza(int size, boolean cheese, boolean pepperoni) { ... }
5 // ...
114 Порождающие паттерны / Строитель
? Строитель конструирует объекты пошагово, а не за один
проход. Более того, шаги строительства можно выполнять
рекурсивно. А без этого не построить древовидную
структуру вроде Компоновщика.
Заметьте, что Строитель не позволяет посторонним
объектам иметь доступ к конструируемому объекту пока тот
не будет полностью готов. Это предотвращает клиентский
код от получения незаконченных «битых» объектов.
? Шаги реализации
1. Убедитесь в том, что создание разных представлений
объекта можно свести к общим шагам.
2. Опишите эти шаги в общем интерфейсе строителей.
3. Для каждого из представлений объекта-продукта создайте
по одному классу-строителю и реализуйте их методы
строительства.
Не забудьте про метод получения результата. Обычно,
конкретные строители определяют собственные методы
получения результата строительства. Вы не можете описать
эти методы в интерфейсе строителей, так продукты не
обязательно должны иметь общий базовый класс или
интерфейс. Но вы всегда можете добавить метод получения
115 Порождающие паттерны / Строитель
результата в общий интерфейс, если ваши строители
производят однородные продукты с общим предком.
4. Подумайте о создании класса директора. Его методы будут
создавать различные конфигурации продуктов, вызывая
разные шаги одного и того же строителя.
5. Клиентский код должен будет создавать и объекты
строителей, и объект директора. Перед началом
строительства, клиент должен связать определённого
строителя с директором. Это можно сделать либо через
конструктор, либо через сеттер, либо подав строителя
напрямую в в строительный метод директора.
6. Результат строительства можно вернуть из директора, но
только если метод возврата продукта удалось поместить в
общий интерфейс строителей. Иначе, вы жёстко привяжете
директора к конкретным классам строителей.
? Преимущества и недостатки
? Позволяет создавать продукты пошагово.
? Позволяет использовать один и тот же код для создания
различных продуктов.
? Изолирует сложный код сборки продукта от его основной
бизнес-логики.
? Усложняет код программы за счёт дополнительных классов.
116 Порождающие паттерны / Строитель
? Клиент будет привязан к конкретным классам строителей,
так как в интерфейсе строителя может не быть метода
получения результата.
? Отношения с другими паттернами
• Многие архитектуры начинаются с применения Фабричного
метода (более простого и расширяемого через подклассы)
и эволюционируют в сторону Абстрактной фабрики,
Прототипа или Строителя (более гибких, но и более
сложных).
• Строитель концентрируется на постройке сложных объектов
шаг за шагом. Абстрактная фабрика специализируется на
создании семейств связанных продуктов. Строитель
возвращает продукт только после выполнения всех шагов, а
Абстрактная фабрика возвращает продукт сразу же.
• Строитель позволяет пошагово сооружать дерево
Компоновщика.
• Паттерн Строитель может быть построен в виде Моста:
директор будет играть роль абстракции, а строители
— реализации.
• Абстрактная фабрика, Строитель и Прототип могут быть
реализованы при помощи Одиночки.
117 Порождающие паттерны / Строитель
ПРОТОТИП
Также известен как: Клон, Prototype
Прототип — это порождающий паттерн проектирования,
который позволяет копировать объекты, не вдаваясь в
подробности их реализации.
118 Порождающие паттерны / Прототип
? Проблема
У вас есть объект, который нужно скопировать. Как это
сделать? Нужно создать пустой объект такого же класса, а
затем поочерёдно скопировать значения всех полей из
старого объекта в новый.
Прекрасно! Но есть нюанс. Не каждый объект удастся
скопировать таким образом, ведь часть его состояния
может быть приватной и недоступна для остального кода
программы.
Копирование «извне» не всегда возможно в реальности.
Но есть и другая проблема. Копирующий код станет
зависим от классов копируемых объектов. Ведь чтобы
перебрать все поля объекта, нужно привязаться к его
классу. Из-за этого вы не сможете копировать объекты, зная
только их интерфейсы, но не конкретные классы.
119 Порождающие паттерны / Прототип
? Решение
Паттерн Прототип поручает создание копий самим
копируемым объектам. Он вводит общий интерфейс для
всех объектов, поддерживающих клонирование. Это
позволяет копировать объекты, не привязываясь к их
конкретным классам. Обычно такой интерфейс имеет всего
один метод clone .
Реализация этого метода в разных классах очень схожа.
Метод создаёт новый объект текущего класса и копирует в
него значения всех полей объекта. Так получится
скопировать даже приватные поля, так как большинство
языков программирования разрешает доступ к приватным
полям отдельного объекта текущего класса.
Предварительно заготовленные прототипы могут стать заменой подклассам.
120 Порождающие паттерны / Прототип
Объект, который копируют, называется прототипом (откуда
и название паттерна). Когда объекты программы содержат
сотни полей и тысячи возможных конфигураций, прототипы
могут служить своеобразной альтернативой созданию
подклассов.
В этом случае, все возможные прототипы заготавливаются и
настраиваются на этапе инициализации программы. Потом,
когда программе нужен новый объект, она создаёт копию
из приготовленного прототипа.
? Аналогия из жизни
В промышленном производстве прототипы создаются перед
основной партией продуктов для проведения
всевозможных испытаний. При этом прототип не участвует
в последующем производстве, отыгрывая пассивную роль.
Пример деления клетки.
121 Порождающие паттерны / Прототип
Прототип на производстве не делает копию самого себя,
поэтому более близкий пример паттерна — деление клеток.
После митозного деления клеток образуются две
совершенно идентичные клетки. Оригинальная клетка
отыгрывает роль прототипа, принимает активную роль в
создании нового объекта.
? Структура
Базовая реализация
1. Интерфейс прототипов описывает операции клонирования.
В большинстве случаев — это единственный метод clone .
122 Порождающие паттерны / Прототип
2. Конкретный прототип реализует операцию клонирования
самого себя. Помимо банального копирования значений
всех полей, здесь могут быть спрятаны различные
сложности, о которых не нужно знать клиенту. Например,
клонирование связанных объектов, распутывание
рекурсивных зависимостей и прочее.
3. Клиент создаёт копию объекта, обращаясь к нему через
общий интерфейс прототипов.
Реализация с общим хранилищем прототипов
123 Порождающие паттерны / Прототип
1. Хранилище прототипов облегчает доступ к часто
используемым прототипам, храня предсозданный набор
эталонных, готовых к копированию объектов. Простейшее
хранилище может быть построено с помощью хеш-таблицы
вида имя-прототипа > прототип . Но для удобства поиска,
прототипы можно маркировать и другими критериями, а не
только условным именем.
? Псевдокод
В этом примере Прототип позволяет производить точные
копии объектов геометрических фигур, не привязываясь к
их классам.
Пример клонирования иерархии геометрических фигур.
124 Порождающие паттерны / Прототип
Все фигуры реализуют интерфейс клонирования и
предоставляют метод для воспроизводства самой себя.
Подклассы используют метод клонирования родителя, а
затем копируют собственные поля в получившийся объект.
1 // Базовый прототип.
2 abstract class Shape is
3 field X: int
4 field Y: int
5 field color: string
6
7 // Копирование всех полей объекта происходит
8 // в конструкторе.
9 constructor Shape(source: Shape) is
10 if (source != null) then
11 this.X = source.X
12 this.Y = source.Y
13 this.color = source.color
14
15 // Результатом операции клонирования всегда будет объект
16 // из иерархии классов Shape.
17 abstract method clone(): Shape
18
19
20 // Конкретный прототип. Метод клонирования создаёт новый
21 // объект и передаёт в его конструктор для копирования
22 // собственный объект. Этим мы пытаемся получить атомарность
23 // операции клонирования. В данной реализации, пока не
24 // выполнится конструктор, нового объекта ещё не существует.
25 // Но как только конструктор завершён, мы получаем полностью
26 // готовый объект-клон, а не пустой объект, который нужно
27 // ещё заполнить.
28 class Rectangle extends Shape is
125 Порождающие паттерны / Прототип
29 field width: int
30 field height: int
31
32 constructor Rectangle(source: Rectangle) is
33 // Вызов родительского конструктора нужен, чтобы
34 // скопировать потенциальные приватные поля,
35 // объявленные в родительском классе.
36 super(source)
37 if (source != null) then
38 this.width = source.width
39 this.height = source.height
40
41 method clone(): Shape is
42 return new Rectangle(this)
43
44
45 class Circle extends Shape is
46 field radius: int
47
48 constructor Circle(source: Circle) is
49 super(source)
50 if (source != null) then
51 this.radius = source.radius
52
53 method clone(): Shape is
54 return new Circle(this)
55
56
57 // Где-то в клиентском коде.
58 class Application is
59 field shapes: array of Shape
60
61 constructor Application() is
62 Circle circle = new Circle()
126 Порождающие паттерны / Прототип
63 circle.X = 10
64 circle.Y = 20
65 circle.radius = 15
66 shapes.add(circle)
67
68 Circle anotherCircle = circle.clone()
69 shapes.add(anotherCircle)
70 // anotherCircle будет содержать точную
71 // копию circle.
72
73 Rectangle rectangle = new Rectangle()
74 rectangle.width = 10
75 rectangle.height = 20
76 shapes.add(rectangle)
77
78 method businessLogic() is
79 // Неочевидный плюс Прототипа в том, что вы можете
80 // клонировать набор объектов, не зная их
81 // конкретных классов.
82 Array shapesCopy = new Array of Shapes.
83
84 // Например, мы не знаем какие конкретно объекты
85 // находятся внутри массива shapes, так как он
86 // объявлен с типом Shape. Но благодаря
87 // полиморфизму, мы можем клонировать все объекты
88 // «вслепую». Будет выполнен метод `clone` того
89 // класса, которым является этот объект.
90 foreach (s in shapes) do
91 shapesCopy.add(s.clone())
92
93 // Переменная shapesCopy будет содержать точные
94 // копии элементов массива shapes.
127 Порождающие паттерны / Прототип
? Применимость
? Когда ваш код не должен зависеть от классов копируемых
объектов.
? Такое часто бывает, если ваш код работает с объектами,
поданными извне через какой-то общий интерфейс. Вы не
можете привязаться к их классам, даже если бы хотели, так
как их конкретные классы неизвестны.
Паттерн прототип предоставляет клиенту общий интерфейс
для работы со всеми прототипами. Клиенту не нужно
зависеть от всех классов копируемых объектов, а только от
интерфейса клонирования.
? Когда вы имеете уйму подклассов, которые отличаются
начальными значениями полей. Кто-то создал эти классы,
чтобы быстро создавать объекты с определённой
конфигурацией.
? Паттерн прототип предлагает использовать набор
прототипов, вместо создания подклассов для популярных
конфигураций объектов.
Таким образом, вместо порождения объектов из
подклассов, вы будете копировать существующие объектыпрототипы, в которых уже настроено внутреннее состояние.
Это позволит избежать взрывного роста количества классов
в программе и уменьшить её сложность.
128 Порождающие паттерны / Прототип
? Шаги реализации
1. Создайте интерфейс прототипов с единственным методом
clone . Если у вас уже есть иерархия продуктов, метод
клонирования можно объявить непосредственно в каждом
из её классов.
2. Добавьте в классы будущих прототипов альтернативный
конструктор, принимающий в качестве аргумента объект
текущего класса. Этот конструктор должен скопировать из
поданного объекта значения всех полей, объявленных в
рамках текущего класса, а затем передать выполнение
родительскому конструктору, чтобы тот позаботился об
остальных полях.
Если ваш язык программирования не поддерживает
перегрузку методов, то копирование значений можно
проводить и в другом методе, специально созданном для
этих целей. Конструктор удобнее тем, что позволяет
клонировать объект за один вызов.
3. Метод клонирования обычно состоит всего из одной
строки: вызова оператора new с конструктором прототипа.
Все классы, поддерживающие клонирование, должны явно
определить метод clone , чтобы подать собственный класс
в оператор new . В обратном случае, результатом
клонирования окажется объект родительского класса.
129 Порождающие паттерны / Прототип
4. Опционально, создайте центральное хранилище
прототипов. В нём можно хранить вариации объектов,
возможно даже одного класса, но по-разному настроенных.
Вы можете разместить это хранилище либо в новом
фабричном классе, либо в фабричном методе базового
класса прототипов. Такой фабричный метод должен на
основании входящих аргументов искать в каталоге
прототипов подходящий экземпляр, а затем вызывать его
метод клонирования и возвращать полученный объект.
Наконец, нужно будет избавиться от прямых вызовов
конструкторов объектов, заменив их вызовами фабричного
метода хранилища прототипов.
? Преимущества и недостатки
? Позволяет клонировать объекты, не привязываясь к их
конкретным классам.
? Меньше повторяющегося кода инициализации объектов.
? Ускоряет создание объектов.
? Альтернатива созданию подклассов для конструирования
сложных объектов.
? Сложно клонировать составные объекты, имеющие ссылки
на другие объекты.
130 Порождающие паттерны / Прототип
? Отношения с другими паттернами
• Многие архитектуры начинаются с применения Фабричного
метода (более простого и расширяемого через подклассы)
и эволюционируют в сторону Абстрактной фабрики,
Прототипа или Строителя (более гибких, но и более
сложных).
• Классы Абстрактной фабрики чаще всего реализуются с
помощью Фабричного метода, хотя они могут быть
построены и на основе Прототипа.
• Если Команду нужно копировать перед вставкой в историю
выполненных команд, вам может помочь Прототип.
• Архитектура, построенная на Компоновщиках и
Декораторах, часто может быть улучшена за счёт
внедрения Прототипа. Он позволяет клонировать сложные
структуры объектов, а не собирать их заново.
• Прототип не опирается на наследование, но ему нужна
сложная операция инициализации. Фабричный метод
наоборот, построен на наследовании, но не требует
сложной инициализации.
• Снимок иногда можно заменить Прототипом, если объект,
чьё состояние требуется сохранять в истории, довольно
131 Порождающие паттерны / Прототип
простой, не имеет активных ссылок на внешние ресурсы,
либо их можно легко восстановить.
• Абстрактная фабрика, Строитель и Прототип могут быть
реализованы при помощи Одиночки.
132 Порождающие паттерны / Прототип
ОДИНОЧКА
Также известен как: Singleton
Одиночка — это порождающий паттерн проектирования,
который гарантирует, что у класса есть только один
экземпляр, и предоставляет к нему глобальную точку
доступа.
133 Порождающие паттерны / Одиночка
? Проблема
Одиночка решает сразу две проблемы (нарушая принцип
единственной ответственности класса).
1. Гарантирует наличие единственного экземпляра класса.
Чаще всего это полезно для доступа к какому-то общему
ресурсу, например, базе данных.
Представьте, что вы создали объект, а через некоторое
время, пробуете создать ещё один. В этом случае, хотелось
бы получить старый объект, вместо создания нового.
Такое поведение невозможно реализовать с помощью
обычного конструктора, так как конструктор класса всегда
возвращает новый объект.
Клиенты могут не подозревать, что работают с одним и тем же объектом.
134 Порождающие паттерны / Одиночка
2. Предоставляет глобальную точку доступа. Это не просто
глобальная переменная, через которую можно достучаться
к определённому объекту. Глобальные переменные не
защищены от записи, поэтому любой код может подменять
их значения без вашего ведома.
Но есть и другой нюанс. Неплохо бы хранить в одном месте
и код, который решает проблему №1, а также иметь к нему
простой и доступный интерфейс.
Интересно, что в наше время паттерн стал настолько
известен, что теперь люди называют «Одиночкой» даже те
классы, которые решают лишь одну из проблем,
перечисленных выше.
? Решение
Все реализации одиночки сводятся к тому, чтобы скрыть
конструктор по умолчанию и создать публичный
статический метод, который и будет контролировать
жизненный цикл объекта-одиночки.
Если у вас есть доступ к классу-одиночке, значит, будет
доступ и к этому статическому методу. Из какой точки кода
вы бы его не вызвали, он всегда будет отдавать один и тот
же объект.
135 Порождающие паттерны / Одиночка
? Аналогия из жизни
Правительство государства — хороший пример одиночки. В
государстве может быть только одно официальное
правительство. Вне зависимости от того, кто конкретно
заседает в правительстве, оно имеет глобальную точку
доступа «Правительство страны N».
? Структура
1. Одиночка определяет статический метод getInstance ,
который возвращает единственный экземпляр своего
класса.
136 Порождающие паттерны / Одиночка
Конструктор одиночки должен быть скрыт от клиентов.
Вызов метода getInstance должен быть единственным
способом получить объект этого класса.
? Псевдокод
В этом примере роль Одиночки отыгрывает класс
подключения к базе данных.
Этот класс не имеет публичного конструктора, поэтому
единственный способ получить его объект — это вызвать
метод getInstance . Этот метод сохранит первый
созданный объект и будет возвращать его при всех
последующих вызовах.
1 class Database is
2 private field instance: Database
3
4 static method getInstance() is
5 if (this.instance == null) then
6 acquireThreadLock() and then
7 // На всякий случай, ещё раз проверим не был
8 // ли объект создан другим потоком, пока
9 // текущий ждал освобождения блокировки.
10 if (this.instance == null) then
11 this.instance = new Database()
12 return this.instance
13
14
137 Порождающие паттерны / Одиночка
? Применимость
? Когда в программе должен быть единственный экземпляр
какого-то класса, доступный всем клиентам (например,
общий доступ к базе данных из разных частей программы).
? Одиночка скрывает от клиентов все способы создания
нового объекта, кроме специального метода. Этот метод
15 private constructor Database() is
16 // Здесь может жить код инициализации подключения к
17 // серверу баз данных.
18 // ...
19
20 public method query(sql) is
21 // Все запросы к базе данных будут проходить через
22 // этот метод. Поэтому имеет смысл поместить сюда
23 // какую-то логику кеширования.
24 // ...
25
26 class Application is
27 method main() is
28 Database foo = Database.getInstance()
29 foo.query("SELECT ...")
30 // ...
31 Database bar = Database.getInstance()
32 bar.query("SELECT ...")
33 // Переменная "bar" содержит тот же объект, что
34 // и переменная "foo".
138 Порождающие паттерны / Одиночка
либо создаёт объект, либо отдаёт существующий объект,
если он уже был создан.
? Когда вам хочется иметь больше контроля над
глобальными переменными.
? В отличие от глобальных переменных, Одиночка
гарантирует, что никакой другой код не заменит созданный
экземпляр класса, поэтому вы всегда уверены в наличие
лишь одного объекта-одиночки.
Тем не менее, в любой момент вы можете расширить это
ограничение и позволить любое количество объектоводиночек, поменяв код в одном месте (метод getInstance ).
? Шаги реализации
1. Добавьте в класс приватное статическое поле, которое
будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет
использоваться для получения одиночки.
3. Добавьте «ленивую инициализацию» (создание объекта при
первом вызове метода) в создающий метод одиночки.
4. Сделайте конструктор класса приватным.
139 Порождающие паттерны / Одиночка
5. В клиентском коде замените вызовы конструктора
вызовами создающего метода.
? Преимущества и недостатки
? Гарантирует наличие единственного экземпляра класса.
? Предоставляет к нему глобальную точку доступа.
? Реализует отложенную инициализацию объекта-одиночки.
? Нарушает принцип единственной ответственности класса.
? Маскирует плохой дизайн.
? Проблемы мультипоточности.
? Требует постоянного создания Mock-объектов при юниттестирования.
? Отношения с другими паттернами
• Фасад можно сделать Одиночкой, так как обычно нужен
только один объект-фасад.
• Паттерн Легковес может напоминать Одиночку, если для
конкретной задачи у вас получилось уменьшить количество
объектов к одному. Но помните, что между паттернами есть
два кардинальных отличия:
140 Порождающие паттерны / Одиночка
1. В отличие от Одиночки, вы можете иметь множество
объектов-легковесов.
2. Объекты-легковесов должны быть неизменяемыми, тогда
как объект-одиночки допускает изменение своего
состояния.
• Абстрактная фабрика, Строитель и Прототип могут быть
реализованы при помощи Одиночки.
141 Порождающие паттерны / Одиночка
Структурные
паттерны
Эти паттерны отвечают за построение удобных в
поддержке иерархий классов.
Адаптер
Adapter
Позволяет объектам с несовместимыми интерфейсами
работать вместе.
Мост
Bridge
Разделяет один или несколько классов на две отдельные
иерархии — абстракцию и реализацию, позволяя изменять их
независимо друг от друга.
142 Структурные паттерны
Компоновщик
Composite
Позволяет сгруппировать объекты в древовидную структуру, а
затем работать с ними так, если бы это был единичный объект.
Декоратор
Decorator
Позволяет динамически добавлять объектам новую
функциональность, оборачивая их в полезные «обёртки».
Фасад
Facade
Предоставляет простой интерфейс к сложной системе классов,
библиотеке или фреймворку.
143 Структурные паттерны
Легковес
Flyweight
Позволяет вместить бoльшее количество объектов в
отведённую оперативной память за счёт экономного
разделения общего состояния объектов между собой, вместо
хранения одинаковых данных в каждом объекте.
Заместитель
Proxy
Позволяет подставлять вместо реальных объектов
специальные объекты-заменители. Эти объекты перехватывают
вызовы к оригинальному объекту, позволяя сделать что-то до
или после передачи вызова оригиналу.
144 Структурные паттерны
АДАПТЕР
Также известен как: Обёртка, Adapter
Адаптер — это структурный паттерн проектирования,
который позволяет объектам с несовместимыми
интерфейсами работать вместе.
145 Структурные паттерны / Адаптер
? Проблема
Представьте, что вы делаете приложение для торговли на
бирже. Ваше приложение скачивает биржевые котировки
из нескольких источников в XML, а затем рисует красивые
графики.
В какой-то момент вы решаете улучшить приложение,
применив стороннюю библиотеку аналитики. Но вот беда,
библиотека поддерживает только формат данных JSON,
несовместимый с вашим приложением.
Подключить стороннюю библиотеку не выйдет из-за несовместимых
форматов данных.
Вы смогли бы переписать библиотеку, чтобы та
поддерживала формат XML. Но, во-первых, это может
нарушить работу существующего кода, который уже зависит
от библиотеки. А во-вторых, у вас может просто не быть
доступа к её исходному коду.
146 Структурные паттерны / Адаптер
? Решение
Вы можете создать адаптер. Это объект-переводчик,
который трансформирует интерфейс или данные одного
объекта в такой вид, чтобы он стал понятен другому
объекту.
При этом адаптер оборачивает один из объектов, так что
другой объект даже не знает о его наличии. Например, вы
можете обернуть объект, работающий в метрах, адаптером,
который бы конвертировал данные в футы.
Адаптеры могут не только переводить данные из одного
формата в другой, но и помогать объектам с разными
интерфейсами работать сообща. Это работает так:
1. Адаптер следует интерфейсу, который один объект ожидает
от другого.
2. Когда первый объект вызывает методы адаптера, адаптер
передаёт выполнение второму объекту, вызывая в нём те
или иные методы в том порядке, который важен для
второго объекта.
Иногда возможно создать даже двухсторонний адаптер,
который работал бы в обе стороны.
147 Структурные паттерны / Адаптер
Программа может работать со сторонней библиотекой через адаптер.
Таким образом, в приложении биржевых котировок, вы
могли бы создать класс XML_To_JSON_Adapter , который бы
оборачивал класс библиотеки аналитики. Ваш код посылал
бы запросы этому объекту в формате XML, а адаптер бы
сначала транслировал входящие данные в формат JSON, а
затем передавал бы их определённым методам библиотеки.
? Аналогия из жизни
Когда вы в первый раз летите за границу, вас может ждать
сюрприз при попытке зарядить ноутбук. Стандарты розеток
в разных странах отличаются.
148 Структурные паттерны / Адаптер
Содержимое чемоданов до и после поездки за границу.
Ваша европейская зарядка будет бесполезна в США без
специального адаптера, позволяющего подключиться к
розетке другого типа.
? Структура
Адаптер объектов
Эта реализация использует композицию: объект адаптера
«оборачивает», то есть содержит ссылку на служебный
объект. Такой подход работает во всех языках
программирования.
149 Структурные паттерны / Адаптер
1. Клиент — это класс, который содержит существующую
бизнес-логику программы.
2. Клиентский интерфейс описывает протокол, через который
клиент может работать с другими классами.
3. Сервис – это какой-то полезный класс, обычно сторонний.
Клиент не может использовать этот класс напрямую, так как
сервис имеет непонятный ему интерфейс.
4. Адаптер — это класс, который может одновременно
работать и с клиентом, и с сервисом. Он реализует
клиентский интерфейс и содержит ссылку на объект
сервиса. Адаптер получает вызовы от клиента через методы
клиентского интерфейса, а затем переводит их в вызовы
методов обёрнутого объекта в правильном формате.
150 Структурные паттерны / Адаптер
5. Работая с адаптером через интерфейс, клиент не
привязываться к конкретному классу адаптера. Благодаря
этому, вы можете добавлять в программу новые виды
адаптеров, независимо от клиентского кода. Это может
пригодиться, если интерфейс сервиса вдруг изменится,
например, после выхода новой версии сторонней
библиотеки.
Адаптер классов
Эта реализация базируется на наследовании: адаптер
наследует оба интерфейса одновременно. Такой подход
возможен только в языках, поддерживающих
множественное наследование, например C++.
1. Адаптер классов не нуждается во вложенном объекте, так
как он одновременно наследует и существующий и
сервисный интерфейс.
151 Структурные паттерны / Адаптер
? Псевдокод
В этом шуточном примере Адаптер преобразует один
интерфейс в другой, позволяя совместить квадратные
колышки и круглые отверстия.
Пример адаптации квадратных колышков и круглых отверстий.
Адаптер вычисляет наименьшую окружность, в которую
можно вписать квадратный колышек и представляет его как
круглый колышек с таким диаметром.
1 // Классы с совместимыми интерфейсами: КруглоеОтверстие
2 // и КруглыйКолышек.
3 class RoundHole is
4 constructor RoundHole(radius) { ... }
5
6
152 Структурные паттерны / Адаптер
7 method getRadius is
8 // Вернуть радиус отверстия.
9
10 method fits(peg: RoundPeg) is
11 return this.getRadius() >= peg.radius()
12
13 class RoundPeg is
14 constructor RoundPeg(radius) { ... }
15
16 method getRadius() is
17 // Вернуть радиус круглого колышка.
18
19
20 // Устаревший несовместимый класс: КвадратныйКолышек.
21 class SquarePeg is
22 constructor SquarePeg(width) { ... }
23
24 method getWidth() is
25 // Вернуть ширину квадратного колышка.
26
27
28 // Адаптер позволяет использовать квадратные колышки и
29 // круглые отверстия вместе.
30 class SquarePegAdapter extends RoundPeg is
31 private field peg: SquarePeg
32
33 constructor SquarePegAdapter(peg: SquarePeg) is
34 this.peg = peg
35
36 method getRadius() is
37 // Вычислить половину диагонали квадратного колышка
38 // по теореме Пифагора.
39 return Math.sqrt(2 * Math.pow(peg.getWidth(), 2)) / 2
40
153 Структурные паттерны / Адаптер
? Применимость
? Когда вы хотите использовать сторонний класс, но его
интерфейс не соответствует остальному коду приложения.
? Адаптер позволяет создать объект-прокладку, который
будет превращать вызовы приложения в формат, понятный
стороннему классу.
? Когда вам нужно использовать несколько существующих
подклассов, но в них не хватает какой-то общей
функциональности. Причём расширять суперкласс вы не
можете.
41 // Где-то в клиентском коде.
42 hole = new RoundHole(5)
43 rpeg = new RoundPeg(5)
44 hole.fits(rpeg) // true
45
46 small_sqpeg = new SquarePeg(2)
47 large_sqpeg = new SquarePeg(5)
48 hole.fits(small_sqpeg) // ошибка компиляции, несовместимые типы
49
50 small_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)
51 large_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)
52 hole.fits(small_sqpeg_adapter) // true
53 hole.fits(large_sqpeg_adapter) // false
154 Структурные паттерны / Адаптер
? Вы могли бы создать ещё один уровень подклассов, и
добавить в них недостающую функциональность. Но при
этом придётся дублировать один и тот же код в обеих
ветках подклассов.
Более элегантное решение — поместить недостающую
функциональность в адаптер и приспособить его для
работы с суперклассом. Такой адаптер сможет работать со
всеми подклассами иерархии. Это решение будет сильно
напоминать паттерн Посетитель.
? Шаги реализации
1. Убедитесь, что у вас есть два класса с неудобными
интерфейсами:
? полезный сервис — служебный класс, который вы не
можете изменять (он либо сторонний, либо от него
зависит другой код);
? один или несколько клиентов — классов приложения,
несовместимых с сервисом из-за неудобного или
несовпадающего интерфейса.
2. Опишите клиентский интерфейс, через который классы
приложения смогли бы использовать сторонний класс.
3. Создайте класс адаптера, реализовав этот интерфейс.
155 Структурные паттерны / Адаптер
4. Поместите в адаптер поле-ссылку на объект-сервис. В
большинстве случаев, это поле заполняется объектом,
переданным в конструктор адаптера. В случае простой
адаптации этот объект можно передавать через параметры
методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере.
Адаптер должен делегировать основную работу сервису.
6. Приложение должно использовать адаптер только через
клиентский интерфейс. Это позволит легко изменять и
добавлять адаптеры в будущем.
? Преимущества и недостатки
? Отделяет и скрывает от клиента подробности
преобразования различных интерфейсов.
? Усложняет код программы за счёт дополнительных классов.
? Отношения с другими паттернами
• Мост проектируют загодя, чтобы развивать большие части
приложения отдельно друг от друга. Адаптер применяется
постфактум, чтобы заставить несовместимые классы
работать вместе.
156 Структурные паттерны / Адаптер
• Адаптер меняет интерфейс существующего объекта.
Декоратор улучшает другой объект без изменения его
интерфейса. Причём Декоратор поддерживает
рекурсивную вложенность, чего не скажешь об Адаптере.
• Адаптер предоставляет классу альтернативный интерфейс.
Декоратор предоставляет расширенный интерфейс.
Заместитель предоставляет тот же интерфейс.
• Фасад задаёт новый интерфейс, тогда как Адаптер
повторно использует старый. Адаптер оборачивает только
один класс, а Фасад оборачивает целую подсистему. Кроме
того, Адаптер позволяет двум существующим интерфейсам
работать сообща, вместо того, чтобы задать полностью
новый.
• Мост, Стратегия и Состояние (а также слегка и Адаптер)
имеют схожие структуры классов — все они построены на
принципе «композиции», то есть делегирования работы
другим объектам. Тем не менее, они отличаются тем, что
решают разные проблемы. Помните, что паттерны — это не
только рецепт построения кода определённым образом, но
и описание проблем, которые привели к данному решению.
157 Структурные паттерны / Адаптер
МОСТ
Также известен как: Bridge
Мост — это структурный паттерн проектирования, который
разделяет один или несколько классов на две отдельные
иерархии — абстракцию и реализацию, позволяя изменять
их независимо друг от друга.
158 Структурные паттерны / Мост
? Проблема
Абстракция? Реализация?! Звучит пугающе! Чтобы понять, о
чём идёт речь, давайте разберём очень простой пример.
У вас есть класс геометрических Фигур , который имеет
подклассы Круг и Квадрат . Вы хотите расширить
иерархию фигур по цвету, то есть иметь Красные и Синие
фигуры. Но чтобы всё это объединить, вам придётся создать
4 комбинации подклассов вроде СиниеКруги и
КрасныеКвадраты .
Количество подклассов растёт в геометрической прогрессии.
При добавлении новых видов фигур и цветов количество
комбинаций будет расти в геометрической прогрессии.
Чтобы добавить подкласс Треугольник , придётся создать
159 Структурные паттерны / Мост
сразу два новых класса под каждый цвет. После этого
новый цвет потребует создания уже трёх классов, для всех
видов фигур. Чем дальше, тем хуже.
? Решение
Корень проблемы заключается в том, что мы пытаемся
расширить классы сразу в двух независимых плоскостях —
по виду и по цвету. Именно это приводит к разрастанию
дерева классов.
Паттерн Мост предлагает заменить наследование
делегированием. Для этого нужно выделить одну из таких
«плоскостей» в отдельную иерархию и ссылаться на объект
этой иерархии, вместо хранения его состояния и поведения
внутри одного класса.
Размножение подклассов можно остановить, разбив классы на
несколько иерархий.
160 Структурные паттерны / Мост
Таким образом, мы можем сделать Цвет отдельным
классом с подклассами Красный и Синий . Класс Фигур
получит ссылку на объект Цвета и сможет делегировать
ему работу, если потребуется. Такая связь и станет мостом
между Фигурами и Цветом . При добавлении новых классов
цветов, не потребуется трогать классы фигур и наоборот.
Абстракция и Реализация
Эти термины были введены в книге GoF1
при описании
Моста. На мой взгляд, они выглядят слишком
академичными, делая описание паттерна сложнее, чем он
есть на самом деле. Помня о примере с фигурами и
цветами, давайте все же разберёмся, что имели в виду
авторы паттерна.
Итак, «Абстракция» (или «интерфейс») — это образный слой
управления чем-либо. Он не делает работу самостоятельно,
а делегирует её слою «реализации» (иногда называемому
«платформой»).
1. Gang of Four / «Банда четырёх». Авторы книги Design Patterns: Elements
of Reusable Object-Oriented Software https://refactoring.guru/ru/gofbook.
161 Структурные паттерны / Мост
Только не путайте эти термины с интерфейсами или
абстрактными классами из вашего языка
программирования, это не одно и то же.
Если говорить о реальных программах, то абстракцией
может выступать графический интерфейс программы, а
реализацией — API, к которому интерфейс обращается по
реакции на действия пользователя.
Вы можете развивать программу в двух разных
направлениях:
• иметь несколько различных интерфейсов (например, для
простых пользователей и администраторов).
• поддерживать много видов API (например, работать под
Windows, Linux и MacOS).
Такая программа может выглядеть как один большой
клубок кода, в котором намешаны условные операторы
слоёв интерфейса и API операционных систем.
162 Структурные паттерны / Мост
Когда изменения осаждают проект, легче отбиваться, если разделить
монолитный код на части.
Вы можете попытаться структурировать этот хаос, создав
для каждой вариаций интерфейса-платформы свои
подклассы. Но такой подход приведёт к росту классов
комбинаций, и с каждой новой платформой их будет всё
больше.
Мы можем решить эту проблему, применив Мост. Паттерн
предлагает распутать этот код, разделив его на две части:
• Абстракцию: слой GUI приложения.
• Реализацию: слой взаимодействия с операционной
системой.
163 Структурные паттерны / Мост
Один из вариантов кросс-платформенной архитектуры.
Абстракция будет делегировать работу одному из объектовРеализаций. Реализации можно будет взаимозаменять, если
все они будут иметь общий интерфейс.
Вы сможете изменять интерфейс приложения, не трогая
низкоуровневый код работы с операционной системой. И
наоборот, сможете добавить поддержку новой
операционной системы, создав подкласс реализации, но не
трогая классы абстракции.
164 Структурные паттерны / Мост
? Структура
1. Абстракция содержит управляющую логику. Код абстракции
делегирует реальную работу связанному объекту
реализации.
2. Реализация задаёт общий интерфейс для всех реализаций.
Все методы, которые здесь описаны, будут доступны из
класса абстракции и его подклассов.
Интерфейсы абстракции и реализации могут как совпадать,
так или быть совершенно разными. Но обычно, в
реализации живут базовые операции, на которых строятся
сложные операции абстракции.
165 Структурные паттерны / Мост
3. Конкретные Реализации содержат платформо-зависимый
код.
4. Расширенные Абстракции содержат различные вариации
управляющей логики. Как и родитель, работает с
реализациями только через общий интерфейс реализации.
5. Клиент работает только с объектами абстракции. Не считая
первичного связывания абстракции с одной из реализаций,
клиентский код не имеет прямого доступа к объектам
реализации.
? Псевдокод
В этом примере Мост разделяет монолитный код приборов
и пультов на две части: приборы (выступают реализацией) и
пульты управления ними (выступают абстракцией).
166 Структурные паттерны / Мост
Пример разделения двух иерархий классов — приборов и пультов управления.
Класс пульта имеет ссылку на объект прибора, которым он
управляет. Пульты работают с приборами через общий
интерфейс. Это даёт возможность связать пульты с
различными приборами.
Сами пульты можно развивать независимо от приборов.
Для этого достаточно создать новый подкласс абстракции.
Вы можете создать простой как простой пульт с двумя
кнопками, так и более сложный пульт с тач-интерфейсом.
Клиентскому коду остаётся выбрать версию абстракции и
реализации, с которым он хочет работать.
167 Структурные паттерны / Мост
1 // Класс пультов имеет ссылку на устройство, которым
2 // управляет. Методы этого класса делегируют работу методам
3 // связанного устройства.
4 class Remote is
5 protected field device: Device
6 constructor Remote(device: Device) is
7 this.device = device
8 method togglePower() is
9 if (device.isEnabled()) then
10 device.disable()
11 else
12 device.enable()
13 method volumeDown() is
14 device.setVolume(device.getVolume() - 10)
15 method volumeUp() is
16 device.setVolume(device.getVolume() + 10)
17 method channelDown() is
18 device.setChannel(device.getChannel() - 1)
19 method channelUp() is
20 device.setChannel(device.getChannel() + 1)
21
22
23 // Вы можете расширять класс пультов не трогая
24 // код устройств.
25 class AdvancedRemote extends Remote is
26 method mute() is
27 device.setVolume(0)
28
29
30 // Все устройства имеют общий интерфейс. Поэтому с ними
31 // может работать любой пульт.
32 interface Device is
33 method isEnabled()
34 method enable()
168 Структурные паттерны / Мост
? Применимость
? Когда вы хотите разделить монолитный класс, который
содержит несколько различных реализаций какой-то
функциональности (например, может работать с разными
системами баз данных).
35 method disable()
36 method getVolume()
37 method setVolume(percent)
38 method getChannel()
39 method setChannel(channel)
40
41
42 // Но каждое устройство имеет особую реализацию.
43 class Tv implements Device is
44 // ...
45
46 class Radio implements Device is
47 // ...
48
49
50 // Где-то в клиентском коде.
51 tv = new Tv()
52 remote = new Remote(tv)
53 remote.power()
54
55 radio = new Radio()
56 remote = new AdvancedRemote(radio)
169 Структурные паттерны / Мост
? Чем больше класс, тем тяжелее разобраться в его коде, тем
больше это затягивает разработку. Кроме того, изменения,
вносимые в одну из реализаций, приводят к
редактированию всего класса, что может привести к
ошибкам.
Мост позволяет разделить монолитный класс на несколько
отдельных иерархий. После этого вы можете менять их код
независимо друг от друга. Это упрощает работу над кодом
и уменьшает вероятность внесения ошибок.
? Когда класс нужно расширять в двух независимых
плоскостях.
? Мост предлагает выделить одну из таких плоскостей в
отдельную иерархию классов, храня ссылку на один из её
объектов в первоначальном классе.
? Когда вы хотите, чтобы реализацию можно было бы
изменять во время выполнения программы.
? Мост позволяет заменять реализацию даже во время
выполнения программы, так как конкретная реализация не
«вшита» в класс абстракции.
Кстати, из-за этого пункта Мост часто путают со
Стратегией. Обратите внимания, что у Моста этот
170 Структурные паттерны / Мост
пункт стоит на последнем месте по значимости, так как
его главная задача — структурная.
? Шаги реализации
1. Определите, существует ли в ваших классах два
непересекающихся измерения. Это может быть
функциональность/платформа, предметная-область/
инфраструктура, фронт-энд/бэк-энд или интерфейс/
реализация.
2. Продумайте, какие операции будут нужны клиентам и
опишите их в базовом классе абстракции.
3. Определите поведения доступные на всех платформах и
выделите из них ту часть, которая будет нужная абстракции.
На основании этого опишите общий интерфейс реализации.
4. Для каждой платформы создайте свой класс конкретной
реализации. Все они должны следовать общему
интерфейсу, который мы выделили перед этим.
5. Добавьте в класс абстракции ссылку на объект реализации.
Реализуйте методы абстракции, делегируя основную работу
связанному объекту реализации.
6. Если у вас есть несколько вариаций абстракции, создайте
для каждой из них свой подкласс.
171 Структурные паттерны / Мост
7. Клиент должен подать объект реализации в конструктор
абстракции, чтобы связать их воедино. После этого он
может свободно использовать объект абстракции, забыв о
реализации.
? Преимущества и недостатки
? Позволяет строить платформо-независимые программы.
? Скрывает лишние или опасные детали реализации от
клиентского кода.
? Реализует принцип открытости/закрытости.
? Усложняет код программы за счёт дополнительных классов.
? Отношения с другими паттернами
• Мост проектируют загодя, чтобы развивать большие части
приложения отдельно друг от друга. Адаптер применяется
постфактум, чтобы заставить несовместимые классы
работать вместе.
• Мост, Стратегия и Состояние (а также слегка и Адаптер)
имеют схожие структуры классов — все они построены на
принципе «композиции», то есть делегирования работы
другим объектам. Тем не менее, они отличаются тем, что
решают разные проблемы. Помните, что паттерны — это не
172 Структурные паттерны / Мост
только рецепт построения кода определённым образом, но
и описание проблем, которые привели к данному решению.
• Абстрактная фабрика может работать совместно с Мостом.
Это особенно полезно, если у вас есть абстракции, которые
могут работать только с некоторыми из реализаций. В этом
случае фабрика будет определять типы создаваемых
абстракций и реализаций.
• Паттерн Строитель может быть построен в виде Моста:
директор будет играть роль абстракции, а строители
— реализации.
173 Структурные паттерны / Мост
КОМПОНОВЩИК
Также известен как: Дерево, Composite
Компоновщик — это структурный паттерн проектирования,
который позволяет сгруппировать объекты в древовидную
структуру, а затем работать с ними так, если бы это был
единичный объект.
174 Структурные паттерны / Компоновщик
? Проблема
Паттерн Компоновщик имеет смысл только тогда, когда
основная модель вашей программы может быть
структурирована в виде дерева.
Например, есть два объекта — Продукт и Коробка .
Коробка может содержать несколько Продуктов и других
Коробок поменьше. Те, в свою очередь, тоже содержат
либо Продукты , либо Коробки и так далее.
Заказ может состоять из различных позиций, упакованных в
собственные коробки.
175 Структурные паттерны / Компоновщик
Теперь, предположим, ваши Продукты и Коробки могут
быть частью заказов. Ваша задача в том, чтобы узнать цену
всего заказа. Причём в заказе может быть как просто
Продукт без упаковки, так и пустая или составная Коробка .
Если решать задачу в лоб, то вам потребуется открыть все
коробки заказа, перебрать все продукты и посчитать их
суммарную цену. Но это слишком хлопотно, так как типы
коробок и их содержимого могут быть вам неизвестны.
Кроме того, наперёд неизвестно и количество уровней
вложенности коробок, поэтому перебрать коробки простым
циклом не выйдет.
? Решение
Компоновщик предлагает рассматривать Продукт и
Коробку через единый интерфейс с общим методом
получения цены.
Продукт просто вернёт свою цену. Коробка спросит цену
каждого предмета внутри себя и вернёт сумму результатов.
Если одним из внутренних предметов окажется коробка
поменьше, она тоже будет перебирать своё содержимое, и
так далее, пока не посчитаются все составные части.
176 Структурные паттерны / Компоновщик
Компоновщик рекурсивно запускает действие по все элементы дерева от корня
к листьям.
Для вас, клиента, главное, что теперь не нужно ничего знать
о структуре заказов. Вы вызываете метод получения цены,
он возвращает цифру, а вы не тонете в горах картона и
скотча.
? Аналогия из жизни
Пример армейской структуры.
177 Структурные паттерны / Компоновщик
Армии большинства государств могут быть представлены в
виде перевёрнутых деревьев. На нижнем уровне у вас есть
солдаты, затем взводы, затем полки, а затем целые армии.
Приказы отдаются сверху и спускаются вниз по структуре
командования, пока не доходят до конкретного солдата.
? Структура
178 Структурные паттерны / Компоновщик
1. Компонент определяет общий интерфейс для простых и
составных компонентов дерева.
2. Лист – это простой элемент дерева, не имеющий
ответвлений.
Из-за того, что им некому больше передавать выполнение,
классы Листьев будут содержать большую часть полезного
кода.
3. Контейнер (или «композит») — это составной элемент
дерева. Он содержит набор дочерних компонентов, но
ничего не знает об их типах. Это могут быть как простые
компоненты-листья, так и другие компоненты-контейнеры.
Но это не является проблемой, так как все дочерние
элементы следуют общему интерфейсу.
Методы контейнера переадресуют основную работу своим
дочерним компонентам, хотя и могут добавлять что-то своё
к результату.
4. Клиент работает с деревом через общий интерфейс
компонентов.
Благодаря этому, клиенту без разницы что перед ним
находится — простой или составной компонент дерева.
179 Структурные паттерны / Компоновщик
? Псевдокод
В этом примере Компоновщик помогает реализовать
вложенные геометрические фигуры.
Пример редактора геометрических фигур.
Класс CompoundGraphic может содержать любое количество
подфигур, включая такие же контейнеры, как он сам.
Контейнер реализует те же методы, что и простые фигуры.
Но вместо непосредственного действия, он передаёт
180 Структурные паттерны / Компоновщик
вызовы всем вложенным компонентам, используя
рекурсию. Затем он как бы «суммирует» результаты всех
вложенных фигур.
Клиентский код работает со всеми фигурами через общий
интерфейс фигур и не знает что перед ним — простая
фигура или составная. Это позволяет клиентскому коду
работать с деревьями объектов любой сложности, не
привязываясь к конкретным классам объектов,
формирующих дерево.
1 // Общий интерфейс компонентов.
2 interface Graphic is
3 method move(x, y)
4 method draw()
5
6 // Простой компонент.
7 class Dot implements Graphic is
8 field x, y
9
10 constructor Dot(x, y) { ... }
11
12 method move(x, y) is
13 this.x += x, this.y += y
14
15 method draw() is
16 // Нарисовать точку в координате X, Y.
17
18 // Компоненты могут расширять другие компоненты.
19 class Circle extends Dot is
20 field radius
21
181 Структурные паттерны / Компоновщик
22 constructor Circle(x, y, radius) { ... }
23
24 method draw() is
25 // Нарисовать окружность в координате X, Y и радиусом R.
26
27 // Контейнер содержит операции добавления/удаления дочерних
28 // компонентов. Все стандартные операции интерфейса
29 // компонентов он делегирует каждому из
30 // дочерних компонентов.
31 class CompoundGraphic implements Graphic is
32 field children: array of Graphic
33
34 method add(child: Graphic) is
35 // Добавить компонент в список дочерних.
36
37 method remove(child: Graphic) is
38 // Убрать компонент из списка дочерних.
39
40 method move(x, y) is
41 foreach (child in children) do
42 child.move(x, y)
43
44 method draw() is
45 // 1. Для каждого дочернего компонента:
46 // - Отрисовать компонент.
47 // - Определить координаты максимальной границы.
48 // 2. Нарисовать пунктирную границу вокруг всей области.
49
50
51 // Приложение работает единообразно как с единичными
52 // компонентами, так и целыми группами компонентов.
53 class ImageEditor is
54 method load() is
55 all = new CompoundGraphic()
182 Структурные паттерны / Компоновщик
? Применимость
? Когда вам нужно представить древовидную структуру
объектов.
? Паттерн Компоновщик предлагает хранить в составных
объектах ссылки на другие простые или составные объекты.
Те, в свою очередь, тоже могут хранить свои вложенные
объекты и так далее. В итоге вы можете строить сложную
древовидную структуру данных, используя всего две
основные разновидности объектов.
? Когда клиенты должны единообразно трактовать простые
и составные объекты.
56 all.add(new Dot(1, 2))
57 all.add(new Circle(5, 3, 10))
58 // ...
59
60 // Группировка выбранных компонентов в один
61 // сложный компонент.
62 method groupSelected(components: array of Graphic) is
63 group = new CompoundGraphic()
64 group.add(components)
65 all.remove(components)
66 all.add(group)
67 // Все компоненты будут отрисованы.
68 all.draw()
183 Структурные паттерны / Компоновщик
? Благодаря тому, что простые и составные объекты
реализуют общий интерфейс, клиенту безразлично с каким
именно объектом ему предстоит работать.
? Шаги реализации
1. Убедитесь, что вашу бизнес-логику можно представить как
древовидную структуру. Попытайтесь разбить её на простые
элементы и контейнеры. Помните, что контейнеры могут
содержать как простые элементы, так и другие контейнеры.
2. Создайте общий интерфейс компонентов, который
объединит операции контейнеров и простых элементов
дерева. Интерфейс будет удачным, если вы сможете
взаимозаменять простые и составные компоненты без
потери смысла.
3. Создайте класс компонентов-листьев, не имеющих
дальнейших ответвлений. Имейте в виду, что программа
может содержать несколько видов таких классов.
4. Создайте класс компонентов-контейнеров, и добавьте в
него массив для хранения ссылок на вложенные
компоненты. Этот массив должен быть способен содержать
как простые, так и составные компоненты, поэтому
убедитесь, что он объявлен с типом интерфейса
компонентов.
184 Структурные паттерны / Компоновщик
Реализуйте в контейнере методы интерфейса компонентов,
помня о том, что контейнеры должны делегировать
основную работу своим дочерним компонентам.
5. Добавьте операции добавления и удаления дочерних
элементов в класс контейнеров.
Имейте в виду, что методы добавления/удаления дочерних
элементов можно поместить и в интерфейс компонентов.
Да, это нарушит принцип разделения интерфейса, так как
реализации методов будут пустыми в компонентах-листьях.
Но зато все компоненты дерева станут действительно
одинаковыми для клиента.
? Преимущества и недостатки
? Упрощает архитектуру клиента при работе со сложным
деревом компонентов.
? Облегчает добавление новых видов компонентов.
? Создаёт слишком общий дизайн классов.
? Отношения с другими паттернами
• Строитель позволяет пошагово сооружать дерево
Компоновщика.
185 Структурные паттерны / Компоновщик
• Цепочку обязанностей часто используют вместе с
Компоновщиком. В этом случае, запрос передаётся от
дочерних компонентов к их родителям.
• Вы можете обходить дерево Компоновщика, используя
Итератор.
• Вы можете выполнить какое-то действие над всем деревом
Компоновщика при помощи Посетителя.
• Компоновщик часто совмещают с Легковесом, чтобы
реализовать общие ветки дерева и сэкономить при этом
память.
• Компоновщик и Декоратор имеют похожие структуры
классов из-за того, что оба построены на рекурсивной
вложенности. Она позволяет связать в одну структуру
бесконечное количество объектов.
Декоратор оборачивает только один объект, а узел
Компоновщика может иметь много детей. Декоратор
добавляет вложенному объекту новую функциональность, а
Компоновщик не добавляет ничего нового, но «суммирует»
результаты всех своих детей.
Но они могут и сотрудничать: Компоновщик может
использовать Декоратор, чтобы переопределить функции
отдельных частей дерева компонентов.
186 Структурные паттерны / Компоновщик
• Архитектура, построенная на Компоновщиках и
Декораторах, часто может быть улучшена за счёт
внедрения Прототипа. Он позволяет клонировать сложные
структуры объектов, а не собирать их заново.
187 Структурные паттерны / Компоновщик
ДЕКОРАТОР
Также известен как: Обёртка, Decorator
Декоратор — это структурный паттерн проектирования,
который позволяет динамически добавлять объектам новую
функциональность, оборачивая их в полезные «обёртки».
188 Структурные паттерны / Декоратор
? Проблема
Вы работаете над библиотекой оповещений, которую
можно подключать к разнообразным программам, чтобы
получать уведомления о важных событиях.
Основой библиотеки является класс Notificator с
методом send , который принимает на вход строкусообщение и высылает её всем администраторам по
электронной почте. Сторонняя программа должна создать и
настроить этот объект, указав кому слать оповещения, а
затем использовать его каждый раз, когда что-то случается.
Сторонние программы используют главный класс оповещений.
В какой-то момент стало понятно, что одних emailоповещений пользователям мало. Некоторые из
пользователей хотели бы получать извещения о
критических проблемах через SMS. Другие пользователи
хотят получать их в виде сообщений Facebook.
Корпоративные пользователи хотят видеть сообщения в
Slack.
189 Структурные паттерны / Декоратор
Каждый способ оповещения живёт в собственном подклассе.
Сначала вы добавили каждый из этих видов оповещений в
программу, унаследовав их от базового класса
Notificator . Теперь пользователь выбирал один из видов
оповещений, который и использовался в дальнейшем.
Но затем кто-то резонно спросил, почему нельзя выбрать
несколько видов оповещений сразу? Ведь если вдруг
загорается ваш дом, вы бы хотели получить оповещения по
всем каналам, верно?
Комбинаторный взрыв подклассов при совмещении способов оповещений.
190 Структурные паттерны / Декоратор
Вы попытались реализовать все возможные комбинации
подклассов оповещений. Но после того, как вы добавили
первый десяток классов, стало ясно, что такой подход
невероятно раздувает код программы.
Итак, нужен какой-то другой способ комбинировать
поведения объектов, который не приводит к взрыву
количества подклассов.
? Решение
Наследование — это первое, что приходит в голову многим
программистам, когда нужно расширить какое-то
существующее поведение. Но механизм наследования
имеет несколько досадных проблем.
• Он статичен. Вы не можете изменить поведение
существующего объекта. Для этого вам надо создать новый
объект, выбрав другой подкласс.
• Он не разрешает наследовать поведение нескольких
классов одновременно. Из-за этого вам приходится
создавать множество подклассов-комбинаций для
получения совмещённого поведения.
Одним из способов обойти эти проблемы является
механизм композиции. Это когда один объект содержит
191 Структурные паттерны / Декоратор
другой, вместо того, чтобы наследовать его. Как раз на этом
принципе построен паттерн декоратор.
Наследование против Композиции
Декоратор имеет альтернативное название — «обёртка».
Оно удачнее описывает суть паттерна: вы помещаете
целевой объект в другой объект-обёртку, который запускает
базовое поведение объекта, а затем добавляет к результату
что-то своё.
Оба объекта имеют общий интерфейс, поэтому для
пользователя нет никакой разницы с чем работать — с
чистым объектом или обёрнутым. Вы можете использовать
несколько разных обёрток одновременно — результат
будет иметь объединённое поведение всех обёрток сразу.
В нашем примере с оповещениями, мы оставим в базовом
классе простую отправку по электронной почте, а
расширенные способы отправки сделаем декораторами.
Сторонняя программа, выступающая клиентом, во время
первичной настройки будет заворачивать объект
192 Структурные паттерны / Декоратор
оповещений в те обёртки, которые соответствуют
желаемому способу оповещения.
Расширенные способы оповещения становятся декораторами.
Последняя обёртка в списке и будет тем объектом, с
которым клиент будет работать в остальное время. Для
остального клиентского кода, по сути, ничего не изменится,
ведь все обёртки имеют точно такой же интерфейс, что и
базовый класс оповещений.
Таким же образом можно изменять не только способ
доставки оповещений, но и форматирование сообщения,
список адресатов, и так далее.
193 Структурные паттерны / Декоратор
Программа может составлять составные объекты из декораторов.
К тому же, клиент может «дообернуть» объект любыми
другими обёртками, когда ему захочется.
? Аналогия из жизни
Одежду можно надевать слоями, получая комбинированный эффект.
194 Структурные паттерны / Декоратор
Любая одежда — это аналог декоратора. Применяя
декоратор, вы не меняете первоначальный класс и не
создаёте дочерних классов. Так и с одеждой — надевая
свитер, вы не перестаёте быть собой, но получаете новое
свойство — защиту от холода. Вы можете пойти дальше и
надеть сверху ещё один декоратор, плащ, чтобы защититься
и от дождя.
? Структура
195 Структурные паттерны / Декоратор
1. Компонент задаёт общий интерфейс обёрток и
оборачиваемых объектов.
2. Конкретный Компонент определяет класс оборачиваемых
объектов. Он содержит какое-то базовое поведение,
которое потом изменяют декораторы.
3. Базовый Декоратор хранит ссылку на вложенный объекткомпонент. Им может быть как конкретный компонент, так и
один из конкретных декораторов. Базовый декоратор
делегирует все свои операции вложенному объекту.
Дополнительное поведение будет жить в конкретных
декораторах.
4. Конкретные Декораторы — это различные вариации
декораторов, которые содержат добавочное поведение.
Оно выполняется до или после вызова аналогичного
поведения обёрнутого объекта.
5. Клиент может оборачивать простые компоненты и
декораторы в другие декораторы, старясь работать со
всему объектами через общий интерфейс компонентов.
? Псевдокод
В этом примере Декоратор защищает финансовые данные
дополнительными уровнями безопасности прозрачно для
кода, который их использует.
196 Структурные паттерны / Декоратор
Пример шифрования и компрессии данных с помощью обёрток.
Приложение оборачивает класс данных в шифрующую и
сжимающую обёртку, которые при чтении выдают
оригинальные данные, а при записи — сжатые и
зашифрованные.
Декораторы, как и сам класс данных, имеют общий
интерфейс. Поэтому клиентскому коду без разницы с чем
работать.
197 Структурные паттерны / Декоратор
1 // Общий интерфейс компонентов.
2 interface DataSource is
3 method writeData(data)
4 method readData():data
5
6 // Один из конкретных компонент, реализует
7 // базовую функциональность.
8 class FileDataSource implements DataSource is
9 constructor FileDataSource(filename) { ... }
10
11 method writeData(data) is
12 // Записать данные в файл.
13
14 method readData():data is
15 // Прочитать данные из файла.
16
17
18 // Родитель всех декораторов содержит код обёртывания.
19 class DataSourceDecorator implements DataSource is
20 protected field wrappee: DataSource
21
22 constructor DataSourceDecorator(source: DataSource) is
23 wrappee = source
24
25 method writeData(data) is
26 wrappee.writeData(data)
27
28 method readData():data is
29 return wrappee.readData()
30
31
32 // Конкретные декораторы добавляют что-то своё к базовому
33 // поведению обёрнутого компонента.
34 class EncyptionDecorator extends DataSourceDecorator is
198 Структурные паттерны / Декоратор
35 method writeData(data) is
36 // 1. Зашифровать поданные данные.
37 // 2. Передать зашифрованные данные в метод writeData
38 // обёрнутого объекта (wrappee).
39
40 method readData():data is
41 // 1. Получить данные из метода readData обёрнутого
42 // объекта (wrappee).
43 // 2. Расшифровать их, если они зашифрованы.
44 // 3. Вернуть результат.
45
46 // Декорировать можно не только базовые компоненты, но и уже
47 // обёрнутые объекты.
48 class CompressionDecorator extends DataSourceDecorator is
49 method writeData(data) is
50 // 1. Запаковать поданные данные.
51 // 2. Передать запакованные данные в метод writeData
52 // обёрнутого объекта (wrappee).
53
54 method readData():data is
55 // 1. Получить данные из метода readData обёрнутого
56 // объекта (wrappee).
57 // 2. Распаковать их, если они запакованы.
58 // 3. Вернуть результат.
59
60 // Вариант 1. Простой пример сборки и
61 // использования декораторов.
62 class Application is
63 method dumbUsageExample() is
64 source = new FileDataSource("somefile.dat")
65 source.writeData(salaryRecords)
66 // В файл были записаны чистые данные.
67
68 source = new CompressionDecorator(source)
199 Структурные паттерны / Декоратор
69 source.writeData(salaryRecords)
70 // В файл были записаны сжатые данные.
71
72 source = new EncyptionDecorator(source)
73 // source — это связка из трёх объектов:
74 // Encryption > Compression > FileDataSource
75 source.writeData(salaryRecords)
76 // В файл были записаны сжатые и
77 // зашифрованные данные.
78
79 // Вариант 2. Клиентский код, использующий внешний источник
80 // данных. Класс SalaryManager ничего не знает о том как
81 // именно будут считаны и записаны данные. Он получает уже
82 // готовый источник данных.
83 class SalaryManager is
84 field source: DataSource
85
86 constructor SalaryManager(source: DataSource) { ... }
87
88 method load() is
89 return source.readData()
90
91 method save() is
92 source.writeData(salaryRecords)
93 // ...Остальные полезные методы...
94
95
96 // Приложение может по-разному собирать декорируемые
97 // объекты, в зависимости от условий использования.
98 class ApplicationConfigurator is
99 method configurationExample() is
100 source = new FileDataSource("salary.dat")
101 if (enabledEncryption)
102 source = new EncyptionDecorator(source)
200 Структурные паттерны / Декоратор
? Применимость
? Когда вам нужно добавлять обязанности объектам на лету,
незаметно для кода, который их использует.
? Объекты помещают в обёртки, имеющие дополнительные
поведения. Обёртки и сами объекты имеют одинаковый
интерфейс, поэтому клиентам без разницы с чем работать
— с обычным объектом или обёрнутым.
? Когда нельзя расширить обязанности объекта с помощью
наследования.
? Во многих языках программирования есть ключевое слово
final , которое может заблокировать наследование класса.
Расширить такие классы можно только с помощью
Декоратора.
103 if (enabledCompression)
104 source = new CompressionDecorator(source)
105
106 logger = new SalaryLogger(source)
107 salary = logger.load()
108 // ...
201 Структурные паттерны / Декоратор
? Шаги реализации
1. Убедитесь, что в вашей задаче есть один основной
компонент и несколько опциональных дополнений или
надстроек над ним.
2. Создайте интерфейс компонента, который описывал бы все
общие методы как для основного компонента, так и для его
дополнений.
3. Создайте класс конкретного компонента и поместите в него
основную бизнес-логику.
4. Создайте базовый класс декораторов. Он должен иметь
поле для хранения ссылки на вложенный объект-компонент.
Все методы базового декоратора должны делегировать
действие вложенному объекту.
5. И конкретный компонент, и базовый декоратор должны
следовать одному и тому же интерфейсу компонента.
6. Теперь создайте классы конкретных декораторов, наследуя
их от базового декоратора. Конкретный декоратор должен
выполнять свою добавочную функциональность, а затем
(или перед этим) вызывать эту же операцию обёрнутого
объекта.
7. Клиент берёт на себя ответственность за конфигурацию и
порядок обёртывания объектов.
202 Структурные паттерны / Декоратор
? Преимущества и недостатки
? Большая гибкость, чем у наследования.
? Позволяет добавлять обязанности на лету.
? Можно добавлять несколько новых обязанностей сразу.
? Позволяет иметь несколько мелких объектов вместо одного
объекта на все случаи жизни.
? Трудно конфигурировать многократно обёрнутые объекты.
? Обилие крошечных классов.
? Отношения с другими паттернами
• Адаптер меняет интерфейс существующего объекта.
Декоратор улучшает другой объект без изменения его
интерфейса. Причём Декоратор поддерживает
рекурсивную вложенность, чего не скажешь об Адаптере.
• Адаптер предоставляет классу альтернативный интерфейс.
Декоратор предоставляет расширенный интерфейс.
Заместитель предоставляет тот же интерфейс.
• Цепочка обязанностей и Декоратор имеют очень похожие
структуры. Оба паттерна базируются на принципе
рекурсивного выполнения операции через серию
связанных объектов. Но есть и несколько важных отличий.
203 Структурные паттерны / Декоратор
Обработчики в Цепочке обязанностей могут выполнять
произвольные действия, независимые друг от друга, а
также в любой момент прерывать дальнейшую передачу по
цепочке. С другой стороны Декораторы расширяют какоето определённое действие, не ломая интерфейс базовой
операции и не прерывая выполнение остальных
декораторов.
• Компоновщик и Декоратор имеют похожие структуры
классов из-за того, что оба построены на рекурсивной
вложенности. Она позволяет связать в одну структуру
бесконечное количество объектов.
Декоратор оборачивает только один объект, а узел
Компоновщика может иметь много детей. Декоратор
добавляет вложенному объекту новую функциональность, а
Компоновщик не добавляет ничего нового, но «суммирует»
результаты всех своих детей.
Но они могут и сотрудничать: Компоновщик может
использовать Декоратор, чтобы переопределить функции
отдельных частей дерева компонентов.
• Архитектура, построенная на Компоновщиках и
Декораторах, часто может быть улучшена за счёт
внедрения Прототипа. Он позволяет клонировать сложные
структуры объектов, а не собирать их заново.
204 Структурные паттерны / Декоратор
• Стратегия меняет поведение объекта «изнутри», а
Декоратор изменяет его «снаружи».
• Декоратор и Заместитель имеют похожие структуры, но
разные назначения. Они похожи тем, что оба построены на
композиции и делегировании работы другому объекту.
Паттерны отличаются тем, что Заместитель сам управляет
жизнью сервисного объекта, а обёртывание Декораторов
контролируется клиентом.
205 Структурные паттерны / Декоратор
ФАСАД
Также известен как: Facade
Фасад — это структурный паттерн проектирования, который
предоставляет простой интерфейс к сложной системе
классов, библиотеке или фреймворку.
206 Структурные паттерны / Фасад
? Проблема
Вашему коду приходится работать с большим количеством
объектов некой сложной библиотеки или фреймворка. Вы
должны самостоятельно инициализировать эти объекты,
следить за правильным порядком зависимостей и так
далее.
В результате, бизнес-логика ваших классов тесно
переплетается с деталями реализации сторонних классов.
Такой код довольно сложно понимать и поддерживать.
? Решение
Фасад — это простой интерфейс работы со сложной
подсистемой, содержащей множество классов. Фасад может
иметь урезанный интерфейс, не имеющий 100%
функциональности, которую можно достичь, используя
сложную подсистему напрямую. Но он предоставляет
именно те фичи, которые нужны клиенту, и скрывает все
остальное.
Фасад полезен, если вы используете какую-то сложную
библиотеку с множеством подвижных частей, но вам нужна
только часть её возможностей.
К примеру, программа, заливающая видео котиков в
социальные сети, может использовать профессиональную
207 Структурные паттерны / Фасад
библиотеку сжатия видео. Но все что нужно клиентскому
коду этой программы — простой метод
encode(filename, format) . Создав класс с таким методом,
вы реализуете свой первый фасад.
? Аналогия из жизни
Пример телефонного заказа.
Когда вы звоните в магазин и делаете заказ по телефону,
сотрудник службы поддержки является вашим фасадом ко
всем службам и отделам магазина. Он предоставляет вам
упрощённый интерфейс к системе создания заказа,
платёжной системе и отделу доставки.
208 Структурные паттерны / Фасад
? Структура
1. Фасад предоставляет быстрый доступ к определённой
функциональности подсистемы. Он «знает», каким классам
нужно переадресовать запрос, и какие данные для этого
нужны.
2. Дополнительный фасад можно ввести, чтобы не захламлять
единственный фасад разнородной функциональностью. Он
может использоваться как клиентом, так и другими
фасадами.
3. Сложная подсистема состоит из множества разнообразных
классов. Для того чтобы заставить их что-то делать, нужно
знать подробности устройства подсистемы, порядок
инициализации объектов и так далее.
209 Структурные паттерны / Фасад
Классы подсистемы не знают о существовании фасада и
работают друг с другом напрямую.
4. Клиент использует фасад вместо прямой работы с
объектами сложной подсистемы.
? Псевдокод
В этом примере Фасад упрощает работу со сложным
фреймворком видеоконвертации.
Пример изоляции множества зависимостей в одном фасаде.
Вместо непосредственной работы с дюжиной классов,
фасад предоставляет коду приложения единственный
метод для конвертации видео, который сам заботится о том,
210 Структурные паттерны / Фасад
чтобы правильно сконфигурировать нужные объекты
фреймворка и получить требуемый результат.
1 // Классы сложного стороннего фреймворка конвертации видео.
2 // Мы не контролируем этот код, поэтому не можем
3 // его упростить.
4
5 class VideoFile
6 // ...
7
8 class OggCompressionCodec
9 // ...
10
11 class MPEG4CompressionCodec
12 // ...
13
14 class CodecFactory
15 // ...
16
17 class BitrateReader
18 // ...
19
20 class AudioMixer
21 // ...
22
23
24 // Вместо этого, мы создаём Фасад — простой интерфейс для
25 // работы со сложным фреймворком. Фасад не имеет всей
26 // функциональности фреймворка, но зато скрывает его
27 // сложность от клиентов.
28 class VideoConverter is
29 method convert(filename, format):File is
30 file = new VideoFile(filename)
211 Структурные паттерны / Фасад
? Применимость
? Когда вам нужно представить простой или урезанный
интерфейс к сложной подсистеме.
? Часто подсистемы усложняются по мере развития.
Применение большинства паттернов приводит к появлению
меньших классов, но в бoльшем количестве. Такую
подсистему проще повторно использовать и настраивать
под конкретные нужды, но вместе с тем применять
подсистему без настройки становится труднее. Фасад
31 sourceCodec = new CodecFactory.extract(file)
32 if (format == "mp4")
33 distinationCodec = new MPEG4CompressionCodec()
34 else
35 distinationCodec = new OggCompressionCodec()
36 buffer = BitrateReader.read(filename, sourceCodec)
37 result = BitrateReader.convert(buffer, distinationCodec)
38 result = (new AudioMixer()).fix(result)
39 return new File(result)
40
41 // Приложение не зависит от сложного фреймворка конвертации
42 // видео. Кстати, если вы вдруг решите сменить фреймворк,
43 // вам нужно будет переписать только класс фасада.
44 class Application is
45 method main() is
46 convertor = new VideoConverter()
47 mp4 = convertor.convert("youtubevideo.ogg", "mp4")
48 mp4.save()
212 Структурные паттерны / Фасад
предлагает некоторый вид системы по умолчанию,
устраивающий большинство клиентов.
? Когда вы хотите разложить подсистему на отдельные слои.
? Используйте фасады для определения точек входа на
каждый уровень подсистемы. Если подсистемы зависят друг
от друга, то зависимость можно упростить, разрешив
подсистемам обмениваться информацией только через
фасады.
Например, возьмём ту же сложную система
видеоконвертации. Вы хотите разбить её на слои работы с
аудио и видео. Для каждой из этих частей можно
попытаться создать фасад и заставить классы аудио и видео
обработки общаться друг с другом через эти фасады, а не
напрямую.
? Шаги реализации
1. Определите можно ли создать более простой интерфейс,
чем тот, который предоставляет сложная подсистема. Вы на
правильном пути, если этот интерфейс избавит клиента от
знания о подробностях подсистемы.
2. Создайте класс фасада, реализующий этот интерфейс. Он
должен переадресовывать вызовы клиента нужным
объектам подсистемы. Фасад должен будет позаботиться о
213 Структурные паттерны / Фасад
том, чтобы правильно инициализировать объекты
подсистемы.
3. Вы получите максимум пользы, если клиент будет работать
только с фасадом. В этом случае, изменения в подсистеме
будут затрагивать только код фасада, а клиентский код
останется рабочим.
4. Если ответственность фасада начинает размываться,
подумайте о введении дополнительных фасадов.
? Преимущества и недостатки
? Изолирует клиентов от компонентов системы.
? Уменьшает зависимость между подсистемой и клиентами.
? Фасад рискует стать божественным объектом,
привязанным ко всем классам программы.
? Отношения с другими паттернами
• Фасад задаёт новый интерфейс, тогда как Адаптер
повторно использует старый. Адаптер оборачивает только
один класс, а Фасад оборачивает целую подсистему. Кроме
того, Адаптер позволяет двум существующим интерфейсам
214 Структурные паттерны / Фасад
работать сообща, вместо того, чтобы задать полностью
новый.
• Абстрактная фабрика может быть использована вместо
Фасада для того, чтобы скрыть платформо-зависимые
классы.
• Легковес показывает, как создавать много мелких объектов,
а Фасад показывает, как создать один объект, который
отображает целую подсистему.
• Посредник и Фасад похожи тем, что пытаются организовать
работу множества существующих классов.
? Фасад создаёт упрощённый интерфейс к подсистеме, не
внося в неё никакой добавочной функциональности.
Сама подсистема не знает о существовании Фасада.
Классы подсистемы общаются друг с другом напрямую.
? Посредник централизует общение между компонентами
системы. Компоненты системы знают только о
существовании Посредника, у них нет прямого доступа к
другим компонентам.
• Фасад можно сделать Одиночкой, так как обычно нужен
только один объект-фасад.
• Фасад похож на Заместитель тем, что замещает сложную
подсистему и может сам её инициализировать. Но в
215 Структурные паттерны / Фасад
отличие от Фасада, Заместитель имеет тот же интерфейс,
что его служебный объект, благодаря чему их можно
взаимозаменять.
216 Структурные паттерны / Фасад
ЛЕГКОВЕС
Также известен как: Приспособленец, Кэш, Flyweight
Легковес — это структурный паттерн проектирования,
который позволяет вместить бoльшее количество объектов
в отведённую оперативной память за счёт экономного
разделения общего состояния объектов между собой,
вместо хранения одинаковых данных в каждом объекте.
217 Структурные паттерны / Легковес
? Проблема
На досуге вы решили написать небольшую игру-стрелялку, в
которой игроки перемещаются по карте и стреляют друг в
друга. Фишкой игры должна была стать реалистичная
система частиц. Пули, снаряды, осколки от взрывов — всё
это должно красиво летать и радовать взгляд.
Игра отлично работала на вашем мощном компьютере.
Однако ваш друг сообщил, что игра начинает тормозить и
вылетает через несколько минут после запуска.
Покопавшись в логах, вы обнаружили, что игра вылетает
из-за недостатка оперативной памяти. И действительно,
каждая частица представлена собственным объектом,
имеющим множество данных.
В определённый момент, когда побоище на экране
достигает кульминации, новые объекты частиц уже не
помещаются в оперативную память компьютера и
программа вылетает.
218 Структурные паттерны / Легковес
? Решение
Если внимательно посмотреть на класс частиц, то можно
заметить, что цвет и спрайт занимают больше всего памяти.
Более того, они хранятся в каждом объекте, хотя
фактически их значения одинаковые для большинства
частиц.
Остальное состояние объектов — координаты, вектор
движения и скорость отличаются для всех частиц. Таким
образом, эти поля можно рассматривать как контекст, в
котором частица используется. А цвет и спрайт — это
данные, не изменяющиеся во времени.
Неизменяемые данные объекта принято называть
«внутренним состоянием». Все остальные данные — это
«внешнее состояние».
Паттерн Легковес предлагает не хранить в классе внешнее
состояние, а передавать его в те или иные методы через
219 Структурные паттерны / Легковес
параметры. Таким образом, одни и те же объекты можно
будет повторно использовать в различных контекстах. Но
главное, понадобится гораздо меньше объектов, ведь они
теперь будут отличаться только внутренним состоянием, а
оно имеет не так много вариаций.
220 Структурные паттерны / Легковес
В нашем примере с частицами, достаточно будет оставить
всего три объекта с отличающимися спрайтами и цветом —
для пуль, снарядов и осколков. Несложно догадаться, что
такие облегчённые объекты называют «легковeсами».
Хранилище внешнего состояния
Но куда переедет внешнее состояние? Ведь кто-то должен
его хранить. Чаще всего, его перемещают в контейнер,
который управлял объектами до применения паттерна.
В нашем случае, это был главный объект игры. Вы могли бы
создать в нём дополнительные поля-массивы для хранения
координат, векторов и скоростей. Кроме этого, понадобится
ещё один массив для хранения ссылок на объектылегковесы, соответствующие той или иной частице.
Но более элегантным решением было бы создать
дополнительный класс-контекст, который связывал внешнее
221 Структурные паттерны / Легковес
состояние с тем или иным легковесом. Это позволит
обойтись только одним полем-массивом в классе
контейнера.
«Но погодите-ка, нам потребуется столько же этих
объектов, сколько было в самом начале!» — скажете вы и
будете правы! Но дело в том, что объекты-контексты
занимают намного меньше места, чем первоначальные.
Ведь самые тяжёлые поля остались в легковесах (простите
за каламбур), и сейчас мы будем ссылаться на эти объекты
из контекстов вместо того, чтобы хранить дублирующее
состояние.
Неизменяемость Легковесов
Так как объекты легковесов будут использованы в разных
контекстах, вы должны быть уверены в том, что их
состояние невозможно изменять после создания. Всё
внутреннее состояние легковес должен получать через
параметры конструктора. Он не должен иметь сеттеров и
публичных полей.
Фабрика Легковесов
Для удобства работы с легковесами и контекстами можно
создать фабричный метод, принимающий в параметрах всё
внутреннее (а иногда и внешнее) состояние желаемого
объекта.
222 Структурные паттерны / Легковес
Главная польза от этого метода в том, чтобы искать уже
созданные легковесы с таким же внутренним состоянием,
что и требуемое. Если легковес находится, его можно
повторно использовать. Если нет — просто создаём новый.
Обычно этот метод добавляют в контейнер легковесов либо
создают отдельный класс-фабрику. Его даже можно сделать
статическим и поместить в класс легковесов.
? Структура
1. Вы всегда должны помнить о том, что Легковес
применяется в программе, имеющей громадное количество
одинаковых объектов. Этих объектов было так много, что
они не помещались в доступную оперативную память без
223 Структурные паттерны / Легковес
ухищрений. Паттерн разделил данные этих объектов на две
части — контексты и легковесы.
2. Легковес содержит состояние, которое повторялось во
множестве первоначальных объектов. Один и тот же
легковес можно использовать в связке с множеством
контекстов. Состояние, которое хранится здесь, называется
внутренним, а то, которое он получает извне — внешним.
3. Контекст содержит «внешнюю» часть состояния,
уникальную для каждого объекта. Контекст связан с одним
из объектов-легковесов, хранящих оставшееся состояние.
4. Поведение оригинального объекта чаще всего оставляют в
Легковесе, передавая значения контекста через параметры
методов. Тем не менее, поведение можно поместить и в
контекст, используя легковес как объект данных.
5. Клиент вычисляет или хранит контекст, то есть внешнее
состояние легковесов. Для клиента легковесы выглядят как
шаблонные объекты, которые можно настроить во время
использования, передав контекст через параметры.
6. Фабрика легковесов управляет созданием и повторным
использованием легковесов. Фабрика получает запросы, в
которых указано желаемое состояние легковеса. Если
легковес с таким состоянием уже создан, фабрика сразу его
возвращает, а если нет — создаёт новый объект.
224 Структурные паттерны / Легковес
? Псевдокод
В этом примере Легковес помогает сэкономить
оперативную память при отрисовке на холсте миллионов
объектов-деревьев.
Легковес выделяет повторяющуюся часть состояния из
основного класса Tree и помещает его в дополнительный
класс TreeType .
Теперь вместо хранения повторяющихся данных во всех
объектах, отдельные деревья будут ссылаться на несколько
общих объектов, хранящих эти данные. Клиент работает с
деревьями через фабрику деревьев, которая скрывает от
него сложность кеширования общих данных деревьев.
225 Структурные паттерны / Легковес
Таким образом, программа будет использовать намного
меньше оперативной памяти, что позволит отрисовать
больше деревьев на экране на том же железе.
1 // Этот класс-легковес содержит часть полей, которые
2 // описывают деревья. Эти поля не уникальные для каждого
3 // дерева в отличие, например, от координат — несколько
4 // деревьев могут иметь ту же текстуру.
5 //
6 // Поэтому мы переносим повторяющиеся данные в один
7 // единственный объект и ссылаемся на него из множества
8 // отдельных деревьев.
9 class TreeType is
10 field name
11 field color
12 field texture
13 constructor TreeType(name, color, texture) { ... }
14 method draw(canvas, x, y) is
15 // 1. Создать картинку данного типа, цвета и текстуры.
16 // 2. Нарисовать картинку на холсте в позиции X, Y.
17
18 // Фабрика легковесов решает когда нужно создать новый
19 // легковес, а когда можно обойтись существующим.
20 class TreeFactory is
21 static field treeTypes: collection of tree types
22 static method getTreeType(name, color, texture) is
23 type = treeTypes.find(name, color, texture)
24 if (type == null)
25 type = new TreeType(name, color, texture)
26 treeTypes.add(type)
27 return type
28
29
226 Структурные паттерны / Легковес
? Применимость
? Когда не хватает оперативной памяти для поддержки всех
нужных объектов.
30 // Контекстный объект, из которого мы выделили легковес
31 // TreeType. В программе могут быть тысячи объектов Tree,
32 // так как накладные расходы на их хранение совсем небольшие
33 // — порядка трёх целых чисел (две координаты и ссылка).
34 class Tree is
35 field x,y
36 field type: TreeType
37 constructor Tree(x, y, type) { ... }
38 method draw(canvas) is
39 type.draw(canvas, this.x, this.y)
40
41 // Классы Tree и Forest являются клиентами Легковеса. При
42 // желании их можно слить в один класс, если вам не нужно
43 // расширять класс деревьев далее.
44 class Forest is
45 field trees: collection of Trees
46
47 method plantTree(x, y, name, color, texture) is
48 type = TreeFactory.getTreeType(name, color, texture)
49 tree = new Tree(x, y, type)
50 trees.add(tree)
51
52 method draw(canvas) is
53 foreach (tree in trees) do
54 tree.draw(canvas)
227 Структурные паттерны / Легковес
? Эффективность паттерна Легковес во многом зависит от
того, как и где он используется. Применяйте этот паттерн,
когда выполнены все перечисленные условия:
• в приложении используется большое число объектов;
• из-за этого высоки расходы оперативной памяти;
• большую часть состояния объектов можно вынести за
пределы их классов;
• многие группы объектов можно заменить относительно
небольшим количеством разделяемых объектов, поскольку
внешнее состояние вынесено.
? Шаги реализации
1. Разделите поля класса, который станет легковесом, на две
части:
? внутреннее состояние: значения этих полей одинаковы
для большого числа объектов.
? внешнее состояние (контекст): значения полей
уникальны для каждого объекта.
2. Оставьте поля внутреннего состояние в классе, но
убедитесь, что их значения неизменяемы. Эти поля должны
инициализироваться только через конструктор.
228 Структурные паттерны / Легковес
3. Превратите поля внешнего состояния в аргументы методов,
где эти поля использовались. Затем, удалите поля из класса.
4. Создайте фабрику, которая будет кешировать и повторно
отдавать уже созданные объекты. Клиент должен
запрашивать легковеса с определённым внутренним
состоянием из этой фабрики, а не создавать его напрямую.
5. Клиент должен хранить или вычислять значения внешнего
состояния (контекст) и передавать его в методы объекта
легковеса.
? Преимущества и недостатки
? Экономит оперативную память.
? Расходует процессорное время на поиск/вычисление
контекста.
? Усложняет код программы за счёт множества
дополнительных классов.
? Отношения с другими паттернами
• Компоновщик часто совмещают с Легковесом, чтобы
реализовать общие ветки дерева и сэкономить при этом
память.
229 Структурные паттерны / Легковес
• Легковес показывает, как создавать много мелких объектов,
а Фасад показывает, как создать один объект, который
отображает целую подсистему.
• Паттерн Легковес может напоминать Одиночку, если для
конкретной задачи у вас получилось уменьшить количество
объектов к одному. Но помните, что между паттернами есть
два кардинальных отличия:
1. В отличие от Одиночки, вы можете иметь множество
объектов-легковесов.
2. Объекты-легковесов должны быть неизменяемыми, тогда
как объект-одиночки допускает изменение своего
состояния.
230 Структурные паттерны / Легковес
ЗАМЕСТИТЕЛЬ
Также известен как: Proxy
Заместитель — это структурный паттерн проектирования,
который позволяет подставлять вместо реальных объектов
специальные объекты-заменители. Эти объекты
перехватывают вызовы к оригинальному объекту, позволяя
сделать что-то до или после передачи вызова оригиналу.
231 Структурные паттерны / Заместитель
? Проблема
Для чего вообще контролировать доступ к объектам?
Рассмотрим такой пример: у вас есть внешний
ресурсоёмкий объект, который нужен не все время, а
изредка.
Запросы к базе данных могут быть очень медленными.
Мы могли бы не создавать этот объект в самом начале
программы, а только когда он кому-то реально
понадобится. Каждый клиент объекта получил бы некий код
отложенной инициализации. Но, вероятно, это привело бы к
множественному дублированию кода. В идеале, этот
хотелось бы поместить прямо в служебный класс, но это не
всегда возможно. Например, код класса может находиться в
закрытой сторонней библиотеке.
? Решение
Паттерн заместитель предлагает создать новый классдублёр, имеющий тот же интерфейс, что и оригинальный
служебный объект. При получении запроса от клиента,
232 Структурные паттерны / Заместитель
объект-заместитель сам бы создавал экземпляр служебного
объекта и переадресовывал бы ему всю реальную работу.
Заместитель «притворяется» базой данных, ускоряя работу за счёт ленивой
инициализации и кеширования повторяющихся запросов.
Но в чём же здесь польза? Вы могли бы поместить в класс
заместителя какую-то промежуточную логику, которая
выполнялась бы до (или после) вызовов этих же методов в
настоящем объекте. А благодаря одинаковому интерфейсу,
объект заместитель можно передать в любой код,
ожидающий сервисный объект.
? Аналогия из жизни
Банковским чеком можно расплачиваться, как и наличностью.
233 Структурные паттерны / Заместитель
Банковский чек — это заместитель пачки наличности. И чек,
и наличность имеют общий интерфейс — ими можно
оплачивать товары. Для покупателя польза в том, что не
надо таскать с собой тонны наличности. А владелец
магазина может превратить чек в зелёные бумажки,
обратившись в банк.
? Структура
234 Структурные паттерны / Заместитель
1. Интерфейс сервиса определяет общий интерфейс для
cервиса и заместителя. Благодаря этому, объект заместителя
можно использовать там, где ожидается объект сервиса.
2. Сервис содержит полезную бизнес-логику.
3. Заместитель хранит ссылку на объект сервиса. После того
как заместитель заканчивает свою работу (например,
инициализацию, логирование, защиту или другое), он
передаёт вызовы вложенному сервису.
Заместитель может сам отвечать за создание и удаление
объекта сервиса.
4. Клиент работает с объектами через интерфейс сервиса.
Благодаря этому, его можно «одурачить», подменив объект
сервиса объектом заместителя.
? Псевдокод
В этом примере Заместитель помогает добавить в
программу механизм ленивой инициализации и
кеширования тяжёлой служебной библиотеки интеграции с
Youtube.
235 Структурные паттерны / Заместитель
Пример кеширования результатов работы реального сервиса с
помощью заместителя.
Оригинальный объект начинал загрузку по сети, даже если
пользователь запрашивал одно и то же видео. Заместитель
же, загружает видео только один раз, используя для этого
служебный объект, но в остальных случаях, возвращает
закешированный файл.
1 // Интерфейс удалённого сервиса.
2 interface ThirdPartyYoutubeLib is
3 method listVideos()
4 method getVideoInfo(id)
5 method downloadVideo(id)
6
236 Структурные паттерны / Заместитель
7 // Конкретная реализация сервиса. Методы этого класса
8 // запрашивают у ютуба различную информацию. Скорость
9 // запроса зависит от интернет-канала пользователя и
10 // состояния самого ютуба. Чем больше будет вызовов к
11 // сервису, тем менее отзывчивой будет программа.
12 class ThirdPartyYoutubeClass is
13 method listVideos() is
14 // Получить список видеороликов с помощью API Youtube.
15
16 method getVideoInfo(id) is
17 // Получить детальную информацию о каком-то видеоролике.
18
19 method downloadVideo(id) is
20 // Скачать видео с Youtube.
21
22 // С другой стороны, можно кешировать запросы к ютубу и не
23 // повторять их какое-то время, пока кеш не устареет. Но
24 // внести этот код напрямую в сервисный класс нельзя, так
25 // как он находится в сторонней библиотеке. Поэтому мы
26 // поместим логику кеширования в отдельный класс-обёртку. Он
27 // будет делегировать запросы к сервисному объекту, только
28 // если нужно непосредственно выслать запрос.
29 class CachedYoutubeClass implements ThirdPartyYoutubeLib is
30 private field service: ThirdPartyYoutubeClass
31 private field listCache, videoCache
32 field needReset
33
34 constructor CachedYoutubeClass(service: ThirdPartyYoutubeLib) is
35 this.service = service
36
37 method listVideos() is
38 if (listCache == null || needReset)
39 listCache = service.listVideos()
40 return listCache
237 Структурные паттерны / Заместитель
41
42 method getVideoInfo(id) is
43 if (videoCache == null || needReset)
44 videoCache = service.getVideoInfo(id)
45 return videoCache
46
47 method downloadVideo(id) is
48 if (!downloadExists(id) || needReset)
49 service.downloadVideo(id)
50
51 // Класс GUI, который использует сервисный объект. Вместо
52 // реального сервиса, мы подсунем ему объект-заместитель.
53 // Клиент ничего не заметит, так как заместитель имеет тот
54 // же интерфейс, что и сервис.
55 class YoutubeManager is
56 protected field service: ThirdPartyYoutubeLib
57
58 constructor YoutubeManager(service: ThirdPartyYoutubeLib) is
59 this.service = service
60
61 method renderVideoPage() is
62 info = service.getVideoInfo()
63 // Отобразить страницу видеоролика.
64
65 method renderListPanel() is
66 list = service.listVideos()
67 // Отобразить список превьюшек видеороликов.
68
69 method reactOnUserInput() is
70 renderVideoPage()
71 renderListPanel()
72
73 // Конфигурационная часть приложения создаёт и передаёт
74 // клиентам объект заместителя.
238 Структурные паттерны / Заместитель
? Применимость
? Ленивая инициализация (виртуальный прокси). Когда у вас
есть тяжёлый объект, грузящий данные из файловой
системы или базы данных.
? Вместо того чтобы грузить данные сразу после старта
программы, можно сэкономить ресурсы и создать объект
тогда, когда он действительно понадобится.
? Защита доступа (защищающий прокси). Когда в программе
есть разные типы пользователей и вам хочется защищать
объект от неавторизованного доступа. Например, если
ваши объекты — это важная часть операционной системы,
а пользователи — сторонние программы (хорошие или
вредоносные).
? Прокси может проверять доступ при каждом вызове и
передавать выполнение служебному объекту, если доступ
разрешён.
75 class Application is
76 method init() is
77 youtubeService = new ThirdPartyYoutubeClass()
78 youtubeProxy = new CachedYoutubeClass(youtubeService)
79 manager = new YoutubeManager(youtubeProxy)
80 manager.reactOnUserInput()
239 Структурные паттерны / Заместитель
? Локальный запуск сервиса (удалённый прокси). Когда
настоящий сервисный объект находится на удалённом
сервере.
? В этом случае заместитель транслирует запросы клиента в
вызовы по сети, в протоколе, понятном удалённому
сервису.
? Логирование запросов (логирующий прокси). Когда
требуется хранить историю обращений к сервисному
объекту.
? Заместитель может сохранять историю обращения клиента
к сервисному объекту.
? Кеширование объектов («умная» ссылка). Когда нужно
кешировать результаты запросов клиентов и управлять их
жизненным циклом.
? Заместитель может подсчитывать количество ссылок на
сервисный объект, которые были отданы клиенту и остаются
активными. Когда все ссылки освобождаются — можно
будет освободить и сам сервисный объект (например,
закрыть подключение к базе данных).
Кроме того, Заместитель может отслеживать, не менял ли
клиент сервисный объект. Это позволит использовать
240 Структурные паттерны / Заместитель
объекты повторно и здoрово экономить ресурсы, особенно
если речь идёт о больших прожорливых сервисах.
? Шаги реализации
1. Определите интерфейс, который бы сделал заместитель и
оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку
на сервисный объект. Чаще всего, сервисный объект
создаётся самим заместителем. В редких случаях,
заместитель получает готовый сервисный объект от клиента
через конструктор.
3. Реализуйте методы заместителя в зависимости от его
предназначения. В большинстве случаев, проделав какуюто полезную работу, методы заместителя должны передать
запрос сервисному объекту.
4. Подумайте о введении фабрики, которая решала бы какой
из объектов создавать — заместитель или реальный
сервисный объект. Но с другой стороны, эта логика может
быть помещена в создающий метод самого заместителя.
5. Подумайте, не реализовать ли вам ленивую
инициализацию сервисного объекта при первом
обращении клиента к методам заместителя.
241 Структурные паттерны / Заместитель
? Преимущества и недостатки
? Позволяет контролировать сервисный объект незаметно
для клиента.
? Может работать, даже если сервисный объект ещё не
создан.
? Может контролировать жизненный цикл служебного
объекта.
? Усложняет программу за счёт дополнительных классов.
? Увеличивает время отклика от сервиса.
? Отношения с другими паттернами
• Адаптер предоставляет классу альтернативный интерфейс.
Декоратор предоставляет расширенный интерфейс.
Заместитель предоставляет тот же интерфейс.
• Фасад похож на Заместитель тем, что замещает сложную
подсистему и может сам её инициализировать. Но в
отличие от Фасада, Заместитель имеет тот же интерфейс,
что его служебный объект, благодаря чему их можно
взаимозаменять.
• Декоратор и Заместитель имеют похожие структуры, но
разные назначения. Они похожи тем, что оба построены на
композиции и делегировании работы другому объекту.
242 Структурные паттерны / Заместитель
Паттерны отличаются тем, что Заместитель сам управляет
жизнью сервисного объекта, а обёртывание Декораторов
контролируется клиентом.
243 Структурные паттерны / Заместитель
Поведенческие
паттерны
Эти паттерны решают задачи эффективного и безопасного
взаимодействия между объектами программы.
Цепочка
обязанностей
Chain of Responsibility
Позволяет передавать запросы последовательно по цепочке
обработчиков. Каждый последующий обработчик решает,
может ли он обработать запрос сам и стоит ли передавать
запрос дальше по цепи.
Команда
Command
Превращает запросы в объекты, позволяя передавать их как
аргументы при вызове методов, ставить запросы в очередь,
логировать их, а также поддерживать отмену операций.
244 Поведенческие паттерны
Итератор
Iterator
Даёт возможность последовательно обходить элементы
составных объектов, не раскрывая их внутреннего
представления.
Посредник
Mediator
Позволяет уменьшить связанность множества классов между
собой, благодаря перемещению этих связей в один класспосредник.
Снимок
Memento
Позволяет делать снимки состояния объектов, не раскрывая
подробностей их реализации. Затем снимки можно
использовать, чтобы восстановить прошлое состояние
объектов.
245 Поведенческие паттерны
Наблюдатель
Observer
Создаёт механизм подписки, позволяющий одним объектам
следить и реагировать на события, происходящие в других
объектах.
Состояние
State
Позволяет объектам менять поведение в зависимости от своего
состояния. Извне создаётся впечатление, что изменился класс
объекта.
Стратегия
Strategy
Определяет семейство схожих алгоритмов и помещает каждый
из них в собственный класс. После чего, алгоритмы можно
взаимозаменять прямо во время исполнения программы.
246 Поведенческие паттерны
Шаблонный
метод
Template method
Определяет скелет алгоритма, перекладывая ответственность
за некоторые его шаги на подклассы. Паттерн позволяет
подклассам переопределять шаги алгоритма, не меняя его
общей структуры.
Посетитель
Visitor
Позволяет создавать новые операции, не меняя классы
объектов, над которыми эти операции могут выполняться.
247 Поведенческие паттерны
ЦЕПОЧКА
ОБЯЗАННОСТЕЙ
Также известен как: CoR, Chain of Command, Chain of Responsibility
Цепочка обязанностей — это поведенческий паттерн
проектирования, который позволяет передавать запросы
последовательно по цепочке обработчиков. Каждый
последующий обработчик решает, может ли он обработать
запрос сам и стоит ли передавать запрос дальше по цепи.
248 Поведенческие паттерны / Цепочка обязанностей
? Проблема
Представьте, что вы делаете систему приёма онлайн
заказов. Вы хотите ограничить к ней доступ так, чтобы
только авторизованные пользователи могли создавать
заказы. Кроме того, определённые пользователи,
владеющие правами администратора, должны иметь
полный доступ к заказам.
Вы быстро сообразили, что эти проверки нужно выполнять
последовательно. Ведь «залогинить» пользователя можно в
любой момент, если только запрос содержит логин и
пароль. Но если аутентификация не удалась, то проверять
права доступа не имеет смысла.
Запрос проходит ряд проверок перед доступом в систему заказов.
На протяжении следующих нескольких месяцев вам
пришлось добавить ещё несколько таких последовательных
проверок.
249 Поведенческие паттерны / Цепочка обязанностей
• Кто-то резонно заметил, что неплохо бы проверять данные
передаваемые в запросе, перед тем как вносить их в
систему — вдруг запрос содержит покупку несуществующих
продуктов.
• Кто-то предложил фильтровать массовые отправки формы с
одним и тем же логином, чтобы предотвратить подбор
паролей ботами.
• Кто-то заметил, что форму заказа неплохо бы доставать из
кеша, если она уже была однажды показана.
Со временем код проверок становится всё более запутанным.
С каждой новой фичей код проверок, выглядящий как
большой клубок условных операторов, всё больше и
больше раздувался. При изменении одного правила,
приходилось трогать код всех проверок. А для того, чтобы
250 Поведенческие паттерны / Цепочка обязанностей
применить проверки к другим ресурсам, пришлось
продублировать их код в других классах.
Поддерживать такой код стало очень хлопотно, да и
затратно. И вот в один прекрасный день вы получаете
задачу рефакторинга...
? Решение
Как и многие другие поведенческие паттерны, Цепочка
обязанностей базируется на том, чтобы превратить
отдельные поведения в объекты. В нашем случае, каждая
проверка переедет в отдельный класс с единственным
методом выполнения. Данные запроса, над которым
происходит проверка, будут передаваться в метод как
аргументы.
А теперь по-настоящему важный этап. Паттерн предлагает
выстроить несколько обработчиков в цепь. Каждый
обработчик будет хранить ссылку на следующий
обработчик в цепи. А при получении запроса, он не только
обработает его, но и передаст следующему объекту.
Таким образом, можно сформировать длинную цепочку
обработчиков и передавать запрос в первый из них, зная о
том, что вся цепочка сможет его обработать в
определённом порядке.
251 Поведенческие паттерны / Цепочка обязанностей
И последний штрих. Обработчик необязательно должен
передавать запрос дальше. Причём эта особенность может
быть использована по-разному.
В примере с фильтрацией доступа, обработчики прерывают
дальнейшие проверки, если текущая проверка не прошла.
Ведь нет смысла тратить попусту ресурсы, если и так
понятно, что с запросом что-то не так.
Обработчики следуют в цепочке один за другим.
Но есть и другой подход, при котором обработчики
прерывают цепь только когда они могут обработать запрос.
В этом случае запрос движется по цепи, пока не найдётся
обработчик, могущий его обработать. Очень часто такой
подход используется для передачи событий в классах
графического интерфейса.
Например, когда пользователь кликает по кнопке,
выстраивается цепочка из самой кнопки, и всех её
родительских элементов, заканчивающаяся окном всего
приложения. Событие клика передаётся по этой цепи до тех
пор, пока не найдётся объект, способный его обработать.
Этот пример примечателен ещё и тем, что цепочку всегда
можно выделить из древовидной структуры объектов.
252 Поведенческие паттерны / Цепочка обязанностей
Цепочку можно выделить даже из дерева объектов.
Очень важно, чтобы все объекты цепочки имели общий
интерфейс. Это сделает связку объектов гибкой и позволит
формировать её на лету из разнообразных объектов, не
привязываясь к конкретным классам. Каждому
конкретному обработчику будет важно знать только то, что
следующий объект в цепи имеет метод выполнить .
? Аналогия из жизни
Вы купили новую видеокарту. Она автоматически
определилась и заработала под Windows, но в вашей
любимой Ubuntu «завести» её не удалось. Со слабой
надеждой, вы звоните в службу поддержки.
Первым вы слышите голос автоответчика, предлагающий
выбор из десятка стандартных решений. Ни один из
253 Поведенческие паттерны / Цепочка обязанностей
вариантов не подходит, и робот соединяет вас с живым
оператором.
Пример общения с поддержкой.
Увы, но рядовой оператор поддержки умеет общаться
только заученными фразами и давать шаблонные ответы.
После очередного предложения «выключить и включить
компьютер», вы просите связать вас с настоящими
инженерами.
Оператор перебрасывает звонок дежурному инженеру,
изнывающему от скуки в своей каморке. Уж он-то знает, как
вам помочь! Инженер рассказывает, где и как вы можете
скачать подходящие драйвера, и как настроить их под
Ubuntu. Запрос удовлетворён. Вы кладёте трубку.
254 Поведенческие паттерны / Цепочка обязанностей
? Структура
1. Обработчик определяет общий для всех конкретных
обработчиков интерфейс. Обычно, достаточно описать
единственный метод обработки запросов, но иногда здесь
может быть определён и метод выставления следующего
обработчика.
255 Поведенческие паттерны / Цепочка обязанностей
2. Базовый обработчик — опциональный класс, который
позволяет избавиться от дублирования одного и того же
кода во всех конкретных обработчиках.
Обычно, этот класс имеет поле для хранения ссылки на
следующий обработчик в цепочке. Клиент связывает
обработчики в цепь, подавая ссылку на следующий
обработчик в конструктор или сеттер, определённый здесь.
Здесь можно реализовать и метод обработки, который бы
просто перенаправлял запрос следующему объекту,
проверив его наличие.
3. Конкретные обработчики содержат код обработки
запросов. При получении запроса каждый обработчик
решает, может ли он обработать запрос или нет, а также
стоит ли передать его следующему объекту.
В большинстве случаев, обработчики могут работать сами
по себе и быть неизменяемыми, получив все нужные
детали из параметров конструктора.
4. Клиент составляет цепочки обработчиков один раз или
динамически, в зависимости от логики программы. Клиент
может отправить запрос любому из объектов цепочки,
причём это не всегда первый объект в цепочке.
256 Поведенческие паттерны / Цепочка обязанностей
? Псевдокод
В этом примере Цепочка обязанностей отвечает за показ
контекстной помощи для активных элементов
пользовательского интерфейса.
257 Поведенческие паттерны / Цепочка обязанностей
Классы UI построены с помощью компоновщика, но каждый элемент «знает» о
своём контейнере. Цепочку можно выстроить, пройдясь по всем контейнерам, в
которые вложен элемент.
Графический интерфейс приложения обычно
структурирован в виде дерева компонентов. Класс Диалог
— это корень дерева, отображающий всё окно приложения.
Диалог содержит Панели , которые, в свою очередь, могут
содержать либо другие вложенные панели, либо простые
компоненты вроде Кнопок .
Простые Компоненты могут показывать небольшие
подсказки, если к ним привязан текст помощи. Но есть и
более сложные компоненты, для которых этот способ
слишком прост. Они определяют собственный способ
отображения помощи.
Пример вызова контекстной помощи в цепочке объектов UI.
Когда пользователь наводит указатель мыши на компонент
и жмёт клавишу F1 , приложение берёт компонент под
курсором и шлёт ему запрос на показ помощи. Запрос
путешествует по всем родителям компонента, пока не
находится компонент, способный показать помощь.
258 Поведенческие паттерны / Цепочка обязанностей
1 // Интерфейс обработчиков.
2 interface ComponentWithContextualHelp is
3 method showHelp() is
4
5
6 // Базовый класс простых компонентов.
7 abstract class Component implements ContextualHelp is
8 field tooltipText: string
9
10 // Контейнер, содержащий компонент, служит в качестве
11 // следующего звена цепочки.
12 protected field container: Container
13
14 // Компонент показывает всплывающую подсказку, если
15 // задан текст подсказки. В обратном случае, он
16 // перенаправляет запрос контейнеру, если
17 // тот существует.
18 method showHelp() is
19 if (tooltipText != null)
20 // Показать подсказку.
21 else
22 container.showHelp()
23
24
25 // Контейнеры могут включать в себя как простые компоненты,
26 // так и другие контейнеры. Здесь формируются связи цепочки.
27 // Класс унаследует метод showHelp от своего родителя.
28 abstract class Container extends Component is
29 protected field children: array of Component
30
31 method add(child) is
32 children.add(child)
33 child.container = this
34
259 Поведенческие паттерны / Цепочка обязанностей
35 // Примитивные компоненты может устраивать поведение помощи
36 // по умолчанию...
37 class Button extends Component is
38 // ...
39
40 // Но сложные компоненты могут переопределять метод помощь
41 // по-своему. Но если помощь не может быть предоставлена,
42 // компонент вызовет базовую реализацию (см.
43 // класс Component)
44 class Panel extends Container is
45 field modalHelpText: string
46
47 method showHelp() is
48 if (modalHelpText != null)
49 // Показать модальное окно с помощью.
50 else
51 super.showHelp()
52
53 // ...то же, что и выше...
54 class Dialog extends Container is
55 field wikiPageURL: string
56
57 method showHelp() is
58 if (wikiPageURL != null)
59 // Открыть страницу Wiki в браузере.
60 else
61 super.showHelp()
62
63
64 // Клиентский код.
65 class Application is
66 // Каждое приложение конфигурирует цепочку по-своему.
67 method createUI() is
68 dialog = new Dialog("Budget Reports")
260 Поведенческие паттерны / Цепочка обязанностей
? Применимость
? Когда программа содержит несколько объектов, способных
обработать тот или иной запрос, однако заранее
неизвестно какой запрос придёт и какой обработчик
понадобится.
? Вы связываете потенциальных обработчиков в одну цепь и
поочерёдно спрашиваете, хочет ли данный объект
обработать запрос. Если нет, двигаетесь дальше по цепочке.
? Когда важно, чтобы обработчики выполнялись один за
другим в строгом порядке.
69 dialog.wikiPage = "http://..."
70 panel = new Panel(0, 0, 400, 800)
71 panel.modalHelpText = "This panel does..."
72 ok = new Button(250, 760, 50, 20, "OK")
73 ok.tooltipText = "This is a OK button that..."
74 cancel = new Button(320, 760, 50, 20, "Cancel")
75 // ...
76 panel.add(ok)
77 panel.add(cancel)
78 dialog.add(panel)
79
80 // Представьте что здесь произойдёт.
81 method onF1KeyPress() is
82 component = this.getComponentAtMouseCoords()
83 component.showHelp()
261 Поведенческие паттерны / Цепочка обязанностей
? Цепочка обязанностей позволяет запускать обработчики
последовательно один за другим в определённом порядке.
? Когда набор объектов, способных обработать запрос,
должен задаваться динамически.
? В любой момент вы можете вмешаться в существующую
цепочку и переназначить связи так, чтобы убрать или
добавить новое звено.
? Шаги реализации
1. Создайте интерфейс обработчика и опишите в нём
основной метод обработки.
Продумайте, в каком виде клиент должен передавать
данные запроса в обработчик. Самый гибкий способ —
превратить данные запроса в объект и передавать его
целиком через параметры метода обработчика.
2. Имеет смысл создать абстрактный базовый класс
обработчиков, чтобы не дублировать реализацию метода
получения следующего обработчика во всех конкретных
обработчиках.
Добавьте в базовый обработчик поле для хранения ссылки
на следующий объект цепочки. Устанавливайте начальное
значение этого поля через конструктор. Это сделает
262 Поведенческие паттерны / Цепочка обязанностей
объекты обработчиков неизменяемыми. Но если программа
предполагает динамическую перестройку цепочек, можете
добавить и сеттер для поля.
Реализуйте здесь метод обработки так, чтобы он
перенаправлял запрос следующему объекту, проверив его
наличие. Это позволит полностью скрыть поле-ссылку от
подклассов, дав им возможность передавать запросы
дальше по цепи, обратившись к родительской реализации
метода.
3. Один за другим создайте классы конкретных обработчиков
и реализуйте в них методы обработки запросов. При
получении запроса каждый обработчик должен решить:
? Может он обработать запрос или нет?
? Следует передать запрос следующему обработчику или
нет?
4. Клиент может собирать цепочку обработчиков
самостоятельно, опираясь на свою бизнес-логику, либо
получать уже готовые цепочки извне. В последнем случае,
цепочки собирают фабричные объекты исходя из
конфигурации приложения или текущего окружения.
5. Клиент может посылать запросы любому обработчику в
цепи, а не только первому. Запрос будет передаваться по
цепочке пока какой-то обработчик не откажется передавать
его дальше, либо когда будет достигнут конец цепи.
263 Поведенческие паттерны / Цепочка обязанностей
6. Клиент должен знать о динамической природе цепочки и
быть готов к таким случаям:
? Цепочка может состоять из единственного объекта.
? Запросы могут не достигать конца цепи.
? Запросы могут достигать конца, оставаясь
необработанными.
? Преимущества и недостатки
? Уменьшает зависимость между клиентом и обработчиками.
? Реализует принцип единственной обязанности.
? Реализует принцип открытости/закрытости.
? Запрос может остаться никем не обработанным.
? Отношения с другими паттернами
• Цепочка обязанностей, Команда, Посредник и
Наблюдатель показывают различные способы работы
отправителей запросов с их получателями:
? Цепочка обязанностей передаёт запрос последовательно
через цепочку потенциальных получателей, ожидая, что
какой-то из них обработает запрос.
264 Поведенческие паттерны / Цепочка обязанностей
? Команда устанавливает косвенную одностороннюю связь
от отправителей к получателям.
? Посредник убирает прямую связь между отправителями и
получателями, заставляя их общаться опосредованно,
через себя.
? Наблюдатель передаёт запрос одновременно всем
заинтересованным получателям, но позволяет им
динамически подписывать или отписываться от таких
оповещений.
• Цепочку обязанностей часто используют вместе с
Компоновщиком. В этом случае, запрос передаётся от
дочерних компонентов к их родителям.
• Обработчики в Цепочке обязанностей могут быть
выполнены в виде Команд. В этом случае множество
разных операций может быть выполнено над одним и тем
же контекстом, коим является запрос.
Но есть и другой подход, в котором сам запрос является
Командой, посланной по цепочке объектов. В этом случае
одна и та же операция может быть выполнена над
множеством разных контекстов, представленных в виде
цепочки.
• Цепочка обязанностей и Декоратор имеют очень похожие
структуры. Оба паттерна базируются на принципе
265 Поведенческие паттерны / Цепочка обязанностей
рекурсивного выполнения операции через серию
связанных объектов. Но есть и несколько важных отличий.
Обработчики в Цепочке обязанностей могут выполнять
произвольные действия, независимые друг от друга, а
также в любой момент прерывать дальнейшую передачу по
цепочке. С другой стороны Декораторы расширяют какоето определённое действие, не ломая интерфейс базовой
операции и не прерывая выполнение остальных
декораторов.
266 Поведенческие паттерны / Цепочка обязанностей
КОМАНДА
Также известен как: Действие, Транзакция, Command
Команда — это поведенческий паттерн проектирования,
который превращает запросы в объекты, позволяя
передавать их как аргументы при вызове методов, ставить
запросы в очередь, логировать их, а также поддерживать
отмену операций.
267 Поведенческие паттерны / Команда
? Проблема
Представьте, что вы работаете над программой текстового
редактора. Дело как раз подошло к разработке панели
управления. Вы создали класс красивых Кнопок и хотите
использовать его для всех кнопок приложения начиная от
панели управления, заканчивая простыми кнопками в
диалогах.
Все кнопки приложения унаследованы от одного класса.
Все эти кнопки, хоть и выглядят схоже, но делают разные
вещи. Поэтому возникает вопрос: куда поместить код
обработчиков кликов по этим кнопкам. Самим простым
решением было создать подклассы для каждой кнопки и
переопределить в них метод действия под разные задачи.
268 Поведенческие паттерны / Команда
Множество подклассов кнопок.
Но скоро стало понятно, что такой подход никуда не
годится. Во-первых, получается очень много подклассов.
Во-вторых, код кнопок, относящийся к графическому
интерфейсу, начинает зависеть от классов бизнес-логики,
которая довольно часто меняется.
Несколько классов дублирует одну и ту же функциональность.
Но самое обидное ещё впереди. Ведь некоторые операции,
например «сохранить», можно вызывать из нескольких мест
— нажав кнопку на панели управления, вызвав контекстное
меню или просто нажав клавиши Ctrl+S . Когда в
программе были только кнопки, код сохранения имелся
только в подклассе SaveButton . Но теперь его придётся
сдублировать ещё в два класса.
269 Поведенческие паттерны / Команда
? Решение
Хорошие программы обычно структурированы в виде
слоёв. Самый распространённый пример — слои
интерфейса и бизнес-логики. Первый всего лишь рисует
красивую картинку для пользователя. Но когда нужно
сделать что-то важное, интерфейс «просит» слой бизнеслогики заняться этим.
В реальности это выглядит так: один из объектов
интерфейса напрямую вызывает метод одного из объектов
бизнес-логики, передавая в него какие-то параметры.
Прямой доступ из UI в бизнес-логику.
Паттерн Команда предлагает не отправлять такие вызовы
напрямую, а «завернуть» их в отдельные объекты с
единственным методом, который приводит вызов в
действие.
270 Поведенческие паттерны / Команда
Доступ из UI в бизнес-логику через команду.
Параметры, с которыми должен быть вызван метод объекта
получателя, можно загодя сохранить в полях объектакоманды. Благодаря этому, объекты, отправляющие
запросы, могут не беспокоиться о том, чтобы собрать
необходимые для получателя данные. Более того, они
теперь вообще не знают, кто будет получателем запроса.
Вся эта информация скрыта внутри команды.
Классы команд можно объединить под общим
интерфейсом, c единственным методом запуска команды.
После этого одни и те же отправители смогут работать с
различными командами, не привязываясь к их классам.
Даже больше, команды можно будет взаимозаменять на
лету, изменяя итоговое поведение отправителей.
После применения Команды в нашем примере с текстовым
редактором, вам больше не потребуется создавать уйму
подклассов кнопок под разные действия.
271 Поведенческие паттерны / Команда
Классы UI делегируют работу командам.
Будет достаточно единственного класса с полем для
хранения объекта команды.
Объекты кнопок, используя общий интерфейс команд, будут
по факту ссылаться на разные объекты команд и
делегировать им работу при нажатии. А конкретные
команды будут перенаправлять вызовы тем или иным
объектам бизнес-логики.
Так же можно поступить и с контекстным меню, и с
горячими клавишами. Они будут привязаны к тем же
объектам команд, что и кнопки, избавляя классы от
дублирования.
Таким образом, команды станут настраиваемой прослойкой
между объектами пользовательского интерфейса и бизнеслогики. И это лишь малая доля пользы, которую может
принести паттерн Команда!
272 Поведенческие паттерны / Команда
? Аналогия из жизни
Пример заказа в ресторане.
Вы заходите в ресторан и садитесь у окна. К вам подходит
вежливый официант и принимает заказ, записывая все
пожелания в блокнот.
Откланявшись, он уходит на кухню, где вырывает лист из
блокнота и клеит на стену. Сорвав лист со стены, шеф
читает содержимое заказа и готовит блюдо, которое вы
заказали.
В этом примере, вы являетесь отправителем, официант с
блокнотом — командой, а шеф — получателем. Как и в
паттерне, вы не соприкасаетесь напрямую с шефом. Вместо
этого, вы отправляете заказ с официантом, который
самостоятельно «настраивает» шефа на работу.
273 Поведенческие паттерны / Команда
? Структура
1. Отправитель хранит ссылку на объект команды и
обращается к нему, когда нужно выполнить какое-то
действие. Отправитель работает с командами только через
их общий интерфейс. Он не знает, какую конкретно
команду использует, так как получает готовый объект
команды от клиента.
2. Команда описывает общий для всех конкретных команд
интерфейс. Обычно, здесь описан всего один метод для
запуска команды.
3. Конкретные команды реализуют различные запросы,
следуя общему интерфейсу команд. Обычно, команда не
делает всю работу самостоятельно, а лишь передаёт вызов
получателю — определённому объекту бизнес-логики.
274 Поведенческие паттерны / Команда
Параметры, с которыми команда обращается к получателю,
следует хранить в виде полей. В большинстве случаев,
объекты команд можно сделать неизменяемым, предавая в
них все необходимые параметры только через конструктор.
4. Получатель содержит бизнес-логику программы. В этой
роли может выступать практически любой объект. Обычно,
команды перенаправляют вызовы получателям. Но иногда,
чтобы упростить программу, вы можете избавиться от
получателей, слив их код в классы команд.
5. Клиент создаёт объекты конкретных команд, передавая в
них все необходимые параметры, а иногда и ссылки на
объекты получателей. После этого, клиент конфигурирует
отправителей созданными командами.
? Псевдокод
В этом примере паттерн Команда служит для ведения
истории выполненных операций, позволяя, отменять их,
если потребуется.
Команды, которые меняют состояние редактора (например,
команда вставки текста из буфера обмена), сохраняют
копию состояния редактора перед выполнением действия.
Копии выполненных команд помещаются в историю
команд, откуда они могут быть доставлены, если нужно
будет сделать отмену операции.
275 Поведенческие паттерны / Команда
Пример реализации отмены в текстовом редакторе.
Классы элементов интерфейса, истории команд и прочие не
зависят от конкретных классов команд, так как работают с
ними через общий интерфейс. Это позволяет добавлять в
приложение новые команды, не изменяя существующий
код.
1 // Абстрактная команда задаёт общий интерфейс для
2 // всех команд.
3 abstract class Command is
4 protected field app: Application
276 Поведенческие паттерны / Команда
5 protected field editor: Editor
6 protected field backup: text
7
8 constructor Command(app: Application, editor: Editor) is
9 this.app = app
10 this.editor = editor
11
12 // Сохраняем состояние редактора.
13 method saveBackup() is
14 backup = editor.text
15
16 // Восстанавливаем состояние редактора.
17 method undo() is
18 editor.text = backup
19
20 // Главный метод команды остаётся абстрактным, чтобы
21 // каждая конкретная команда определила его по-своему.
22 // Метод должен возвратить true или false, в зависимости
23 // о того, изменила ли команда состояние редактора, а
24 // значит, нужно ли её сохранить в истории.
25 abstract method execute()
26
27
28 // Конкретные команды.
29 class CopyCommand extends Command is
30 // Команда копирования не записывается в историю, так
31 // как она не меняет состояние редактора.
32 method execute() is
33 app.clipboard = editor.getSelection()
34 return false
35
36 class CutCommand extends Command is
37 // Команды, меняющие состояние редактора, сохраняют
38 // состояние редактора перед своим действием и
277 Поведенческие паттерны / Команда
39 // сигнализируют об изменении, возвращая true.
40 method execute() is
41 saveBackup()
42 app.clipboard = editor.getSelection()
43 editor.deleteSelection()
44 return true
45
46 class PasteCommand extends Command is
47 method execute() is
48 saveBackup()
49 editor.replaceSelection(app.clipboard)
50 return true
51
52 // Отмена это тоже команда.
53 class UndoCommand extends Command is
54 method execute() is
55 app.undo()
56 return false
57
58
59 // Глобальная история команд — это стек.
60 class CommandHistory is
61 private field history: array of Command
62
63 // Последний зашедший...
64 method push(c: Command) is
65 // Добавить команду в конец массива-истории.
66
67 // ...выходит первым.
68 method pop():Command is
69 // Достать последнюю команду из массива-истории.
70
71
72
278 Поведенческие паттерны / Команда
73 // Класс редактора содержит непосредственные операции над
74 // текстом. Он отыгрывает роль получателя – команды
75 // делегируют ему свои действия.
76 class Editor is
77 field text: string
78
79 method getSelection() is
80 // Вернуть выбранный текст.
81
82 method deleteSelection() is
83 // Удалить выбранный текст.
84
85 method replaceSelection(text) is
86 // Вставить текст из буфера обмена в текущей позиции.
87
88
89 // Класс приложения настраивает объекты для совместной
90 // работы. Он выступает в роли отправителя — создаёт
91 // команды, чтобы выполнить какие-то действия.
92 class Application is
93 field clipboard: string
94 field editors: array of Editors
95 field activeEditor: Editor
96 field history: CommandHistory
97
98 // Код, привязывающий команды к элементам интерфейса
99 // может выглядеть примерно так.
100 method createUI() is
101 // ...
102 copy = function() {executeCommand(
103 new CopyCommand(this, activeEditor)) }
104 copyButton.setCommand(copy)
105 shortcuts.onKeyPress("Ctrl+C", copy)
106
279 Поведенческие паттерны / Команда
107 cut = function() { executeCommand(
108 new CutCommand(this, activeEditor)) }
109 cutButton.setCommand(cut)
110 shortcuts.onKeyPress("Ctrl+X", cut)
111
112 paste = function() { executeCommand(
113 new PasteCommand(this, activeEditor)) }
114 pasteButton.setCommand(paste)
115 shortcuts.onKeyPress("Ctrl+V", paste)
116
117 undo = function() { executeCommand(
118 new UndoCommand(this, activeEditor)) }
119 undoButton.setCommand(undo)
120 shortcuts.onKeyPress("Ctrl+Z", undo)
121
122 // Запускаем команду и проверяем, надо ли добавить её
123 // в историю.
124 method executeCommand(command) is
125 if (command.execute)
126 history.push(command)
127
128 // Берём последнюю команду из истории и заставляем её
129 // все отменить. Мы не знаем конкретный тип команды, но
130 // это и не важно, так как каждая команда знает как
131 // отменить своё действие.
132 method undo() is
133 command = history.pop()
134 if (command != null)
135 command.undo()
280 Поведенческие паттерны / Команда
? Применимость
? Когда вы хотите параметризовать объекты выполняемым
действием.
? Команда превращает операции в объекты. А объекты
можно передавать, хранить и взаимозаменять внутри
других объектов.
Скажем, вы разрабатываете библиотеку графического меню
и хотите, чтобы пользователи могли использовать меню в
разных приложениях, не меняя каждый раз код ваших
классы. Применив паттерн, пользователям не придётся
изменять классы меню, вместо этого они будут
конфигурировать объекты меню различными командами.
? Когда вы хотите ставить операции в очередь, выполнять их
по расписанию или передавать по сети.
? Как и любые другие объекты, команды можно
сериализовать, то есть превратить в строку, чтобы потом
сохранить в файл или базу данных. Затем, в любой удобный
момент, её можно достать обратно, снова превратить в
объект команды, и выполнить. Таким же образом команды
можно передавать по сети, логировать или выполнять на
удалённом сервере.
? Когда вам нужна операция отмены.
281 Поведенческие паттерны / Команда
? Главная вещь, которая вам нужна, чтобы иметь возможность
отмены операций — это хранение истории. Среди многих
способов как это делается, паттерн Команда является,
пожалуй, самым популярным.
История команд выглядит как стек, в который попадают все
выполненные объекты команд. Каждая команда перед
выполнением операции сохраняет текущее состояния
объекта, с которым она будет работать. После выполнения
операции, копия команды попадает в стек истории, все ещё
неся в себе сохранённое состояние объекта. Если
потребуется отмена, программа возьмёт последнюю
команду из истории и возобновит сохранённое в ней
состояние.
Этот способ имеет две особенности. Во-первых, точное
состояние объектов не так-то просто сохранить, ведь часть
его может быть приватным. Но с этим может помочь
справиться паттерн Снимок.
Во-вторых, копии состояния могут занимать довольно
много оперативной памяти. Поэтому иногда можно
прибегнуть к альтернативной реализации, когда вместо
восстановления старого состояния, команда выполняет
обратное действие. Недостаток этого способа в сложности
(а иногда и невозможности) реализации обратного
действия.
282 Поведенческие паттерны / Команда
? Шаги реализации
1. Создайте общий интерфейс команд и определите в нём
метод запуска.
2. Один за другим создайте классы конкретных команд. В
каждом классе должно быть поле для хранения ссылки на
один или несколько объектов-получателей, которым
команда будет перенаправлять основную работу.
Кроме этого, команда должна иметь поля для хранения
параметров, которые нужны при вызове методов
получателя. Значения всех этих полей команда должна
получать через конструктор.
И наконец, реализуйте основной метод команды, вызывая в
нём те или иные методы получателя.
3. Добавьте в классы отправителей поля для хранения
команд. Объект-отправитель должен принимать готовый
объект команды извне через конструктор, либо через
сеттер команды.
4. Измените основной код отправителей так, чтобы они
делегировали выполнение действия команде.
5. Порядок инициализации объектов должен выглядеть так:
? Создаём объекты получателей.
283 Поведенческие паттерны / Команда
? Создаём объекты команд, связав их с получателями.
? Создаём объекты отправителей, связав их с командами.
? Преимущества и недостатки
? Убирает прямую зависимость между объектами,
вызывающими операции и объектами, которые их
непосредственно выполняют.
? Позволяет реализовать простую отмену и повтор операций.
? Позволяет реализовать отложенный запуск команд.
? Позволяет собирать сложные команды из простых.
? Реализует принцип открытости/закрытости.
? Усложняет код программы за счёт дополнительных классов.
? Отношения с другими паттернами
• Цепочка обязанностей, Команда, Посредник и
Наблюдатель показывают различные способы работы
отправителей запросов с их получателями:
? Цепочка обязанностей передаёт запрос последовательно
через цепочку потенциальных получателей, ожидая, что
какой-то из них обработает запрос.
284 Поведенческие паттерны / Команда
? Команда устанавливает косвенную одностороннюю связь
от отправителей к получателям.
? Посредник убирает прямую связь между отправителями и
получателями, заставляя их общаться опосредованно,
через себя.
? Наблюдатель передаёт запрос одновременно всем
заинтересованным получателям, но позволяет им
динамически подписывать или отписываться от таких
оповещений.
• Обработчики в Цепочке обязанностей могут быть
выполнены в виде Команд. В этом случае множество
разных операций может быть выполнено над одним и тем
же контекстом, коим является запрос.
Но есть и другой подход, в котором сам запрос является
Командой, посланной по цепочке объектов. В этом случае
одна и та же операция может быть выполнена над
множеством разных контекстов, представленных в виде
цепочки.
• Команду и Снимок можно использовать сообща для
реализации отмены операций. В этом случае объекты
команд будут отображать выполненные действие над
объектом, снимки — хранить копию состояния этого объекта
до того, как команда была выполнена.
285 Поведенческие паттерны / Команда
• Команда и Стратегия похожи по духу, но отличаются
масштабом и применением:
? Команду используют, чтобы превратить любые
разнородные действия в объекты. Параметры операции
превращаются в поля объекта. Этот объект теперь можно
логировать, хранить в истории для отмены, передавать
во внешние сервисы и так далее.
? С другой стороны, Стратегия описывает разные способы
сделать одно и то же действие, позволяя взаимозаменять
эти способы в каком-то объекте контекста.
• Если Команду нужно копировать перед вставкой в историю
выполненных команд, вам может помочь Прототип.
• Посетитель можно рассматривать как расширенный аналог
Команды, который способен работать сразу с несколькими
видами получателей.
286 Поведенческие паттерны / Команда
ИТЕРАТОР
Также известен как: Iterator
Итератор — это поведенческий паттерн проектирования,
который даёт возможность последовательно обходить
элементы составных объектов, не раскрывая их
внутреннего представления.
287 Поведенческие паттерны / Итератор
? Проблема
Коллекции — самая частая структура данных, которую вы
можете встретить в программировании. Это набор
объектов, собранный в одну кучу по каким-то причинам.
Разные типы коллекций.
Большинство коллекций выглядят как обычный список
элементов. Но есть и экзотические коллекции, построенные
на основе деревьев, графов и других сложных структур
данных.
Но как бы ни была структурирована коллекция,
пользователь должен иметь возможность последовательно
обходить её элементы, чтобы проделывать с ними какие-то
действия.
Но каким способом следует перемещаться по сложной
структуре данных? Например, сегодня может быть
достаточным обход дерева в глубину. Но завтра
потребуется возможность перемещаться по дереву в
ширину. А на следующей неделе, и того хуже, понадобится
обход коллекции в случайном порядке.
288 Поведенческие паттерны / Итератор
Одну и ту же коллекцию можно обходить разными способами.
Добавляя всё новые алгоритмы в код коллекции, вы
понемногу размываете её основную, которой является
эффективное хранение данных. Некоторые алгоритмы
могут быть и вовсе слишком заточены под определённое
приложение и смотреться дико в общем классе коллекции.
? Решение
Идея паттерна Итератор в том, чтобы вынести поведение
обхода коллекции из самой коллекции в отдельный класс.
Объект итератор будет отслеживать состояние обхода,
текущую позицию в коллекции и сколько элементов ещё
осталось обойти. Одну и ту же коллекцию смогут
одновременно обходить различные итераторы, а сама
коллекция не будет даже знать об этом.
289 Поведенческие паттерны / Итератор
Итераторы содержат код обхода коллекции. Одну коллецию могут обходить
сразу несколько итераторов.
К тому же, если вам понадобится добавить новый способ
обхода, вы создадите новый класс итератора, не изменяя
существующий код коллекции.
290 Поведенческие паттерны / Итератор
? Аналогия из жизни
Варианты прогулок по Риму.
Вы планируете полететь в Рим и обойти все
достопримечательности за пару дней. Но приехав, вы
можете долго петлять узкими улочками, пытаясь найти
Колизей. Если у вас ограниченный бюджет — не беда. Вы
можете воспользоваться виртуальным гидом, скачанным на
телефон, который позволит отфильтровать только
интересные вам точки. А можете плюнуть и нанять
локального гида, который хоть и обойдётся в копеечку, но
знает город как свои пять пальцев и сможет посвятить вас
во все городские легенды.
Таким образом, Рим выступает коллекцией
достопримечательностей, а ваш мозг, навигатор или гид —
итератором по коллекции. Вы, как клиентский код, можете
выбрать один из итераторов, опираясь на решаемую задачу
и доступные ресурсы.
291 Поведенческие паттерны / Итератор
? Структура
1. Итератор описывает интерфейс для доступа и обхода
элементов коллекции.
2. Конкретный итератор реализует алгоритм обхода какой-то
конкретной коллекции. Объект итератора должен сам
отслеживать текущую позицию при обходе коллекции,
чтобы отдельные итераторы могли обходить одну и ту же
коллекцию независимо.
3. Коллекция описывает интерфейс получения итератора из
коллекции. Как мы уже говорили, коллекции не всегда
являются списком. Это может быть и база данных, и
удалённое API, и даже дерево Компоновщика. Поэтому
292 Поведенческие паттерны / Итератор
сама коллекция может создавать итераторы, так как она
знает, какие именно итераторы могут с ней работать.
4. Конкретная коллекция возвращает новый экземпляр
определённого конкретного итератора, связав его с
текущим объектом коллекции. Обратите внимание, что
сигнатура метода возвращает интерфейс итератора. Это
позволяет клиенту не зависеть от конкретных классов
итераторов.
5. Клиент работает со всеми объектами через интерфейсы
коллекции и итератора. Так клиентский код не зависит от
конкретного класса итератора, что позволяет применять
различные итераторы, не изменяя существующий код
программы.
В общем случае клиенты не создают объекты итераторов, а
получают их из коллекций. Тем не менее, если клиенту
требуется специальный итератор, он всегда может создать
его самостоятельно.
? Псевдокод
В этом примере паттерн Итератор используется для
реализации обхода нестандартной коллекции, которая
инкапсулирует доступ к социальному графу Facebook.
Коллекция предоставляет несколько итераторов, которые
могут по-разному обходить профиля людей.
293 Поведенческие паттерны / Итератор
Пример обхода социальных профилей через итератор.
Так, итератор друзей перебирает всех друзей профиля, а
итератор коллег — фильтрует друзей по принадлежности к
компании профиля. Все итераторы реализуют общий
интерфейс, который позволяет клиентам работать с
профилями, не вникая в детали работы с социальной сетью
(например, авторизацию, отправку REST-запросов и т.д.)
Кроме того, Итератор избавляет код от привязки к
конкретным классам коллекций. Это позволяет добавить
294 Поведенческие паттерны / Итератор
поддержку другого вида коллекций (например, LinkedIn), не
меняя клиентский код, который работает с итераторами и
коллекциями.
1 // Общий интерфейс коллекций должен определить фабричный
2 // метод для производства итератора. Можно определить сразу
3 // несколько методов, чтобы дать пользователям различные
4 // варианты обхода одной и той же коллекции.
5 interface SocialNetwork is
6 method createFriendsIterator(profileId): ProfileIterator
7 method createCoworkersIterator(profileId): ProfileIterator
8
9
10 // Конкретная коллекция знает объекты каких итераторов
11 // нужно создавать.
12 class Facebook implements SocialNetwork is
13 // ... Основной код коллекции ...
14
15 // Код получения нужного итератора.
16 method createFriendsIterator(profileId) is
17 return new FacebookIterator(this, profileId, "friends")
18 method createCoworkersIterator(profileId) is
19 return new FacebookIterator(this, profileId, "coworkers")
20
21
22 // Общий интерфейс итераторов.
23 interface ProfileIterator is
24 method getNext(): Profile
25 method hasMore(): bool
26
27
28 // Конкретный итератор.
29 class FacebookIterator implements ProfileIterator is
295 Поведенческие паттерны / Итератор
30 // Итератору нужна ссылка на коллекцию, которую
31 // он обходит.
32 private field facebook: Facebook
33 private field profileId, type: string
34
35 // Но каждый итератор обходит коллекцию независимо от
36 // остальных, поэтому он содержит информацию о текущей
37 // позиции обхода.
38 private field currentPosition
39 private field cache: array of Profile
40
41 constructor FacebookIterator(facebook, profileId, type) is
42 this.facebook = network
43 this.profileId = profileId
44 this.type = type
45
46 private method lazyInit() is
47 if (cache == null)
48 cache = facebook.sendSophisticatedSocialGraphRequest(profileId,
49
50 // Итератор реализует методы базового
51 // интерфейса по-своему.
52 method getNext() is
53 if (hasMore())
54 currentPosition++
55 return cache[currentPosition]
56
57 method hasMore() is
58 lazyInit()
59 return cache.length < currentPosition
60
61
62
63
296 Поведенческие паттерны / Итератор
64 // Вот ещё полезная тактика: мы можем передавать объект
65 // итератора вместо коллекции в клиентские классы. При таком
66 // подходе, клиентский код не будет иметь доступа к
67 // коллекциям, а значит его не будет волновать подробности
68 // их реализаций. Ему будет доступен только общий
69 // интерфейс итераторов.
70 class SocialSpammer is
71 method send(iterator: ProfileIterator, message: string) is
72 while (iterator.hasNext())
73 profile = iterator.getNext()
74 System.sendEmail(profile.getEmail(), message)
75
76
77 // Класс приложение конфигурирует классы как захочет.
78 class Application is
79 field network: SocialNetwork
80 field spammer: SocialSpammer
81
82 method config() is
83 if working with Facebook
84 this.network = new Facebook()
85 if working with LinkedIn
86 this.network = new LinkedIn()
87 this.spammer = new SocialSpammer()
88
89 method sendSpamToFriends(profile) is
90 iterator = network.createFriendsIterator(profile.getId())
91 spammer.send(iterator, "Very important message")
92
93 method sendSpamToCoworkers(profile) is
94 iterator = network.createCoworkersIterator(profile.getId())
95 spammer.send(iterator, "Very important message")
297 Поведенческие паттерны / Итератор
? Применимость
? Когда у вас есть сложная структура данных, и вы хотите
скрыть от клиента детали её реализации (из-за сложности
или вопросов безопасности).
? Итератор предоставляет клиенту всего несколько простых
методов перебора элементов коллекции. Это не только
упрощает доступ к коллекции, но и защищает её данные от
неосторожных или злоумышленных действий.
? Когда вам нужно иметь несколько вариантов обхода одной
и той же структуры данных.
? Нетривиальные алгоритмы обхода структуры данных могут
иметь довольно объёмный код. Этот код будет захламлять
всё вокруг, если поместить его в класс коллекции или где-то
посреди основной бизнес-логики программы. Применив
итератор, вы можете переместить код обхода структуры
данных в собственный класс, упростив поддержку
остального кода.
? Когда вам хочется иметь единый интерфейс обхода
различных структур данных.
? Итератор позволяет вынести реализации различных
вариантов обхода в подклассы. Это позволит легко
298 Поведенческие паттерны / Итератор
взаимозаменять объекты итераторов, в зависимости от того,
с какой структурой данных приходится работать.
? Шаги реализации
1. Создайте интерфейс итераторов. В качестве минимума, вам
понадобится операция получения следующего элемента. Но
для удобства можно предусмотреть и другие методы,
например, для получения предыдущего элемента, текущей
позиции, проверки окончания обхода и прочих.
2. Создайте интерфейс коллекции и опишите в нём метод
получения итератора. Важно, чтобы его сигнатура
возвращала общий интерфейс итераторов, а не один из
конкретных итераторов.
3. Создайте классы конкретных итераторов для тех
коллекций, которые нужно обходить с помощью паттерна.
Итератор должен быть привязан только к одному объекту
коллекции. Обычно эта связь устанавливается через
конструктор.
4. Реализуйте методы получения итератора в конкретных
классах коллекций. Они должны создавать новый итератор
того класса, который способен работать с данным типом
коллекции. Коллекция должна передавать собственную
ссылку в созданный итератор.
299 Поведенческие паттерны / Итератор
5. В клиентском коде и в классах коллекций не должно
остаться кода обхода элементов. Клиент должен получать
новый итератор из объекта коллекции каждый раз, когда
ему нужно перебрать её элементы.
? Преимущества и недостатки
? Упрощает классы хранения данных.
? Позволяет реализовать различные способы обхода
структуры данных.
? Позволяет одновременно перемещаться по структуре
данных в разные стороны.
? Неоправдан, если можно обойтись простым циклом.
? Отношения с другими паттернами
• Вы можете обходить дерево Компоновщика, используя
Итератор.
• Фабричный метод можно использовать вместе с
Итератором, чтобы подклассы коллекций могли создавать
подходящие им итераторы.
300 Поведенческие паттерны / Итератор
• Снимок можно использовать вместе с Итератором, чтобы
сохранить текущее состояние обхода структуры данных и
вернуться к нему в будущем, если потребуется.
• Посетитель можно использовать совместно с Итератором.
Итератор будет отвечать за обход структуры данных, а
Посетитель — за выполнение действий над каждым её
компонентом.
301 Поведенческие паттерны / Итератор
ПОСРЕДНИК
Также известен как: Intermediary, Controller, Mediator
Посредник — это поведенческий паттерн проектирования,
который позволяет уменьшить связанность множества
классов между собой, благодаря перемещению этих связей
в один класс-посредник.
302 Поведенческие паттерны / Посредник
? Проблема
Предположим, что у вас есть диалог создания профиля
пользователя. Он состоит из всевозможных элементов
управления — текстовых полей, чекбоксов, кнопок.
Беспорядочные связи между элементами пользовательского интерфейса.
Отдельные элементы окна должны взаимодействовать друг
с другом. Так, например, чекбокс «у меня есть собака»
открывает скрытые поле для ввода имени домашнего
любимца, а клик по кнопке отправки запускает проверку
значений всех полей формы.
Код элементов нужно трогать при измении каждого диалога.
303 Поведенческие паттерны / Посредник
Прописав эту логику прямо в коде элементов управления,
вы поставите крест на их повторном использовании в
других окнах приложения. Они станут слишком тесно
связаны с остальными компонентами, которые не нужны в
других контекстах. Поэтому вы сможете использовать либо
все компоненты сразу, либо никаких вообще.
? Решение
Паттерн Посредник заставляет объекты общаться не
напрямую друг с другом, а через отдельный объектпосредник, который знает, кому нужно перенаправить тот
или иной запрос. Благодаря этому, компоненты системы
будут зависеть только от посредника, а не от десятков
других компонентов.
Элементы интерфейса общаются через посредника.
В нашем примере посредником мог бы стать диалог. Скорее
всего, класс диалога и так знает, из каких компонентов
304 Поведенческие паттерны / Посредник
состоит. Поэтому никаких новых связей добавлять в него не
придётся.
Основные изменения произойдут внутри отдельных
компонентов диалога. Если раньше при получении клика от
пользователя, объект кнопки сам проверял значения полей
диалога, то теперь его единственной обязанностью будет
сообщить диалогу о том, что произошёл клик. Получив
извещение, диалог выполнит все необходимые проверки
полей. Таким образом, вместо нескольких зависимостей от
остальных элементов, кнопка получит только одну — от
самого диалога.
Чтобы сделать код ещё гибче, можно выделить общий
интерфейс для всех посредников, то есть диалогов
программы. Наша кнопка станет зависимой не от
конкретного диалога создания пользователя, а от
абстрактного, что позволит использовать её и в других
диалогах.
Таким образом, посредник скрывает в себе все сложные
связи и зависимости между классами отдельных
компонентов программы. А чем меньше связей имеют
классы, тем проще их изменять, расширять и повторно
использовать.
305 Поведенческие паттерны / Посредник
? Аналогия из жизни
Самолёты общаются не напрямую, а через диспетчера.
Пилоты садящихся или улетающих самолётов не общаются
напрямую с другими пилотами. Вместо этого, они
связываются с диспетчером, который координирует
действия нескольких самолётов одновременно. Без
диспетчера, пилотам приходилось бы все время быть
начеку и следить за всеми окружающими самолётами
самостоятельно. А это приводило бы к частым катастрофам
в небе.
Важно понимать, что диспетчер не нужен во время всего
полёта. Он задействован только в зоне аэропорта, когда
нужно координировать взаимодействие многих самолётов.
306 Поведенческие паттерны / Посредник
? Структура
1. Компоненты — это разнородные объекты, содержащие
бизнес-логику программы. Каждый компонент хранит
ссылку на объект посредника, но работает с ним только
через абстрактный интерфейс посредников. Благодаря
этому, компоненты можно повторно использовать в другой
программе, связав их с посредником другого типа.
2. Посредник определяет интерфейс для обмена
информацией с компонентами. Обычно хватает одного
метода для оповещения посредника о событиях,
произошедших в компонентах. В параметрах этого метода
307 Поведенческие паттерны / Посредник
можно передавать детали события: ссылку на компонент, в
котором оно произошло, и любые другие данные.
3. Конкретный посредник содержит код взаимодействия
нескольких компонентов между собой. Этот объект создаёт
и хранит ссылки на компоненты системы.
4. Компоненты не должны общаться напрямую друг с другом.
Если в компоненте происходит важное событие, влияющее
на других, он должен оповестить своего посредника. А тот,
в свою очередь, самостоятельно передаст вызов другим
компонентам, если это потребуется. При этом компонентотправитель не знает, кто обработает его запрос, а
компонент-получатель не знает, кто его прислал.
? Псевдокод
В этом примере Посредник помогает избавиться от
зависимостей между классами различных элементов UI —
кнопками, чекбоксами и надписями.
По реакции на действия пользователей, элементы не
взаимодействуют напрямую, а всего лишь уведомляют
посредника о том, что они изменились.
308 Поведенческие паттерны / Посредник
Пример структурирования классов UI-диалогов.
Посредник, в виде диалога авторизации, знает о том, как
конкретные элементы должны взаимодействовать. Поэтому
при получении уведомлений он может перенаправить
вызов тому или иному элементу.
1 // Общий интерфейс посредников.
2 interface Mediator is
3 method notify(sender: Component, event: string)
4
5 // Конкретныи? посредник. Все связи между конкретными
6 // компонентами переехали в код посредника. Он получает
7 // извещения от своих компонентов и знает как на
8 // них реагировать.
309 Поведенческие паттерны / Посредник
9 class AuthenticationDialog implements Mediator is
10 private field title: string
11 private field loginOrRegisterChkBx: Checkbox
12 private field loginUsername, loginPassword: Textbox
13 private field registrationUsername, registrationPassword
14 private field registrationEmail: Textbox
15 private field okBtn, cancelBtn: Button
16
17 constructor AuthenticationDialog() is
18 // Здесь нужно создать объекты всх компонентов, подав
19 // текущий объект-псоредник в их конструктор.
20
21 // Когда что-то случается с компонентом, он шлёт
22 // посреднику оповещение. После получения извещения,
23 // посредник может либо сделать что-то самостоятельно,
24 // либо перенаправить запрос другому компоненту.
25 method notify(sender, event) is
26 if (sender == loginOrRegisterChkBx and event == "check")
27 if (loginOrRegisterChkBx.checked)
28 title = "Log in"
29 // 1. Показать компоненты формы входа.
30 // 2. Скрыть компоненты формы регистрации.
31 else
32 title = "Register"
33 // 1. Показать компоненты формы регистрации.
34 // 2. Скрыть компоненты формы входа.
35
36 if (sender == okBtn && event == "click")
37 if (loginOrRegister.checked)
38 // Попробовать найти пользователя с данными из
39 // формы логина.
40 if (!found)
41 // Показать ошибку над формой логина.
42 else
310 Поведенческие паттерны / Посредник
43 // 1. Создать пользовательский аккаунт с данными
44 // из формы регистрации.
45 // 2. Авторизировать этого пользователя.
46 // ...
47
48
49 // Классы компонентов общаются с посредниками через их общий
50 // интерфейс. Благодаря этому, одни и те же компоненты можно
51 // использовать в разных посредниках.
52 class Component is
53 field dialog: Mediator
54
55 constructor Component(dialog) is
56 this.dialog = dialog
57
58 method click() is
59 dialog.notify(this, "click")
60
61 method keypress() is
62 dialog.notify(this, "keypress")
63
64 // Конкретные компоненты никак не связаны между собой. У них
65 // есть только один канал общения – через отправку
66 // уведомлений посреднику.
67 class Button extends Component is
68 // ...
69
70 class Textbox extends Component is
71 // ...
72
73 class Checkbox extends Component is
74 method check() is
75 dialog.notify(this, "check")
76 // ...
311 Поведенческие паттерны / Посредник
? Применимость
? Когда вам сложно менять некоторые классы из-за
множества хаотичных связей с другими классами.
? Посредник позволяет поместить все эти связи в один класс.
После чего вам будет легче их отрефакторить, сделать
более понятными и гибкими.
? Когда вы не можете повторно использовать класс,
поскольку он зависит от уймы других классов.
? После применения паттерна, компоненты теряют прежние
связи с другими компонентами. А всё их общение
происходит косвенно, через посредника.
? Когда вам приходится создавать множество подклассов
компонентов, чтобы использовать одни и те же
компоненты в разных контекстах.
? Если раньше изменение отношений в одном компоненте
могли повлечь за собой снежный ком изменений в каждом
другом компоненте, то теперь вам достаточно создать
подкласс посредника и поменять в нём связи между
компонентами.
312 Поведенческие паттерны / Посредник
? Шаги реализации
1. Найдите группу тесно переплетённых классов, отвязав
которые друг от друга, можно получить некоторую пользу.
Например, чтобы повторно использовать их код в другой
программе.
2. Создайте общий интерфейс Посредников и опишите в нём
методы для взаимодействия с Компонентами. В
простейшем случае достаточно одного метода для
получения оповещений от компонентов.
Этот интерфейс необходим, если вы хотите повторно
использовать классы компонентов для других задач. В этом
случае, всё, что нужно сделать — это создать новый класс
конкретного посредника.
3. Реализуйте этот интерфейс в классе Конкретного
посредника. Поместите в него поля, которые будут
содержать ссылки на все объекты компонентов.
4. Вы можете пойти дальше и переместить код создания
компонентов в класс Конкретного посредника, превратив
его в фабрику.
5. Компоненты тоже должны иметь ссылку на объект
посредника. Связь между ними удобней всего установить,
подавая посредника в параметры конструктора
компонентов.
313 Поведенческие паттерны / Посредник
6. Измените код компонентов так, чтобы они вызывали метод
оповещения посредника, а не методы других компонентов.
С другой стороны, посредник должен вызывать методы
нужного компонента, когда получает оповещение.
? Преимущества и недостатки
? Устраняет зависимости между компонентами, позволяя
повторно их использовать.
? Упрощает взаимодействие между компонентами.
? Централизует управление в одном месте.
? Посредник может сильно раздуться.
? Отношения с другими паттернами
• Цепочка обязанностей, Команда, Посредник и
Наблюдатель показывают различные способы работы
отправителей запросов с их получателями:
? Цепочка обязанностей передаёт запрос последовательно
через цепочку потенциальных получателей, ожидая, что
какой-то из них обработает запрос.
? Команда устанавливает косвенную одностороннюю связь
от отправителей к получателям.
314 Поведенческие паттерны / Посредник
? Посредник убирает прямую связь между отправителями и
получателями, заставляя их общаться опосредованно,
через себя.
? Наблюдатель передаёт запрос одновременно всем
заинтересованным получателям, но позволяет им
динамически подписывать или отписываться от таких
оповещений.
• Посредник и Фасад похожи тем, что пытаются организовать
работу множества существующих классов.
? Фасад создаёт упрощённый интерфейс к подсистеме, не
внося в неё никакой добавочной функциональности.
Сама подсистема не знает о существовании Фасада.
Классы подсистемы общаются друг с другом напрямую.
? Посредник централизует общение между компонентами
системы. Компоненты системы знают только о
существовании Посредника, у них нет прямого доступа к
другим компонентам.
• Разница между Посредником и Наблюдателем не всегда
очевидна. Чаще всего они выступают как конкуренты, но
иногда могут работать вместе.
Цель Посредника — убрать обоюдные зависимости между
компонентами системы. Вместо этого они становятся
зависимыми от самого посредника. С другой стороны, цель
315 Поведенческие паттерны / Посредник
Наблюдателя — обеспечить динамическую одностороннюю
связь, в которой одни объекты косвенно зависят от других.
Довольно популярна реализация Посредника при помощи
Наблюдателя. При этом объект посредника будет выступать
издателем, а все остальные компоненты станут
подписчиками и смогут динамически следить за событиями,
происходящими в посреднике. В этом случае трудно понять,
чем же отличаются оба паттерна.
Но Посредник имеет и другие реализации, когда отдельные
компоненты жёстко привязаны к объекту посредника. Такой
код вряд ли будет напоминать Наблюдателя, но всё же
останется Посредником.
Напротив, в случае реализации посредника с помощью
Наблюдателя, представим такую программу, в которой
каждый компонент системы становится издателем.
Компоненты могут подписываться друг на друга, в то же
время, не привязываясь к конкретным классам. Программа
будет состоять из целой сети Наблюдателей, не имея
центрального объекта Посредника.
316 Поведенческие паттерны / Посредник
СНИМОК
Также известен как: Хранитель, Memento
Снимок — это поведенческий паттерн проектирования,
который позволяет делать снимки состояния объектов, не
раскрывая подробностей их реализации. Затем снимки
можно использовать, чтобы восстановить прошлое
состояние объектов.
317 Поведенческие паттерны / Снимок
? Проблема
Предположим, что вы пишете текстовый редактор. Помимо
обычного редактирования, ваш редактор позволяет менять
форматирование текста, вставлять картинки и прочее.
В какой-то момент вы решили сделать все эти действия
отменяемыми. Для этого вам нужно сохранять текущее
состояние редактора перед тем, как выполнить любое
действие. Если потом пользователь решит отменить своё
действие, вы достанете копию состояния из истории и
восстановите старое состояние редактора.
Перед выполнением команды, вы можете сохранить копию состояния
редактора, чтобы потом иметь возможность отменить операцию.
Чтобы сделать копию состояния объекта, достаточно
скопировать значение его полей. Таким образом, если вы
сделали класс редактора достаточно открытым, то любой
другой класс сможет заглянуть внутрь, чтобы скопировать
его состояние.
318 Поведенческие паттерны / Снимок
Казалось бы, что ещё нужно? Ведь теперь любая операция
сможет сделать резервную копию редактора перед своим
действием. Но такой наивный подход обеспечит вам уйму
проблем в будущем. Ведь если вы решите провести
рефакторинг — убрать или добавить парочку полей в класс
редактора — то придётся изменять код всех классов,
которые могли копировать состояние редактора.
Как команде создать снимок состояния редактора, если все его
поля приватные?
Но это ещё не все. Давайте теперь рассмотрим сами копии
состояния. Из чего состоит состояние редактора? Даже
самые примитивные редакторы требуют нескольких полей
для хранения текущего открытого текста, позиции курсора
и прокрутки экрана. Чтобы сделать копию состояния, вам
нужно записать значения всех этих полей в некий
«контейнер».
Скорее всего, вам понадобится хранить массу таких
«контейнеров», поэтому удобней всего сделать их
319 Поведенческие паттерны / Снимок
объектами одного класса. Этот класс должен иметь массу
полей и практически никаких методов. Чтобы другие
классы смогли записывать и читать из него данные, вам
придётся сделать его поля публичными. Но это приведёт к
той же проблеме, что и с открытым классом редактора.
Другие классы станут зависимыми от любых изменений в
классе редактора.
Получается, нам придётся либо открывать классы для всех
желающих, испытывая массу хлопот с поддержкой кода,
либо делать классы закрытыми, но отказаться от идеи
отмены операций. Нет ли какого-то другого пути?
? Решение
Все проблемы, описанные выше, возникают из-за
нарушения инкапсуляции. Это когда одни объекты пытаются
сделать работу за других, влезая в их приватную зону,
чтобы собрать необходимые для операции данные.
Паттерн Снимок поручает создание копии состояния
объекта самому объекту, который этим состоянием владеет.
Вместо того чтобы делать снимок «извне», наш редактор
сам сделает копию своих полей — ведь ему доступны все
поля, даже приватные.
Паттерн предлагает держать копию состояния в
специальном объекте «снимке» с ограниченным
320 Поведенческие паттерны / Снимок
интерфейсом, позволяющим, например, узнать дату
изготовления или название снимка. Но с другой стороны,
снимок должен быть открыт для своего «создателя»,
позволяя прочесть и восстановить его внутреннее
состояние.
Снимок полностью открыт для создателя, но лишь частично открыт
для опекунов.
Эта схема позволяет создателям производить снимки и
отдавать их для хранения другим объектам, называемым
«опекунами». Опекунам будет доступен только
ограниченный интерфейс снимка, поэтому они никак не
смогут повлиять на внутренности самого снимка. В нужный
момент, опекун может попросить создателя восстановить
своё состояние, передав в него соответствующий снимок.
321 Поведенческие паттерны / Снимок
В нашем примере с редактором, опекуном можно сделать
отдельный класс, который будет хранить список
выполненных операций. Ограниченный интерфейс снимков
позволит демонстрировать пользователю красивый список
с названиями и датами выполненных операций. А когда
пользователь решит откатить операцию, класс истории
возьмёт последний снимок из стека и отправит его в
редактор для восстановления.
? Структура
Классическая реализация на вложенных классах
Классическая реализация паттерна полагается на механизм
вложенных классов, которые доступны только в некоторых
языках программирования (C++, C#, Java).
322 Поведенческие паттерны / Снимок
1. Создатель делает снимки своего состояния по запросу, а
также воспроизводит прошлое состояние, если подать в
него готовый снимок.
2. Снимок — это простой объект данных, содержащий
состояние создателя. Надёжней всего сделать объекты
снимков неизменяемыми и передавать в них состояние
только через конструктор.
3. Опекун должен знать, когда делать снимок создателя и
когда его нужно восстанавливать.
Опекун может хранить историю прошлых состояний
создателя в виде стека из снимков. Если понадобится
сделать отмену, он возьмёт последний снимок и передаст
его создателю для восстановления.
4. В этой реализации снимок — это внутренний класс по
отношению к классу создателя, поэтому тот имеет полный
доступ к его полям и методам, несмотря на то, что они
объявлены приватными. Опекун же не имеет доступа ни к
состоянию, ни к методам снимков и может всего лишь
хранить ссылки на эти объекты.
323 Поведенческие паттерны / Снимок
Реализация с промежуточным пустым интерфейсом
Подходит для языков, не имеющих механизма вложенных
классов (PHP).
1. В этой реализации создатель работает напрямую с
конкретным классом снимка, а опекун — только с его
ограниченным интерфейсом.
2. Благодаря этому достигается тот же эффект, что и в
классической реализации. Создатель имеет полный доступ
к снимку, а опекун — нет.
324 Поведенческие паттерны / Снимок
Снимки с повышенной защитой
Когда нужно полностью исключить доступ к состоянию
Создателей и Снимков.
1. Эта реализация разрешает иметь несколько видов
создателей и снимков. Каждому классу создателей
соответствует собственный класс снимков. Ни создатели, ни
снимки не позволяют прочесть их состояние.
2. Здесь опекун ещё более жёстко ограничен в доступе к
состоянию создателей и снимков. Но с другой стороны,
опекун становится независим от создателей, так как метод
восстановления теперь находится в самих снимках.
3. Снимки теперь связаны с теми создателями, из которых они
сделаны. Они по-прежнему получают состояние через
конструктор. Благодаря близкой связи между классами,
325 Поведенческие паттерны / Снимок
снимки знают, как восстановить состояние своих
создателей.
? Псевдокод
В этом примере паттерн Снимок используется совместно с
паттерном Команда и позволяет хранить резервные копии
сложного состояния текстового редактора и, если
потребуется, восстанавливать его.
Пример сохранения снимков состояния текстового редактора.
Объекты команд выступают в роли опекунов и запрашивают
снимки у редактора перед тем, как выполнить своё
действие. Если потребуется отмена операции, команда
сможет восстановить состояние редактора, используя
сохранённый снимок.
При этом снимок не имеет публичных полей, поэтому
никакой объект не сможет получить доступа его данным.
Снимки связаны с определённым редактором, которых их
создал и сам восстанавливает его состояние. Это позволяет
программе иметь одновременно несколько объектов
редакторов, например, разбитых по вкладкам.
326 Поведенческие паттерны / Снимок
1 // Класс создателя должен иметь специальный метод, который
2 // сохраняет состояние создателя в новом объекте-снимке.
3 class Editor is
4 private field text, curX, curY, selectionWidth
5
6 method setText(text) is
7 this.text = text
8
9 method setCursor(x, y) is
10 this.curX = curX
11 this.curY = curY
12
13 method setSelectionWidth(width) is
14 this.selectionWidth = width
15
16 method createSnapshot(): EditorState is
17 // Снимок — неизменяемый объект, поэтому Создатель
18 // передаёт все своё состояние через
19 // параметры конструктора.
20 return new Snapshot(this, text, curX, curY, selectionWidth)
21
22 // Снимок хранит прошлое состояние редактора.
23 class Snapshot is
24 private field editor: Editor
25 private field text, curX, curY, selectionWidth
26
27 constructor Snapshot(editor, text, curX, curY, selectionWidth) is
28 this.editor = editor
29 this.text = text
30 this.curX = curX
31 this.curY = curY
32 this.selectionWidth = selectionWidth
33
34 // В нужный момент, владелец снимка может восстановить
327 Поведенческие паттерны / Снимок
? Применимость
? Когда вам нужно сохранять мгновенныи? снимок состояния
объекта (или его части), чтобы впоследствии объект можно
было восстановить в том же состоянии.
? Паттерн Снимок позволяет делать любое количество
снимков объекта и хранить их независимо от объекта, с
которого делают снимок. Снимки часто используют не
35 // состояние редактора.
36 method restore() is
37 editor.setText(text)
38 editor.setCursor(curX, curY)
39 editor.setSelectionWidth(selectionWidth)
40
41 // Опекуном может выступать класс команд (см. паттерн
42 // Команда). В этом случае, команда сохраняет снимок
43 // получателя перед тем, как выполнить действие. А при
44 // отмене, возвращает получателя в предыдущее состояние.
45 class Command is
46 private field backup: Snapshot
47
48 method makeBackup() is
49 backup = editor.saveState()
50
51 method undo() is
52 if (backup != null)
53 backup.restore()
54 // ...
328 Поведенческие паттерны / Снимок
только для реализации операции отмены, но и для
транзакций, когда состояние объекта нужно откатить, если
операция не удалась.
? Когда прямое получение состояния объекта раскрывает
детали его реализации и нарушает инкапсуляцию.
? Паттерн предлагает изготовить снимок самому исходному
объекту, так как ему доступны все поля, даже приватные.
? Шаги реализации
1. Определите класс создателя, объекты которого должны
создавать снимки своего состояния.
2. Создайте класс снимка и опишите в нём все те же поля,
которые имеются в оригинальном классе-создателе.
3. Сделайте объекты снимков неизменяемыми. Они должны
получать начальные значения только один раз, через свой
конструктор.
4. Если ваш язык программирования это позволяет, сделайте
класс снимка вложенным в класс создателя.
Если нет, извлеките из класса снимка пустой интерфейс,
который будет доступен остальным объектам программы.
Впоследствии вы можете добавить некоторые
329 Поведенческие паттерны / Снимок
вспомогательные методы в этот интерфейс, дающие доступ
к метаданным снимка, однако прямой доступ к данным
создателя должен быть исключён.
5. Добавьте в класс создателя метод получения снимков.
Создатель должен создавать новые объекты снимков,
передавая значения своих полей через конструктор.
Сигнатура метода должна возвращать снимки через
ограниченный интерфейс, если он у вас есть. Сам класс
должен работать с конкретным классом снимка.
6. Добавьте в класс создателя метод восстановления из
снимка. Что касается привязки к типам, руководствуйтесь
той же логикой, что и в пункте 4.
7. Опекуны, будь то история операций, объекты команд или
нечто иное, должны знать о том, когда запрашивать снимки
у создателя, где их хранить, и когда восстанавливать.
8. Связь опекунов с создателями можно перенести внутрь
снимков. В этом случае каждый снимок будет привязан к
своему создателю и должен будет сам восстанавливать его
состояние. Но это будет работать либо если классы снимков
вложены в классы создателей, либо если создатели имеют
сеттеры для установки значений своих полей.
330 Поведенческие паттерны / Снимок
? Преимущества и недостатки
? Не нарушает инкапсуляции исходного объекта.
? Упрощает структуру исходного объекта. Ему не нужно
хранить историю версий своего состояния.
? Требует много памяти, если клиенты слишком часто
создают снимки.
? Может повлечь дополнительные издержки памяти, если
объекты, хранящие историю, не освобождают ресурсы,
занятые устаревшими снимками.
? В некоторых языках (например, PHP, Python, JavaScript)
сложно гарантировать, чтобы только исходный объект имел
доступ к состоянию снимка.
? Отношения с другими паттернами
• Команду и Снимок можно использовать сообща для
реализации отмены операций. В этом случае объекты
команд будут отображать выполненные действие над
объектом, снимки — хранить копию состояния этого объекта
до того, как команда была выполнена.
• Снимок можно использовать вместе с Итератором, чтобы
сохранить текущее состояние обхода структуры данных и
вернуться к нему в будущем, если потребуется.
331 Поведенческие паттерны / Снимок
• Снимок иногда можно заменить Прототипом, если объект,
чьё состояние требуется сохранять в истории, довольно
простой, не имеет активных ссылок на внешние ресурсы,
либо их можно легко восстановить.
332 Поведенческие паттерны / Снимок
НАБЛЮДАТЕЛЬ
Также известен как: Издатель-Подписчик, Слушатель, Observer
Наблюдатель — это поведенческий паттерн
проектирования, который создаёт механизм подписки,
позволяющий одним объектам следить и реагировать на
события, происходящие в других объектах.
333 Поведенческие паттерны / Наблюдатель
? Проблема
Представьте, что у вас есть два объекта: Покупатель и
Магазин . В магазин вот-вот должны завезти новый товар,
который интересен покупателю.
Покупатель может каждый день ходить в магазин, чтобы
проверить наличие товара. Но при этом он будет тратить
драгоценное время и злиться.
Постоянное посещение магазинга или спам?
С другой стороны, магазин может разослать спам каждому
своему покупателю. Многих это расстроит, так как товар
специфический и не всем он нужен.
Получается конфликт: либо один объект работает
неэффективно, тратя ресурсы на периодические проверки,
либо второй объект оповещает слишком широкий круг
пользователей, тоже тратя ресурсы впустую.
334 Поведенческие паттерны / Наблюдатель
? Решение
Давайте будем называть объекты, которые содержат
интересное состояние Издателями . А другие объекты,
которым интересно это состояние давайте
звать Подписчиками .
Паттерн Наблюдатель предлагает издателям хранить
список подписчиков, которым интересно наблюдать за их
состоянием. Причём, издатели не должны вести этот список
сами, а предоставить возможность самим подписчикам
вписывать себя в этот список или вычёркиваться оттуда.
Подписка на события.
Теперь самое интересное. Каждый раз, когда в издателе
будет происходить что-нибудь, он должен проходиться по
списку своих подписчиков и оповещать их, вызывая
определённый метод их объектов.
Для издателя не важно, какого конкретно подписчика он
оповещает, так как все подписчики договорились иметь
335 Поведенческие паттерны / Наблюдатель
один и тот же метод оповещения, то есть иметь общий
интерфейс.
Оповещения о событиях.
Увидев как складно всё работает, вы можете выделить
общий интерфейс и для всех издателей. Он получит методы
подписки и отписки. После этого подписчики смогут
однотипно работать с издателями, а также получать
оповещения от них через один и тот же метод.
336 Поведенческие паттерны / Наблюдатель
? Аналогия из жизни
Подписка на газеты и их доставка.
После того как вы оформили подписку на газету или
журнал, вам больше не нужно ездить в супермаркет и
проверять, не вышел ли очередной номер. Вместо этого,
издательство будет присылать новые номера сразу после
выхода прямо к вам домой.
Издательство ведёт список подписчиков и знает, кому какой
журнал слать. Вы можете в любой момент отказаться от
подписки, и журнал перестанет к вам приходить.
337 Поведенческие паттерны / Наблюдатель
? Структура
1. Издатель владеет внутренним состоянием, изменение
которого интересно для подписчиков. Он содержит
механизм подписки — список подписчиков, а также методы
подписки/отписки.
2. Когда внутреннее состояние издателя меняется, он
оповещает своих подписчиков. Для этого издатель
проходит по списку подписчиков и вызывает их метод
оповещения, заданный в интерфейсе подписчика.
3. Подписчик определяет интерфейс, которым пользуется
издатель для отправки оповещения. В большинстве
случаев, для этого достаточно единственного метода.
4. Конкретные подписчики выполняют что-то в ответ на
оповещение, пришедшее от издателя. Эти классы должны
338 Поведенческие паттерны / Наблюдатель
следовать общему интерфейсу подписчиков, чтобы
издатель не зависел от конкретных классов подписчиков.
5. По приходу оповещения, подписчику нужно получить
обновлённое состояние издателя. Издатель может передать
это состояние через параметры метода оповещения. Более
гибкий вариант — передавать через параметры весь объект
издателя, чтобы подписчик сам мог получить требуемые
данные. Как вариант, подписчик может постоянно хранить
ссылку на объект издателя, переданный ему в конструкторе.
6. Клиент создаёт объекты издателей и подписчиков, а затем
регистрирует подписчиков на обновления в издателях.
? Псевдокод
В этом примере Наблюдатель позволяет объекту текстового
редактора оповещать другие объекты об изменениях
своего состояния.
Список подписчиков составляется динамически, объекты
могут, как подписываться на определённые события, так и
отписываться от них прямо во время выполнения
программы.
В этой реализации, редактор не ведёт список подписчиков
сам, а делегирует это вложенному объекту. Это даёт
возможность использовать механизм подписки и в других
339 Поведенческие паттерны / Наблюдатель
объектах программы, а не только в классе редактора. Таким
образом, паттерн Наблюдатель позволяет динамически
настраивать обработчики тех или иных событий,
происходящих с объектом.
Пример оповещения объектов о событиях в других объектах.
Для добавления в программу новых подписчиков, не нужно
менять классы издателей, покуда они работают с
подписчиками через общий интерфейс.
340 Поведенческие паттерны / Наблюдатель
1 // Базовый класс-издатель. Содержит код управления
2 // подписчиками и их оповещения.
3 class EventManager is
4 private field listeners: hash map of event types and listeners
5
6 method subscribe(eventType, listener) is
7 listeners.add(eventType, listener)
8
9 method unsubscribe(eventType, listener) is
10 listeners.remove(eventType, listener)
11
12 method notify(eventType, data) is
13 foreach (listener in listeners.of(eventType)) do
14 listener.update(data)
15
16 // Конкретный класс издатель, содержащий интересную для
17 // других компонентов бизнес-логику. Мы могли бы сделать его
18 // прямым потомком EventManager, но в реальной жизни это не
19 // всегда возможно (например, если вы у класса уже есть
20 // родитель). Поэтому здесь мы подключаем механизм подписки
21 // при помощи композиции.
22 class Editor is
23 private field events: EventManager
24 private field file: File
25
26 constructor Editor() is
27 events = new EventManager()
28
29 // Методы бизнес-логики, которые оповещают подписчиков
30 // об изменениях.
31 method openFile(path) is
32 this.file = new File(path)
33 events.notify("open", file.name)
34
341 Поведенческие паттерны / Наблюдатель
35 method saveFile() is
36 file.write()
37 events.notify("save", file.name)
38 // ...
39
40
41 // Общий интерфейс подписчиков. Во многих языках, имеющих
42 // функциональный типы, можно обойтись без этого интерфейса
43 // и конкретных классов, заменив объекты подписчиков
44 // функциями.
45 interface EventListener is
46 method update(filename)
47
48 // Набор конкретных подписчиков. Они реализуют добавочную
49 // функциональность, реагируя на извещения от издателя.
50 class LoggingListener is
51 private field log: File
52 private field message
53
54 constructor LoggingListener(log_filename, message) is
55 this.log = new File(log_filename)
56 this.message = message
57
58 method update(filename) is
59 log.write(replace('%s',filename,message))
60
61 class EmailAlertsListener is
62 private field email: string
63
64 constructor EmailAlertsListener(email, message) is
65 this.email = email
66 this.message = message
67
68
342 Поведенческие паттерны / Наблюдатель
? Применимость
? Когда при изменении состояния одного объекта требуется
что-то сделать в других, но вы не знаете наперёд какие
именно объекты должны отреагировать.
? Эта задача может возникнуть при разработке GUIфреймворка, когда надо дать возможность сторонним
классам реагировать на клики по кнопкам.
69 method update(filename) is
70 system.email(email, replace('%s',filename,message))
71
72
73 // Приложение может сконфигурировать издателей и подписчиков
74 // как угодно, в зависимости от целей и конфигурации.
75 class Application is
76 method config() is
77 editor = new TextEditor()
78
79 logger = new LoggingListener(
80 "/path/to/log.txt",
81 "Someone has opened file: %s");
82 editor.events.subscribe("open", logger)
83
84 emailAlers = new EmailAlertsListener(
85 "admin@example.com",
86 "Someone has changed the file: %s")
87 editor.events.subscribe("save", emailAlers)
343 Поведенческие паттерны / Наблюдатель
Паттерн Наблюдатель даёт возможность любому объекту с
интерфейсом подписчика, подписываться на изменения в
объектах-издателях.
? Когда одни объекты должны наблюдать за другими, но
только в определённых случаях.
? Издатели ведут динамические списки. Все наблюдатели
могут подписываться или отписываться на обновления
прямо во время выполнения программы.
? Шаги реализации
1. Разбейте вашу функциональность на две части:
независимое ядро и опциональные зависимые части.
Независимое ядро станет издателем. Зависимые части
станут подписчиками.
2. Создайте интерфейс подписчиков. Обычно, в нём
достаточно определить единственный метод оповещения.
3. Создайте интерфейс издателей и опишите в нём операции
управления подпиской. Помните, что издатель должен
работать только с общим интерфейсом подписчиков.
4. Вам нужно решить, куда поместить код ведения подписки,
ведь он обычно бывает одинаков для всех типов издателей.
Самый очевидный способ — вынести этот код в
344 Поведенческие паттерны / Наблюдатель
промежуточный абстрактный класс, от которого будут
наследоваться все издатели.
Но если вы интегрируете паттерн в существующие классы,
то создать новый базовый класс может быть
затруднительно. В этом случае, вы можете поместить логику
подписки во вспомогательный объект и делегировать ему
работу из издателей.
5. Создайте классы конкретных издателей. Реализуйте их так,
чтобы при каждом изменении состояния, они слали
оповещения всем своим подписчикам.
6. Реализуйте метод оповещения в конкретных подписчиках.
Издатель может отправлять какие-то данные вместе с
оповещением (например, в параметрах). Возможен и
другой вариант, когда подписчик, получив оповещение, сам
берёт из объекта издателя нужные данные. Но при этом
подписчик привяжет себя к конкретному классу издателя.
7. Клиент должен создавать необходимое количество
объектов подписчиков и подписывать их у издателей.
? Преимущества и недостатки
? Издатель не зависит от конкретных классов подписчиков.
? Вы можете подписывать и отписывать получателей на лету.
345 Поведенческие паттерны / Наблюдатель
? Реализует принцип открытости/закрытости.
? Наблюдатели оповещаются в случайном порядке.
? Отношения с другими паттернами
• Цепочка обязанностей, Команда, Посредник и
Наблюдатель показывают различные способы работы
отправителей запросов с их получателями:
? Цепочка обязанностей передаёт запрос последовательно
через цепочку потенциальных получателей, ожидая, что
какой-то из них обработает запрос.
? Команда устанавливает косвенную одностороннюю связь
от отправителей к получателям.
? Посредник убирает прямую связь между отправителями и
получателями, заставляя их общаться опосредованно,
через себя.
? Наблюдатель передаёт запрос одновременно всем
заинтересованным получателям, но позволяет им
динамически подписывать или отписываться от таких
оповещений.
• Разница между Посредником и Наблюдателем не всегда
очевидна. Чаще всего они выступают как конкуренты, но
иногда могут работать вместе.
346 Поведенческие паттерны / Наблюдатель
Цель Посредника — убрать обоюдные зависимости между
компонентами системы. Вместо этого они становятся
зависимыми от самого посредника. С другой стороны, цель
Наблюдателя — обеспечить динамическую одностороннюю
связь, в которой одни объекты косвенно зависят от других.
Довольно популярна реализация Посредника при помощи
Наблюдателя. При этом объект посредника будет выступать
издателем, а все остальные компоненты станут
подписчиками и смогут динамически следить за событиями,
происходящими в посреднике. В этом случае трудно понять,
чем же отличаются оба паттерна.
Но Посредник имеет и другие реализации, когда отдельные
компоненты жёстко привязаны к объекту посредника. Такой
код вряд ли будет напоминать Наблюдателя, но всё же
останется Посредником.
Напротив, в случае реализации посредника с помощью
Наблюдателя, представим такую программу, в которой
каждый компонент системы становится издателем.
Компоненты могут подписываться друг на друга, в то же
время, не привязываясь к конкретным классам. Программа
будет состоять из целой сети Наблюдателей, не имея
центрального объекта Посредника.
347 Поведенческие паттерны / Наблюдатель
СОСТОЯНИЕ
Также известен как: State
Состояние — это поведенческий паттерн проектирования,
который позволяет объектам менять поведение в
зависимости от своего состояния. Извне создаётся
впечатление, что изменился класс объекта.
348 Поведенческие паттерны / Состояние
? Проблема
Паттерн Состояние невозможно рассматривать в отрыве от
концепции машины состояний (также известной как стейтмашина или конечный автомат).
Конечный автомат.
Основная идея в том, что программа может находиться в
одном из нескольких состояний, которые всё время
сменяют друг друга. Набор этих состояний, а также
переходов между ними предопределён и конечен. Находясь
в разных состояниях, программа может по-разному
реагировать на одни и те же события, которые происходят с
ней.
Такой подход может быть применён и к отдельным
объектам. Например, объект Документ может принимать
три состояния: Черновик , Модерация или Опубликован . В
349 Поведенческие паттерны / Состояние
каждом из них его метод опубликовать будет работать поразному:
• В первом случае, он отправит документ на модерацию.
• Во втором — отправит документ в публикацию, но при
условии, что это сделал администратор.
• А в последнем — и вовсе ничего не будет делать.
Возможные состояния страницы и переходы между ними.
Машину состояний чаще всего реализуют с помощью
множества условных операторов, if либо switch ,
которые проверяют текущее состояние объекта и
выполняют соответствующее поведение. Наверняка вы уже
реализовали хотя бы одну машину состояний в своей
350 Поведенческие паттерны / Состояние
жизни, даже не зная об этом. Как на счёт вот такого кода,
выглядит знакомо?
Основная проблема машины состояний построенной таким
образом проявится, если в Документ добавить ещё десяток
состояний. Каждый метод будет состоять из увесистого
условного оператора, перебирающего доступные состояния.
Такой код крайне сложно поддерживать, так как любое
изменение логики переходов влечёт за собой путешествие
по всем методам и их условным операторам в поисках
веток, которые изменились.
1 class Document
2 string state;
3 // ...
4 method publish() {
5 switch (state) {
6 "draft":
7 state = "moderation";
8 break;
9 "moderation":
10 if (currentUser.role == 'admin')
11 state = "published"
12 break;
13 "published":
14 // Do nothing.
15 }
16 }
17 // ...
351 Поведенческие паттерны / Состояние
Путаница и нагромождение условий особенно сильно
проявляется в старых проектах. Набор возможных
состояний бывает трудно предопределить заранее, поэтому
они всё время добавляются в процессе эволюции
программы. Таким образом, то, что выглядело простым и
эффективным в самом начале, может впоследствии стать
проекцией большого макаронного монстра.
? Решение
Паттерн Состояние предлагает создать отдельные классы
для каждого состояния, в котором может пребывать
контекстный объект, а затем вынести туда поведения,
соответствующие этим состоянию.
Страница делегирует выполнение своему активному состоянию.
352 Поведенческие паттерны / Состояние
Вместо того чтобы хранить код всех состояний,
первоначальный объект (называемый «контекстом») будет
содержать ссылку на один из объектов-состояний и
делегировать ему работу, зависящую от состояния.
Благодаря тому, что состояния будут иметь общий
интерфейс, контекст сможет делегировать работу
состоянию, не привязываясь к его классу. Состояние и
поведение контекста можно будет изменить в любой
момент, подключив к нему другой объект-состояние.
Очень важным нюансом, отличающим этот паттерн от
Стратегии, является то, что и контекст, и сами конкретные
состояния могут знать друг о друге и инициировать
переходы от одного состояния к другому.
? Аналогия из жизни
Ваш смартфон ведёт себя по-разному, в зависимости от
текущего состояния:
• Когда телефон разблокирован, нажатие кнопок телефона
приводит к каким-то действиям.
• Когда телефон заблокирован, нажатие кнопок приводит к
экрану разблокировки.
• Когда телефон разряжен, нажатие кнопок приводит к
экрану зарядки.
353 Поведенческие паттерны / Состояние
? Структура
1. Контекст хранит ссылку на объект состояния и делегирует
ему работу, зависящую от внутреннего состояния. Контекст
работает с этим объектом через общий интерфейс
состояний. Контекст должен иметь метод для присваивания
ему ныового объекта-состояния.
2. Состояние описывает общий интерфейс для всех
конкретных состояний.
3. Конкретные состояния реализуют поведения, связанные с
определённым состоянием контекста. Иногда приходится
354 Поведенческие паттерны / Состояние
создавать целые иерархии классов состояний, чтобы
обобщить дублирующий код.
Состояние может иметь обратную ссылку на объект
контекста. Через неё не только удобно получать из
контекста нужную информацию, но и осуществлять смену
его состояния.
4. И контекст, и объекты конкретных состояний могут решать,
когда и какое следующее состояние будет выбрано. Чтобы
переключить состояние, нужно подать другой объектсостояние в контекст.
? Псевдокод
Пример изменение поведения проигрывателя с помощью состояний.
355 Поведенческие паттерны / Состояние
В этом примере паттерн Состояние изменяет
функциональность одних и тех же элементов управления
музыкальным проигрывателем, в зависимости от того, в
каком состоянии находится сейчас проигрыватель.
Объект проигрывателя содержит объект-состояние,
которому и делегирует основную работу. Изменяя
состояния, можно менять то, как ведут себя элементы
управления проигрывателя.
1 // Общий интерфейс всех состояний.
2 abstract class State is
3 protected field player: Player
4
5 // Контекст передаёт себя в конструктор состояния, чтобы
6 // состояние могло обращаться к его данным и методам в
7 // будущем, если потребуется.
8 constructor State(player) is
9 this.player = player
10
11 abstract method clickLock()
12 abstract method clickPlay()
13 abstract method clickNext()
14 abstract method clickPrevious()
15
16
17 // Конкретные состояния реализуют методы абстрактного
18 // состояния по-своему.
19 class LockedState is
20
21 // При разблокировке проигрователя с заблокированными
22 // клавишами, он может принять одно из двух состояний.
356 Поведенческие паттерны / Состояние
23 method clickLock() is
24 if (player.playing)
25 player.changeState(new PlayingState(player))
26 else
27 player.changeState(new ReadyState(player))
28
29 method clickPlay() is
30 // Ничего не делать.
31
32 method clickNext() is
33 // Ничего не делать.
34
35 method clickPrevious() is
36 // Ничего не делать.
37
38
39 // Они также могут переводить контекст в другие состояния.
40 class ReadyState is
41 method clickLock() is
42 player.changeState(new LockedState(player))
43
44 method clickPlay() is
45 player.startPlayback()
46 player.changeState(new PlayingState(player))
47
48 method clickNext() is
49 player.nextSong()
50
51 method clickPrevious() is
52 player.previousSong()
53
54
55
56
357 Поведенческие паттерны / Состояние
57 class PlayingState is
58 method clickLock() is
59 player.changeState(new LockedState(player))
60
61 method clickPlay() is
62 player.stopPlayback()
63 player.changeState(new ReadyState(player))
64
65 method clickNext() is
66 if (event.doubleclick)
67 player.nextSong()
68 else
69 player.fastForward(5)
70
71 method clickPrevious() is
72 if (event.doubleclick)
73 player.previous()
74 else
75 player.rewind(5)
76
77
78 // Проигрыватель играет роль контекста.
79 class Player is
80 field state: State
81 field UI, volume, playlist, currentSong
82
83 constructor Player() is
84 this.state = new ReadyState(this)
85
86 // Контекст заставляет состояние реагировать на
87 // пользовательский ввод вместо себя. Реакция может
88 // быть разной в зависимости от того, какое
89 // состояние сейчас активно.
90 UI = new UserInterface()
358 Поведенческие паттерны / Состояние
91 UI.lockButton.onClick(this.clickLock)
92 UI.playButton.onClick(this.clickPlay)
93 UI.nextButton.onClick(this.clickNext)
94 UI.prevButton.onClick(this.clickPrevious)
95
96 // Другие объекты должны иметь возможность заменить
97 // состояние проигрывателя.
98 method changeState(state: State) is
99 this.state = state
100
101 // Методы UI будут делегировать работу
102 // активному состоянию.
103 method clickLock() is
104 state.clickLock()
105 method clickPlay() is
106 state.clickPlay()
107 method clickNext() is
108 state.clickNext()
109 method clickPrevious() is
110 state.clickPrevious()
111
112 // Сервисные методы контекста, вызываемые состояниями.
113 method startPlayback() is
114 // ...
115 method stopPlayback() is
116 // ...
117 method nextSong() is
118 // ...
119 method previousSong() is
120 // ...
121 method fastForward(time) is
122 // ...
123 method rewind(time) is
124 // ...
359 Поведенческие паттерны / Состояние
? Применимость
? Когда у вас есть объект, поведение которого кардинально
меняется в зависимости от внутреннего состояния. Причём
типов состояний много и их код часто меняется.
? Паттерн предлагает выделить все поля и методы,
связанные с определённым состоянием в собственные
классы. Первоначальный объект будет постоянно ссылаться
на один из объектов-состояний, делегируя ему большую
часть работы. Для изменения состояния, в контекст
достаточно будет подставляться другой объект-состояние.
? Когда код класса содержит множество больших, похожих
друг на друга, условных операторов, которые выбирают
поведения в зависимости от текущих значений полей
класса.
? Паттерн предлагает переместить каждую ветку такого
условного оператора в собственный класс. Тут же можно
поселить и все поля, связанные с данным состоянием.
? Когда вы сознательно используете табличную машину
состояний, построенную на условных операторах, но
вынуждены мириться с дублированием кода для похожих
состояний и переходов.
360 Поведенческие паттерны / Состояние
? Паттерн Состояние позволяет реализовать иерархическую
машину состояний, базирующуюся на наследовании. Вы
можете отнаследовать похожие состояния от одного
родительского класса, и вынести туда весь дублирующий
код.
? Шаги реализации
1. Определитесь с классом, который будет играть роль
контекста. Это может быть как существующий класс, в
котором уже есть зависимость от состояния, так и новый
класс, если код состояний размазан по нескольким классам.
2. Создайте интерфейс состояний. Он должен описывать
методы, общие для всех состояний, обнаруженных в
контексте. Заметьте, что не всё поведение контекста нужно
переносить в состояние, а только то, которое зависит от
состояний.
3. Для каждого фактического состояния, создайте класс,
реализующий интерфейс состояния. Переместите весь код,
связанный с конкретным состоянием в нужный класс. В
конце концов, все методы интерфейса состояния должны
быть реализованы.
При переносе поведения из контекста, вы можете
столкнуться с тем, что это поведение зависит от приватных
полей или методов контекста, к кторым нет доступа из
361 Поведенческие паттерны / Состояние
состояния. Есть парочка способов обойти эту проблему.
Самый простой — оставить поведение внутри контекста,
вызывая его из объекта состояния. С другой стороны, вы
может сделать классы состояний вложенными в класс
контекста, и тогда они получат доступ ко всем приватным
частям контекста. Но последний способ доступен только в
некоторых языках программирования (например, Java, C#).
4. Создайте в контексте поле для хранения объектовсостояний, а также публичный метод для изменения
значения этого поля.
5. Старые методы контекста, в которых находился зависимый
от состояния код, замените на вызовы соответствующих
методов объекта-состояния.
6. В зависимости от бизнес-логики, разместите код, который
переключает состояние контекста либо внутри контекста,
либо внутри классов конкретных состояний.
? Преимущества и недостатки
? Избавляет от множества больших условных операторов
машины состояний.
? Концентрирует в одном месте код, связанный с
определённым состоянием.
? Упрощает код контекста.
362 Поведенческие паттерны / Состояние
? Может неоправданно усложнить код, если состояний мало и
они редко меняются.
? Отношения с другими паттернами
• Мост, Стратегия и Состояние (а также слегка и Адаптер)
имеют схожие структуры классов — все они построены на
принципе «композиции», то есть делегирования работы
другим объектам. Тем не менее, они отличаются тем, что
решают разные проблемы. Помните, что паттерны — это не
только рецепт построения кода определённым образом, но
и описание проблем, которые привели к данному решению.
• Состояние можно рассматривать как надстройку над
Стратегией. Оба паттерна используют композицию, чтобы
менять поведение основного объекта, делегируя работу
вложенным объектам-помощникам. Однако в Стратегии
эти объекты не знают друг о друге и никак не связаны. В
Состоянии сами конкретные состояния могут переключать
контекст.
363 Поведенческие паттерны / Состояние
СТРАТЕГИЯ
Также известен как: Strategy
Стратегия — это поведенческий паттерн проектирования,
который определяет семейство схожих алгоритмов и
помещает каждый из них в собственный класс. После чего,
алгоритмы можно взаимозаменять прямо во время
исполнения программы.
364 Поведенческие паттерны / Стратегия
? Проблема
Вы решили написать приложение-навигатор для
путешественников. Он должен показывать красивую и
удобную карту, позволяющую с лёгкостью ориентироваться
в незнакомом городе.
Одной из самых востребованных функций был поиск и
прокладка маршрута, поэтому вы планировали посвятить
ей особое внимание. Пребывая в неизвестном ему городе,
пользователь должен иметь возможность указать
начальную точку и пункт назначения. А навигатор —
проложит оптимальный путь.
Первая версия вашего навигатора могла прокладывать
маршрут лишь по дорогам, поэтому отлично подходила для
путешествий на автомобиле. Но, очевидно, не все ездят в
отпуск на машине. Поэтому следующим шагом вы добавили
в навигатор прокладку пеших маршрутов. Через некоторое
время выяснилось, что некоторые люди предпочитают
ездить по городу на общественном транспорте, поэтому вы
добавили и такую опцию прокладки пути.
Но и это ещё не всё. В ближайшей перспективе вы хотели
бы добавить прокладку маршрутов по велодорожкам. А в
отдалённом будущем — интересные маршруты посещения
достопримечательностей.
365 Поведенческие паттерны / Стратегия
Код навигатора становится слишком раздутым.
Если с популярностью навигатора не было никаких
проблем, то техническая часть вызывала вопросы и
периодическую головную боль. С каждым новым
алгоритмом, код основного класса навигатора увеличивался
вдвое. В таком большом классе стало довольно трудно
ориентироваться.
Любое изменение алгоритмов поиска, будь то исправление
багов или добавление нового алгоритма, затрагивало
основной класс. Это повышало риск сделать ошибку,
случайно задев остальной работающий код.
Кроме того, осложнялась командная работа с другими
программистами, которых вы наняли после успешного
релиза навигатора. Ваши изменения нередко затрагивали
один и тот же код, создавая конфликты, которые требовали
дополнительного времени на их разрешение.
366 Поведенческие паттерны / Стратегия
? Решение
Паттерн Стратегия предлагает определить семейство
схожих алгоритмов, которые часто изменяются или
расширяются, и вынести их в собственные классы,
называемые стратегиями.
Вместо того чтобы изначальный класс сам выполнял тот или
иной алгоритм, он будет отыгрывать роль контекста,
ссылаясь на одну из стратегий и делегируя ей выполнение
работы. А для смены алгоритма будет достаточно
подставить в контекст другой объект-стратегию.
Важно, чтобы все стратегии имели общий интерфейс.
Используя этот интерфейс, контекст будет независимым от
конкретных классов стратегий. С другой стороны, вы
сможете изменять и добавлять новые виды алгоритмов, не
трогая код контекста.
Стратегии постройки пути.
367 Поведенческие паттерны / Стратегия
В нашем примере, каждый алгоритм поиска пути переедет
в свой собственный класс с единственным методом,
принимающим в параметрах начальную и конечную точку
маршрута и возвращающий массив точек маршрута.
Хотя каждый класс будет прокладывать маршрут по-своему,
для навигатора это не будет иметь никакого значения, так
как его работа заключается только в отрисовке маршрута.
Навигатору достаточно подать в стратегию данные о начале
и конце маршрута, чтобы получить массив точек маршрута
в оговорённом формате. Класснавигатора будет иметь
метод изменения стратегии, позволяющий изменять
стратегию поиска пути на лету. Им сможет воспользоваться
клиентский код навигатора, например, кнопкипереключатели типов маршрутов в пользовательском
интерфейсе.
? Аналогия из жизни
Различные стратегии попадания в аэропорт.
368 Поведенческие паттерны / Стратегия
Вам нужно добраться до аэропорта. Можно доехать на
автобусе, такси или велосипеде. Здесь вид транспорта
является стратегией. Вы выбираете конкретную стратегию в
зависимости от контекста (например, наличия денег или
времени до отлёта).
? Структура
1. Контекст хранит ссылку на объект конкретной стратегии,
работая с ним объектом через общий интерфейс стратегий.
369 Поведенческие паттерны / Стратегия
2. Стратегия определяет интерфейс, общий для всех вариаций
алгоритма. Контекст использует этот интерфейс для вызова
алгоритма.
Для контекста не важно, какая именно вариация алгоритма
будет выбрана, так как все они имеют одинаковый
интерфейс.
3. Конкретные стратегии реализуют различные вариации
алгоритма.
4. Во время выполнения программы, контекст получает
вызовы от клиента и делегирует их объекту конкретной
стратегии.
5. Обычно, клиент должен создать объект конкретной
стратегии и передать его в контекст: либо через
конструктор, либо в какой-то другой решающий момент,
используя сеттер. Благодаря этому, контекст не знает о том,
какая именно стратегия сейчас выбрана.
? Псевдокод
В этом примере, контекст использует Стратегию для
выполнения той или иной арифметической операции.
370 Поведенческие паттерны / Стратегия
1 // Общий интерфейс всех стратегий.
2 interface Strategy is
3 method execute(a, b)
4
5 // Каждая конкретная стратегия реализует общий интерфейс
6 // своим способом.
7 class ConcreteStrategyAdd implements Strategy is
8 method execute(a, b) is
9 return a + b
10
11 class ConcreteStrategySubtract implements Strategy is
12 method execute(a, b) is
13 return a - b
14
15 class ConcreteStrategyMultiply implements Strategy is
16 method execute(a, b) is
17 return a * b
18
19 // Контекст всегда работает со стратегиями через общий
20 // интерфейс. Он не знает какая именно стратегия ему подана.
21 class Context is
22 private strategy: Strategy
23
24 method setStrategy(Strategy strategy) is
25 this.strategy = strategy
26
27 method executeStrategy(int a, int b) is
28 return strategy.execute(a, b)
29
30 // Конкретная стратегия выбирается на более высоком уровне,
31 // например, конфигуратором всего приложения. Готовый
32 // объект-стратегия подаётся в клиентский объект, а затем
33 // может быть заменён другой стратегией в любой момент
34 // на лету.
371 Поведенческие паттерны / Стратегия
? Применимость
? Когда вам нужно использовать разные вариации какого-то
алгоритма внутри одного объекта.
? Стратегия позволяет варьировать поведение объекта во
время выполнения программы, подставляя в него
различные объекты-поведения (например, отличающиеся
балансом скорости и потребления ресурсов).
35 class ExampleApplication is
36 method main() is
37 Create context object.
38
39 Read first number.
40 Read last number.
41 Read the desired action from user input.
42
43 if (action == addition) then
44 context.setStrategy(new ConcreteStrategyAdd())
45
46 if (action == subtraction) then
47 context.setStrategy(new ConcreteStrategySubtract())
48
49 if (action == multiplication) then
50 context.setStrategy(new ConcreteStrategyMultiply())
51
52 result = context.executeStrategy(First number, Second number)
53
54 Print result.
372 Поведенческие паттерны / Стратегия
? Когда у вас есть множество похожих классов,
отличающихся только некоторым поведением.
? Стратегия позволяет вынести отличающееся поведение в
отдельную иерархию классов и свести первоначальные
классы к одному, сделав его поведение настраиваемым.
? Когда вы не хотите обнажать детали реализации
алгоритмов для других классов.
? Стратегия позволяет изолировать код, данные и
зависимости алгоритмов от других объектов, скрыв из
внутри собственных классов.
? Когда различные вариации алгоритмов реализованы в
виде развесистого условного оператора. Каждая ветка
такого оператора представляет вариацию алгоритма.
? Стратегия помещает каждую лапу такого оператора в
отдельный класс-стратегию. Затем контекст получает
определённый объект-стратегию от клиента и делегирует
ему работу. Если вдруг понадобится сменить алгоритм, в
контекст можно подать другую стратегию.
373 Поведенческие паттерны / Стратегия
? Шаги реализации
1. Определите алгоритм, который подвержен частым
изменениям. Также подойдёт алгоритм, имеющий
несколько вариаций, которые выбираются во время
выполнения программы.
2. Создайте интерфейс стратегий, описывающий этот
алгоритм. Он должен быть общим для всех вариантов
алгоритма.
3. Поместите вариации алгоритма в собственные классы,
которые реализуют этот интерфейс.
4. В классе контекста создайте поле для хранения ссылки на
текущий объект-стратегию, а также метод для её изменения.
Убедитесь в том, что контекст работает с этим объектом
только через общий интерфейс стратегий.
5. Клиенты контекста должны подавать в него
соответствующий объект-стратегию, когда хотят, чтобы
контекст вёл себя определённым образом.
? Преимущества и недостатки
? Горячая замена алгоритмов на лету.
? Изолирует код и данные алгоритмов от остальных классов.
? Уход от наследования к делегированию.
374 Поведенческие паттерны / Стратегия
? Реализует принцип открытости/закрытости.
? Усложняет программу за счёт дополнительных классов.
? Клиент должен знать, в чём разница между стратегиями,
чтобы выбрать подходящую.
? Отношения с другими паттернами
• Мост, Стратегия и Состояние (а также слегка и Адаптер)
имеют схожие структуры классов — все они построены на
принципе «композиции», то есть делегирования работы
другим объектам. Тем не менее, они отличаются тем, что
решают разные проблемы. Помните, что паттерны — это не
только рецепт построения кода определённым образом, но
и описание проблем, которые привели к данному решению.
• Команда и Стратегия похожи по духу, но отличаются
масштабом и применением:
? Команду используют, чтобы превратить любые
разнородные действия в объекты. Параметры операции
превращаются в поля объекта. Этот объект теперь можно
логировать, хранить в истории для отмены, передавать
во внешние сервисы и так далее.
? С другой стороны, Стратегия описывает разные способы
сделать одно и то же действие, позволяя взаимозаменять
эти способы в каком-то объекте контекста.
375 Поведенческие паттерны / Стратегия
• Стратегия меняет поведение объекта «изнутри», а
Декоратор изменяет его «снаружи».
• Шаблонный метод использует наследование, чтобы
расширять части алгоритма. Стратегия использует
делегирование, чтобы изменять выполняемые алгоритмы
на лету. Шаблонный метод работает на уровне классов.
Стратегия позволяет менять логику отдельных объектов.
• Состояние можно рассматривать как надстройку над
Стратегией. Оба паттерна используют композицию, чтобы
менять поведение основного объекта, делегируя работу
вложенным объектам-помощникам. Однако в Стратегии
эти объекты не знают друг о друге и никак не связаны. В
Состоянии сами конкретные состояния могут переключать
контекст.
376 Поведенческие паттерны / Стратегия
ШАБЛОННЫЙ
МЕТОД
Также известен как: Template Method
Шаблонный метод — это поведенческий паттерн
проектирования, который определяет скелет алгоритма,
перекладывая ответственность за некоторые его шаги на
подклассы. Паттерн позволяет подклассам переопределять
шаги алгоритма, не меняя его общей структуры.
377 Поведенческие паттерны / Шаблонный метод
? Проблема
Вы пишете программу для дата-майнинга в офисных
документах. Пользователи будут загружать в неё документы
в разных форматах (PDF, DOC, CSV), а программа должна
извлекать из них полезную информацию.
В первой версии вы ограничились только обработкой DOCфайлов. В следующей версии, добавили поддержку CSV. А
через месяц прикрутили работу с PDF-документами.
Классы дата майнинга содержат много дублирования.
В какой-то момент вы заметили, что код всех трёх классов
обработки документов хоть и отличается в части работы с
файлами, но содержат довольно много общего в части
378 Поведенческие паттерны / Шаблонный метод
самого извлечения данных. Было бы здорово избавится от
повторной реализации алгоритма извлечения данных в
каждом из классов
К тому же остальной код, работающий с объектами этих
классов, наполнен условиями, проверяющими тип
обработчика перед началом работы. Весь этот код можно
упростить, если слить все три класса воедино, либо свести
их к общему интерфейсу.
? Решение
Паттерн Шаблонный метод предлагает разбить алгоритм на
последовательность шагов, описать шаги в отдельных
методах и вызывать их в одном «шаблонном» методе друг
за другом.
Это позволит подклассам переопределять некоторые шаги
алгоритма, оставляя без изменений его структуру и
остальные шаги, которые для этого подкласса не так важны.
В нашем примере с дата-майнингом, мы можем создать
общий базовый класс для всех трёх алгоритмов. Этот класс
будет состоять из шаблонного метод, который
последовательно вызывает шаги разбора документов.
Для начала, шаги шаблонного метода можно сделать
абстрактными. Из-за этого все подклассы должны будут
379 Поведенческие паттерны / Шаблонный метод
реализовать каждый из шагов по-своему. В нашем случае,
все подклассы и так содержат реализацию каждого из
шагов, поэтому ничего дополнительно делать не нужно.
Шаблонный метод разбивает алгоритм на шаги, позволяя подклассам
переопределить некоторые из них.
По-настоящему важным является следующий этап. Теперь
мы можем определить общее для всех трёх классов
поведение и вынести его в суперкласс. В нашем примере,
шаги открытия и закрытия документов будут отличаться для
всех подклассов, поэтому останутся абстрактными. А вот
одинаковый для всех типов документов код обработки
данных переедет в базовый класс.
Как видите, у нас получилось два вида шагов:
абстрактные, которые каждый подкласс должен будет
380 Поведенческие паттерны / Шаблонный метод
реализовать, а также — шаги с реализацией по-умолчанию,
которую можно, но не обязательно, переопределить в
подклассе.
Но есть и третий тип шагов — хуки. Это «опциональные»
шаги, которые выглядят как обычные методы, но не
содержат никакого кода. Шаблонный метод останется
рабочим, даже если ни один подкласс не переопределит
такой хук. В то же время, хук даёт подклассам
дополнительные точки «вклинивания» в ход шаблонного
метода.
? Аналогия из жизни
Проект типового дома могут немного изменить по желанию клиента.
Строители используют подход, похожий на шаблонный
метод при строительстве типовых домов. У них есть
381 Поведенческие паттерны / Шаблонный метод
основной архитектурный проект, в котором расписаны шаги
строительства — заливка фундамента, постройка стен,
постановка крыши, установка окон, обивка и так далее.
Но, несмотря на стандартизацию каждого этапа, строители
могут делать небольшие изменения на любом из этапов,
чтобы сделать дом чуточку непохожим на другие.
? Структура
382 Поведенческие паттерны / Шаблонный метод
1. Абстрактный класс определяет шаги алгоритма и содержит
шаблонный метод, состоящий из вызовов этих шагов. Шаги
могут быть как абстрактными, так и содержать реализацию
по умолчанию.
2. Конкретный класс переопределяет некоторые (или все)
шаги алгоритма. Конкретные классы не переопределяют
сам шаблонный метод.
? Псевдокод
В этом примере Шаблонный метод используется как
заготовка для стандартных действий искусственного
интеллекта в простой игре. Для введения в игру новой
расы, достаточно создать подкласс и реализовать в нём
недостающие методы.
Все расы игры будут содержать примерно такие же типы
юнитов и строений, поэтому структура ИИ будет
одинаковой. Но разные расы могут по-разному реализовать
эти шаги. Так, например, орки будут агрессивней в атаке,
люди — более активны в защите, а дикие монстры —
вообще не будут заниматься строительством.
383 Поведенческие паттерны / Шаблонный метод
Пример классов искусственного интеллекта для простой игры.
1 class GameAI is
2 // Шаблонный метод должен быть задан в базовом классе.
3 // Он состоит из вызовов методов в определённом порядке.
4 // Чаще всего эти методы являются шагами
5 // некоего алгоритма.
6 method turn() is
7 collectResources()
8 buildNewStructures()
9 buildUnits()
10 attack()
384 Поведенческие паттерны / Шаблонный метод
11 // Некоторые из этих методов могут быть реализованы
12 // прямо в базовом классе.
13 method collectResources() is
14 foreach (s in this.builtStructures) do
15 s.collect()
16
17 // А некоторые могут быть полностью абстрактными.
18 abstract method buildStructures()
19 abstract method buildUnits()
20
21 // Кстати, шаблонных методов в классе может
22 // быть несколько.
23 method attack() is
24 enemy = closestEnemy()
25 if (enemy == null)
26 sendScouts(map.center)
27 else
28 sendWarriors(enemy.position)
29
30 abstract method sendScouts(position)
31 abstract method sendWarriors(position)
32
33 // Подклассы могут предоставлять свою реализацию шагов
34 // алгоритма, не изменяя сам шаблонный метод.
35 class OrcsAI extends GameAI is
36 method buildStructures() is
37 if (there are some resources) then
38 // Строить фермы, затем бараки, а потом цитадель.
39
40 method buildUnits() is
41 if (there are plenty of resources) then
42 if (there are no scouts)
43 // Построить раба и добавить в группу разведчиков.
44 else
385 Поведенческие паттерны / Шаблонный метод
? Применимость
? Когда подклассы должны расширять базовый алгоритм, не
меняя его структуры.
45 // Построить пехотинца и добавить в группу воинов.
46
47 // ...
48
49 method sendScouts(position) is
50 if (scouts.length > 0) then
51 // Отправить разведчиков на позицию.
52
53 method sendWarriors(position) is
54 if (warriors.length > 5) then
55 // Отправить воинов на позицию.
56
57 // Подклассы могут не только реализовывать абстрактные шаги,
58 // но и переопределять шаги, уже реализованные в
59 // базовом классе.
60 class MonstersAI extends GameAI is
61 method collectResources() is
62 // Ничего не делать.
63
64 method buildStructures() is
65 // Ничего не делать.
66
67 method buildUnits() is
68 // Ничего не делать.
386 Поведенческие паттерны / Шаблонный метод
? Шаблонный метод позволяет подклассам расширять
определённые шаги алгоритма через наследование, не
меняя при этом структуру алгоритмов, объявленную в
родительском классе.
? Когда у вас есть несколько классов, делающих одно и то же
с незначительными отличиями. Если вы редактируете один
класс, то приходится вносить такие же правки и в
остальные классы.
? Паттерн шаблонный метод предлагает создать для похожих
классов общий суперкласс и оформить в нём главный
алгоритма в виде шагов. Отличающиеся шаги можно
переопределить в подклассах.
Это позволит убрать дублирование кода в нескольких
классах с похожим поведением, но отличающихся в
деталях.
? Шаги реализации
1. Изучите алгоритм и подумайте, можно ли его разбить на
шаги. Прикиньте, какие шаги будут стандартными для всех
вариаций алгоритма, а какие — изменчивыми.
2. Создайте абстрактный базовый класс. Определите в нём
шаблонный метод. Этот метод должен состоять из вызовов
шагов алгоритма. Имеет смысл сделать шаблонный метод
387 Поведенческие паттерны / Шаблонный метод
финальным, чтобы подклассы не могли переопределить его
(если ваш язык программирования это позволяет).
3. Добавьте в абстрактный класс методы для каждого из
шагов алгоритма. Вы можете сделать эти методы
абстрактными или добавить какую-то реализацию по
умолчанию. В первом случае, все подклассы должны будут
реализовать эти методы, а во втором — только если
реализация шага в подклассе отличается от стандартной
версии.
4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки
располагают между основными шагами алгоритма, а также
до и после всех шагов.
5. Создайте конкретные классы, унаследовав их от
абстрактного класса. Реализуйте в них все недостающие
шаги и хуки.
? Преимущества и недостатки
? Облегчает повторное использование кода.
? Вы жёстко ограничены скелетом существующего алгоритма.
? Вы можете нарушить принцип подстановки Барбары Лисков,
изменяя базовое поведение одного из шагов алгоритма
через подкласс.
388 Поведенческие паттерны / Шаблонный метод
? С ростом количества шагов, шаблонный метод становится
слишком сложно поддерживать.
? Отношения с другими паттернами
• Фабричный метод можно рассматривать как частный
случай Шаблонного метода. Кроме того, Фабричный метод
нередко бывает частью большого класса с Шаблонными
методами.
• Шаблонный метод использует наследование, чтобы
расширять части алгоритма. Стратегия использует
делегирование, чтобы изменять выполняемые алгоритмы
на лету. Шаблонный метод работает на уровне классов.
Стратегия позволяет менять логику отдельных объектов.
389 Поведенческие паттерны / Шаблонный метод
ПОСЕТИТЕЛЬ
Также известен как: Visitor
Посетитель — это поведенческий паттерн проектирования,
который позволяет создавать новые операции, не меняя
классы объектов, над которыми эти операции могут
выполняться.
390 Поведенческие паттерны / Посетитель
? Проблема
Ваша команда разрабатывает приложение, работающее с
геоданными в виде графа. Узлами графа могут быть как
города, так и другие локации, будь то
достопримечательности, большие предприятия и так далее.
Каждый узел имеет ссылки на другие, ближайшие к нему
узлы. Для каждого типа узла имеется свой класс, а каждый
узел представлен отдельным объектом.
Экспорт гео-узлов в XML.
Ваша задача — сделать экспорт этого графа в XML. Дело
было бы плёвым, если бы вы могли редактировать классы
узлов. В этом случае, можно было бы добавить метод
экспорта в каждый тип узла, а затем, перебирая узлы
географического графа, вызывать этот метод для каждого
узла. Решение получилось бы изящным, так как
полиморфизм позволил бы не привязываться к конкретным
классам узлов.
391 Поведенческие паттерны / Посетитель
Но, к сожалению, классы узлов вам изменить не
получилось. Системный архитектор сослался на то, что код
классов узлов сейчас очень стабилен и от него многое
зависит, поэтому он не хочет рисковать и позволять комулибо его трогать.
Код XML-экспорта придётся добавить во все классы узлов, а это
слишком накладно.
К тому же он сомневался в том, что экспорт в XML вообще
уместен в рамках этих классов. Их основная задача была
связана с геоданными, а экспорт выглядит как чужеродное
поведение в рамках этих классов.
Была и ещё одна причина запрета. На следующей неделе
мог понадобиться экспорт в какой-то другой формат
данных, и вам снова пришлось бы трогать эти классы.
392 Поведенческие паттерны / Посетитель
? Решение
Паттерн Посетитель предлагает разместить новое
поведение в отдельном классе, вместо того, чтобы множить
его сразу в нескольких классах. Объекты, с которыми
должно было быть связано поведение, не будут выполнять
его самостоятельно. Вместо этого, вы будете передавать эти
объекты в методы посетителя.
Код поведения скорей всего должен отличаться для
объектов разных классов, поэтому и методов у посетителя
должно быть несколько. Названия и принцип действия этих
методов будет схож, но основное отличие будет в типе
принимаемого в параметрах объекта, например:
Здесь возникает вопрос, каким образом мы будет подавать
узлы в объект посетитель. Так как все методы имеют
отличающуюся сигнатуру, использовать полиморфизм при
переборе узлов не получится. Придётся проверять тип
узлов для того, чтобы выбрать соответствующий метод
посетителя.
1 class ExportVisitor implements Visitor is
2 method doForCity(City c) { ... }
3 method doForIndustry(Industry f) { ... }
4 method doForSightSeeing(SightSeeing ss) { ... }
5 // ...
393 Поведенческие паттерны / Посетитель
Тут не поможет даже механизм перегрузки методов
(доступный в Java и C#). Если назвать все методы
одинаково, то неопределённость реального типа узла всё
равно не даст вызвать правильный метод. Механизм
перегрузки всё время будет вызывать метод посетителя,
соответствующий типу Node , а не реального класса
поданного узла.
Но паттерн Посетитель решает и эту проблему, используя
механизм двойной диспетчеризации. Вместо того чтобы
самим искать нужный метод, мы можем поручить это
объектам, которые передаём в параметрах посетителю. А
они уже вызовут правильный метод посетителя.
1 foreach (Node node : graph)
2 if (node instanceof City)
3 exportVisitor.doForCity((City) node);
4 if (node instanceof Industry)
5 exportVisitor.doForIndustry((Industry) node);
6 // ...
1 // Client code
2 foreach (Node node : graph)
3 node.accept(exportVisitor);
4 // City
5 class City is
6 method accept(Visitor v) is
7 v.doForCity(this);
8 // ...
394 Поведенческие паттерны / Посетитель
Как видите, изменить классы узлов всё-таки придётся. Но
это простое изменение в любое время позволит применять
к объектам узлов и другие поведения. Ведь классы узлов
будут привязаны не к конкретному классу посетителей, а к
их общему интерфейсу. Поэтому если придётся добавить в
программу новое поведение, вы создадите новый класс
посетителей, реализующий общий интерфейс, и будете
передавать его в методы узлов.
? Аналогия из жизни
У страхового агента приготовлены полисы для разных видов организаций.
9 // Industry
10 class Industry is
11 method accept(Visitor v) is
12 v.doForIndustry(this);
13 // ...
395 Поведенческие паттерны / Посетитель
Представьте начинающего страхового агента, жаждущего
получить новых клиентов. Он беспорядочно посещает все
дома в округе, предлагая свои услуги. Но для каждого из
«типов» домов, которые он посещает, у него имеется
особое предложение.
• Придя в дом к обычной семье, он предлагает оформить
медицинскую страховку.
• Придя в банк, он предлагает страховку от грабежа.
• Придя на фабрику, он предлагает страховку предприятия от
пожара и наводнения.
396 Поведенческие паттерны / Посетитель
? Структура
1. Посетитель описывает общий интерфейс для всех типов
посетителей. Он объявляет набор методов, которые
принимают различные классы компонентов в качестве
параметров. В языках, поддерживающих перегрузку
методов, эти методы могут иметь одинаковые имена, но
типы их параметров должны отличаться.
397 Поведенческие паттерны / Посетитель
2. Конкретные посетители реализуют какое-то особенное
поведение для всех типов компонентов, которые можно
подать через методы интерфейс посетителя.
3. Компонент описывает метод принятия посетителя. Этот
метод должен иметь единственный параметр, объявленный
с типом интерфейса посетителя.
4. Конкретные компоненты реализуют методы принятия
посетителя. Цель этого метода — вызвать тот метод
посещения, который соответствует типу этого компонента.
Так посетитель узнает, с каким именно компонентом он
работает.
5. Клиентом зачастую выступает коллекция или сложный
составной объект (например, дерево Компоновщика).
Клиент не знает конкретные классы своих компонентов.
? Псевдокод
В этом примере Посетитель добавляет в существующую
иерархию классов геометрических фигур возможность
экспорта в XML.
398 Поведенческие паттерны / Посетитель
Пример организации экспорта объектов в XML через отдельный класспосетитель.
1 // Сложная иерархия компонентов.
2 interface Shape is
3 method move(x, y)
4 method draw()
5 method accept(v: Visitor)
6
7 // Метод принятия посетителя должен быть реализован в каждом
8 // компоненте, а не только в базовом классе. Это поможет
9 // программе определить какой метод посетителя нужно
10 // вызвать, в случае если вы не знаете тип компонента.
11 class Dot extends Shape is
12 // ...
399 Поведенческие паттерны / Посетитель
13 method accept(v: Visitor) is
14 v.visitDot(this)
15
16 class Circle extends Dot is
17 // ...
18 method accept(v: Visitor) is
19 v.visitCircle(this)
20
21 class Rectangle extends Shape is
22 // ...
23 method accept(v: Visitor) is
24 v.visitRectangle(this)
25
26 class CompoundShape implements Shape is
27 // ...
28 method accept(v: Visitor) is
29 v.visitCompoundShape(this)
30
31
32 // Интерфейс посетителей должен содержать методы посещения
33 // каждого компонента. Важно, чтобы иерархия компонентов
34 // менялась редко, так как при добавлении нового компонента
35 // придётся менять всех существующих посетителей.
36 interface Visitor is
37 method visitDot(d: Dot)
38 method visitCircle(c: Circle)
39 method visitRectangle(r: Rectangle)
40 method visitCompoundShape(cs: CompoundShape)
41
42 // Конкретный посетитель реализует одну операцию для всей
43 // иерархии компонентов. Новая операция = новый посетитель.
44 // Посетитель выгодно применять, когда новые компоненты
45 // добавляются очень редко, а команды добавляются
46 // очень часто.
400 Поведенческие паттерны / Посетитель
Вам не кажется, что вызов метода accept – это лишнее
звено здесь? Если так, то ещё раз рекомендую вам
ознакомиться с проблемой раннего и позднего связывания
в статье Посетитель и Double Dispatch.
47 class XMLExportVisitor is
48 method visitDot(d: Dot) is
49 // Экспорт id и кординатов центра точки.
50
51 method visitCircle(c: Circle) is
52 // Экспорт id, кординатов центра и радиуса окружности.
53
54 method visitRectangle(r: Rectangle) is
55 // Экспорт id, кординатов левого-верхнего угла, ширины
56 // и высоты прямоугольника.
57
58 method visitCompoundShape(cs: CompoundShape) is
59 // Экспорт id составной фигуры, а также списка id
60 // подфигур, из которых она состоит.
61
62
63 // Приложение может применять посетителя к любому набору
64 // объектов компонентов, даже не уточняя их типы. Нужный
65 // метод посетителя будет выбран благодаря проходу через
66 // метод accept.
67 class Application is
68 field allShapes: array of Shapes
69
70 method export() is
71 exportVisitor = new XMLExportVisitor()
72
73 foreach (shape in allShapes) do
74 shape.accept(exportVisitor)
401 Поведенческие паттерны / Посетитель
? Применимость
? Когда вам нужно выполнить операцию над всеми
элементами сложной структуры объектов (например,
деревом).
? Посетитель позволяет применять одну и ту же операцию к
объектам различных классов.
? Когда над объектами сложной структуры объектов надо
выполнять некоторые, не связанные между собой
операций, но вы не хотите «засорять» классы такими
операциями.
? Посетитель позволяет извлечь родственные операции из
классов, составляющих структуру объектов, поместив их в
один класс-посетитель. Если структура объектов является
общей для нескольких приложений, то паттерн позволит в
каждое приложение включить только нужные операции.
? Когда новое поведение имеет смысл только для некоторых
классов из существующей иерархии.
? Посетитель позволяет определить поведение только для
этих классов и оставить его пустым для всех остальных.
402 Поведенческие паттерны / Посетитель
? Шаги реализации
1. Создайте интерфейс посетителя и объявите в нём методы
«посещения» для каждого класса компонента, который
существует в программе.
2. Опишите интерфейс компонентов. Если вы работаете с уже
существующими классами, то объявите абстрактный метод
принятия посетителей в базовом классе иерархии
компонентов.
3. Реализуйте методы принятия во всех конкретных
компонентах. Они должны переадресовывать вызовы тому
методу посетителя, в котором класс параметра совпадает с
текущим классом компонента.
4. Иерархия компонентов должна знать только о базовом
интерфейсе посетителей. С другой стороны, посетители
будут знать обо всех классах компонентов.
5. Для каждого нового поведения создайте свой конкретный
класс. Приспособьте это поведение для всех посещаемых
компонентов, реализовав все методы интерфейса
посетителей.
Вы можете столкнуться с ситуацией, когда посетителю
нужен будет доступ к приватным полям компонентов. В
этом случае, вы можете либо раскрыть доступ к этим полям,
нарушив инкапсуляцию компонентов, либо сделать класс
403 Поведенческие паттерны / Посетитель
посетителя вложенным в класс компонента, если вам
повезло писать на языке, который поддерживает
вложенность классов.
6. Клиент будет создавать объекты посетителей, а затем
передавать их компонентам, используя метод принятия.
? Преимущества и недостатки
? Упрощает добавление новых операций над всей связанной
структурой объектов.
? Объединяет родственные операции в одном классе.
? Посетитель может накоплять состояние при обходе
структуры компонентов.
? Паттерн неоправдан, если иерархия компонентов часто
меняется.
? Может привести к нарушению инкапсуляции компонентов.
? Отношения с другими паттернами
• Посетитель можно рассматривать как расширенный аналог
Команды, который способен работать сразу с несколькими
видами получателей.
404 Поведенческие паттерны / Посетитель
• Вы можете выполнить какое-то действие над всем деревом
Компоновщика при помощи Посетителя.
• Посетитель можно использовать совместно с Итератором.
Итератор будет отвечать за обход структуры данных, а
Посетитель — за выполнение действий над каждым её
компонентом.
405 Поведенческие паттерны / Посетитель
Заключение
Поздравляю! Вы добрались до конца!
Но в мире существует множество других паттернов.
Надеюсь, эта книга станет вашей стартовой точкой к
дальнейшему постижению паттернов и развитию
сверхспособностей в проектировании программ.
Вот парочка идей для следующих шагов, если вы ещё не
определились что будете делать дальше:
• ? Не забывайте, что вместе с этой книгой поставляется
архив с реальными примерами кода на разных языках
программирования.
• ? Прочитайте книгу Джошуа Кериевски «Рефакторинг с
использованием паттернов проектирования».
• ? Не разбираетесь в рефакторинге? У меня есть хорошие
материалы для вас.
• ? Распечатайте шпаргалки по паттернам и повесьте их гдето на видном месте.
• ? Оставьте отзыв об этой книге. Мне было бы очень
интересно услышать ваше мнение, даже если это критика ?