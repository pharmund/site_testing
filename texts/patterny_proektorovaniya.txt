Отзывы о книге
Я получил книгу вчера, начал читать ее по дороге домой... и не мог остановиться. Я взял ее в тренажерный зал, и окружающие, вероятно, удивлялись, когда я читал во время тренировки. Круто в высшей 
степени. Книга отлично читается, но в ней рассматривается вполне серьезный материал, и все по делу. 
Весьма впечатляюще.
 — Эрик Гамма, заслуженный специалист IBM, 
соавтор книги «Паттерны объектно-ориентированного проектирования»,
один из участников «Банды Четырех» наряду
с Ричардом Хелмом, Ральфом Джонсоном и Джоном Влиссидесом
Книга умудряется сочетать юмор, техническую глубину и полезнейшие практические советы; получается занимательное чтение, располагающее к размышлениям. И новички в области паттернов, 
и опытные разработчики, применявшие их годами, наверняка вынесут что-то полезное из посещения 
Объектвиля.
 — Ричард Хелм, соавтор книги «Паттерны объектно-ориентированного проектирования»,
вместе с остальными участниками «Банды Четырех» — Эриком Гаммой,
Ральфом Джонсоном и Джоном Влиссидесом
У меня такое чувство, словно я прочитал сразу полтонны книг.
 — Уорд Каннингем, изобретатель Wiki и основатель Hillside Group
Книга близка к идеалу благодаря сочетанию удобочитаемости и практического опыта. Авторы излагают материал на достойном уровне и делают это изящно. Это одна из немногих книг по программированию, которую я считаю незаменимой (а я к этой категории причисляю книг десять, не более).
 — Дэвид Гелентер, профессор информационных технологий, 
 Йельский университет, автор книг «Mirror Worlds» и «Machine Beauty»
Погружение в мир паттернов — в страну, в которой сложное становится простым, но и простое может 
оказаться сложным. Не представляю себе лучшего вводного руководства, чем эта книга.
 — Мико Мацумура, отраслевой аналитик, Middleware Company,
 бывший ведущий специалист по Java, Sun Microsystems
Я смеялся, я плакал, книга тронула меня.
 — Дэниел Стейнберг, старший редактор java.net
Сначала мне захотелось упасть на пол от смеха. Но потом я собрался и понял, что эта книга не только 
содержит технически точную информацию, но и является самым доступным введением в паттерны 
проектирования, которое я когда-либо встречал.
 — Доктор Тимоти Бадд, адъюнкт-профессор в области информационных технологий 
 Орегонского государственного университета, автор более дюжины книг, 
 в том числе «C++ for Java Programmers»
Отзывы о книге
Джерри Райс обращается с паттернами лучше любого принимающего в NFL, но Фримены превзошли 
его. Серьезно... Это одна из самых забавных и умных книг в области проектирования ПО, которые 
я когда-либо читал.
 — Аарон Лаберг, старший вице-президент по технологиям и разработке продуктов, ESPN
Хорошая архитектура программы прежде всего определяется хорошей информационной архитектурой. Проектировщик учит компьютер, как выполнить ту или иную операцию, и не приходится удивляться тому, что хороший учитель компьютеров оказывается хорошим учителем программистов. Благодаря ее доступности, юмору и уму авторов даже непрограммист хорошо воспримет эту книгу.
 — Кори Доктороу, один из редакторов Boing Boing, автор книг «Down and Out in the Magic 
Kingdom» и «Someone Comes to Town, Someone Leaves Town»
Эрик и Элизабет в своей книге бесстрашно вызвались заглянуть за занавес программного кода. Они 
излагают основные концепции проектирования на таком честном уровне, на который не решаются 
многие писатели, думающие только об укреплении своего замечательного эго, — на уровне, на котором открываются столь поразительные истины. Софистам и цирковым зазывалам здесь делать нечего. 
Образованные люди следующего поколения — не забудьте взять в руки карандаш.
 — Кен Голдстейн, исполнительный вице-президент
и директор-распорядитель, Disney Online
Для меня написать этот абзац было трудно, потому что очень давно Эрик и Элизабет были моими студентами, и мне не хотелось уж слишком сильно восторгаться… но это лучшая книга по паттернам проектирования, написанная для студентов. Вот вам доказательство: я использовал ее с момента выхода 
на средних и старших курсах, в области разработки ПО и нетривиального программирования. И как 
только она вышла, я забросил книгу «Банды Четырех» и всех ее конкурентов!
— Грегори Роулинс, Университет Индианы
Благодаря сочетанию юмора, отличных примеров и глубокого знания паттернов проектирования обучение по этой книге становится увлекательным занятием. Например, меня как активного участника 
индустрии развлечений сразу заинтриговал Голливудский принцип и паттерн Фасад для домашнего 
кинотеатра. Понимание паттернов проектирования не только помогает нам создавать качественные 
программы, пригодные для повторного использования, но и совершенствует наши навыки решения 
задач во всех предметных областях. Эта книга рекомендуется всем профессионалам и студентам в области компьютерных технологий.
— Ньютон Ли, основатель и старший редактор сайта acmcie.org (Association 
 for Computing Machinery / Computers in Entertainment)
Отзывы о книге
Если и есть тема, преподавание которой определенно требует большей занимательности, то это паттерны проектирования. К счастью, у нас теперь есть эта книга.
Великолепные авторы «Head First Java» используют все мыслимые приемы, чтобы помочь вам понять 
и запомнить материал. Здесь вы найдете не только множество изображений людей, которые привлекают внимание других людей. Сюрпризы повсюду! Многочисленные истории (например, о пицце 
и шоколаде. Стоит ли говорить еще?). Вдобавок книга невероятно смешная.
В ней представлены множество концепций и приемов, а также почти все паттерны, которые чаще 
всего используются на практике: Наблюдатель, Декоратор, Фабрика, Одиночка, Команда, Адаптер, 
Фасад, Шаблонный Метод, Итератор, Компоновщик, Состояние, Заместитель. Прочитайте, и все они 
перестанут быть «просто словами», превратившись в воспоминания, которые задевают вас за живое, 
и инструменты, применяемые в повседневной работе.
— Билл Камарда, READ ONLY
После использования «Head First Java» для обучения азам программирования я с нетерпением ждал 
следующего издания из этой серии. Я уверен, что данная книга быстро станет первой книгой, с которой следует начинать знакомство с паттернами, — и она уже стала книгой, которую я рекомендую 
своим студентам.
— Бен Бедерсон, адъюнкт-профессор в области информационных технологий,
директор лаборатории взаимодействий «человек–компьютер» в Мэрилендском университете
Обычно во время чтения книги или статьи, посвященной паттернам программирования, мне приходится 
время от времени щипать себя, чтобы убедиться в том, что я еще не заснул. С этой книгой все совершенно 
иначе. Как ни странно, она делает изучение паттернов легким и веселым занятием.
— Эрик Вулер
Я буквально влюблен в эту книгу. Я даже поцеловал ее на глазах у жены.
— Сатиш Кумар
Отзывы о технологии «Head First»
Технология Java повсюду: в мобильных телефонах, в машинах, фотоаппаратах, принтерах, играх, КПК, 
банкоматах, смарт-картах, бензонасосах, на стадионах, в медицинском оборудовании, веб-камерах, серверах... Если вы занимаетесь программированием, но еще не изучили Java, вам определенно стоит сделать 
это с книгой Head First.
— Скотт Макнили, председатель совета директоров Sun Microsystems,
президент и исполнительный директор
Книга читается быстро, она несерьезная, веселая и увлекательная. Будьте внимательны — из нее легко чтонибудь узнать!
— Кен Арнольд, бывший старший специалист в Sun Microsystems, соавтор книги «Язык программирования Java» (написанной вместе с Джеймсом Гослингом, создателем Java).
Design Patterns
Head First
Eric Freeman & 
Elisabeth Robson
with Kathy Sierra & Bert Bates
Wouldn't it be dreamy 
if there was a Design Patterns book 
that was more fun than going to the 
dentist, and more revealing than 
an IRS form? It's probably just 
a fantasy…
2-nd edition
Design Patterns
Head First
Eric Freeman & 
Elisabeth Robson
with Kathy Sierra & Bert Bates
Wouldn't it be dreamy 
if there was a Design Patterns book 
that was more fun than going to the 
dentist, and more revealing than 
an IRS form? It's probably just 
a fantasy…
2-nd edition 2-е издание
Паттерны проектирования
Head First
Эрик Фримен
Элизабет Робсон
Кэти Сьерра и Берт Бейтс
Как бы было хорошо 
найти книгу по паттернам. которая
будет веселее визита к зубному врачу 
и понятнее налоговой декларации... 
Наверное, об этом можно только 
мечтать...
2022
ББК 32.973.2-018-02
УДК 004.42
Х99
Фримен Эрик, Робсон Элизабет, Сьерра Кэти, Бейтс Берт
Х99 Head First. Паттерны проектирования. 2-е изд. — СПб.: Питер, 2022. — 640 с.: ил. — (Серия «Head 
First O’Reilly»).
ISBN 978-5-4461-1819-9
Не имеет смысла каждый раз изобретать велосипед, лучше сразу освоить приемы проектирования, которые уже созданы 
людьми, сталкивавшимися с аналогичными задачами. В этой книге рассказано, какие паттерны действительно важны, когда 
и при каких условиях ими необходимо пользоваться, как применить их в ваших проектах и на каких принципах объектноориентированного проектирования они построены. Присоединяйтесь к сотням тысяч разработчиков, которые повысили 
свою квалификацию объектно-ориентированного проектирования благодаря книге «Head First. Паттерны проектирования».
Если вы уже читали книги из серии Head First, то знаете, что вас ждет визуально насыщенный формат, разработанный 
с учетом особенностей работы мозга. В книге «Head First. Паттерны проектирования» принципы и паттерны проектирования представлены так, чтобы вы не заснули, читая книгу, научились решать реальные задачи проектирования программных 
продуктов и общаться на языке паттернов с другими участниками вашей команды.
16+ (В соответствии с Федеральным законом от 29 декабря 2010 г. № 436-ФЗ.)
ББК 32.973.2-018-02
УДК 004.42
Права на издание получены по соглашению с O’Reilly. Все права защищены. Никакая часть данной книги не может быть воспроизведена 
в какой бы то ни было форме без письменного разрешения владельцев авторских прав.
Информация, содержащаяся в данной книге, получена из источников, рассматриваемых издательством как надежные. Тем не менее, 
имея в виду возможные человеческие или технические ошибки, издательство не может гарантировать абсолютную точность и полноту 
приводимых сведений и не несет ответственности за возможные ошибки, связанные с использованием книги. Издательство не несет ответственности за доступность материалов, ссылки на которые вы можете найти в этой книге. На момент подготовки книги к изданию все 
ссылки на интернет-ресурсы были действующими.
Authorized Russian translation of the English edition of Head First Design Patterns 2E 
ISBN 9781492078005 © 2020 Eric Freeman & Elisabeth Robson
This translation is published and sold by permission of O’Reilly Media, Inc., 
which owns or controls all rights to publish and sell the same.
© Перевод на русский язык ООО Издательство «Питер», 2022
© Издание на русском языке, оформление ООО Издательство «Питер», 2022
© Серия «Head First O’Reilly», 2022
ISBN 978-1492078005 англ.
ISBN 978-5-4461-1819-9
Посвящается «Банде Четырех»; их прозорливость 
и мастерство в формулировке и описании паттернов проектирования навсегда изменили область 
проектирования программных архитектур и улучшили жизнь разработчиков во всем мире.
Ну сколько можно ждать, когда выйдет второе издание? 
В конце концов, прошло уже десять лет!
двадцать пять
8
Авторы/разработчики книги
об авторах
Элизабет — программист, писатель и преподаватель. Она влюблена в свою работу еще со времен 
учебы в Йельском университете, где получила степень магистра в области компьютерных наук.
Она стала одним из учредителей WickedlySmart — 
компании, работающей в области интернет-образования на базе веб-технологий. Здесь она пишет 
книги, статьи, создает видеокурсы и т. д. Ранее 
Элизабет занимала должность директора по специальным проектам в O’Reilly Media и разрабатывала семинары и курсы дистанционного обучения 
по разным техническим темам, помогающие людям разобраться в новых технологиях. 
Когда Элизабет не сидит за компьютером, она занимается велоспортом и греблей, фотографирует. 
Эрик, по словам Кэти Сьерра, соавтора серии 
Head First, — «один из редких людей, хорошо разбирающихся в самых разных областях деятельности, — технохипстер, вице-президент, инженер, 
аналитик».
Эрик Фримен — специалист по компьютерным 
технологиям, получил докторскую степень в Йельском университете. На протяжении своей профессиональной карьеры Эрик был техническим директором Disney Online и Disney.com в Walt Disney 
Company. 
В настоящее время Эрик — один из руководителей серии Head First, свое свободное время он 
посвящает созданию печатного и видеоконтента 
в WIckedlySmart. Этот контент распространяется 
по ведущим образовательным каналам. 
При участии Эрика вышли такие книги, как «Head 
First Design Patterns», «Head First HTML & CSS», 
«Head First JavaScript Programming», «Head First 
HTML5 Programming» и «Head First Learn to 
Code»*.
Эрик живет в Остине (штат Техас).
Элизабет Робсон
Эрик Фримен
* C книгами серии Head First вы можете ознакомиться
и приобрести их на сайте www.piter.com.
https://www.piter.com/collection/all?q=Head+First
9
Создатели серии Head First (и соавторы книги)
Кэти Сьерра
Кэти интересовалась теорией обучения еще 
с того времени, когда она занималась разработкой игр для Virgin, MGM и Amblin’ и преподавала теорию создания контента новых типов 
в UCLA. Она была ведущим преподавателем 
JavaScript в Sun Microsystems, а позднее основала сайт JavaRanch.com (теперь CodeRanch.com), 
получивший премии Jolt Cola Productivity в 2003 
и 2004 годах.
В 2015 году она получила премию Electronic 
Frontier Foundation Pioneer Award за свою работу, 
которая способствовала появлению квалифицированных разработчиков и формированию жизнеспособных сообществ.
В последнее время Кэти интересуется революционной методологией дрессировки, известной как 
«экологическая динамика», или Eco-D. Ее работа 
по применению Eco-D для обучения лошадей основана на гуманном подходе.
С Кэти можно связаться в Instagram:
@antherflows
Берт до того, как стал писать книги, был разработчиком, специализировавшимся на традиционном искусственном интеллекте (в основном 
экспертных системах), ОС реального времени 
и сложных системах планирования.
В 2003 году Берт и Кэти написали книгу «Head First 
Java» и положили начало серии Head First. С того 
времени Берт написал другие книги о Java и консультировал Sun Microsystems и Oracle по многим 
сертификационным экзаменам Java. Он также научил сотни авторов и редакторов создавать книги, 
которые стали хорошими учебниками.
Берт играет в го. В 2016 году он с ужасом и восхищением следил за тем, как AlphaGo громит Ли 
Седоля. В последнее время он применяет методологию Eco-D для улучшения своих навыков игры 
в гольф и для обучения своего попугайчика Боке.
Берту можно отправить сообщение на сайте 
CodeRanch.com.
Берт и Кэти знакомы с Бет и Эриком уже 16 лет, 
и серии Head First в высшей степени повезло, что 
они стали одними из ее ключевых соавторов.
Берт Бейтс
содержание
10
Введение
Настройте свой мозг на дизайн паттернов. Вот что вам понадобится, когда 
вы пытаетесь что-то выучить, в то время как ваш мозг не хочет воспринимать 
информацию. Ваш мозг считает: «Лучше уж я подумаю о более важных вещах, например об опасных диких животных или почему нельзя голышом прокатиться на сноуборде». Как же заставить свой мозг думать, что ваша жизнь 
зависит от овладения дизайном паттернов?
Для кого написана эта книга? 26
Мы знаем, о чем вы думаете 27
Метапознание: наука о мышлении 29
Вот что сделали мы 30
Что можете сделать вы 31
Примите к сведению 32
Содержание (сводка)
 Введение 25
1 Добро пожаловать в мир паттернов: знакомство с паттернами 37
2 Объекты в курсе событий: паттерн Наблюдатель 71
3 Украшение объектов: паттерн Декоратор 111
4 Домашняя ОО-выпечка: паттерн Фабрика 141
5 Уникальные объекты: паттерн Одиночка 199
6 Инкапсуляция вызова: паттерн Команда 219
7 Умение приспосабливаться: паттерны Адаптер и Фасад 265
8 Инкапсуляция алгоритмов: паттерн Шаблонный Метод 303
9 Управляемые коллекции: паттерны Итератор и Компоновщик 341
10 Состояние дел: паттерн Состояние 403
11 Управление доступом к объектам: паттерн Заместитель 447
12 Паттерны паттернов: составные паттерны 513
13 Паттерны в реальном мире: паттерны для лучшей жизни 581
14 Приложение: другие паттерны 615
Содержание (настоящее)
11
1 Добро пожаловать в мир паттернов
Наверняка вашу задачу кто-то уже решал. В этой главе вы узнаете, почему 
(и как) следует использовать опыт других разработчиков, которые уже сталкивались с аналогичной задачей и успешно решили ее. Заодно мы поговорим 
об использовании и преимуществах паттернов проектирования, познакомимся 
с ключевыми принципами объектно-ориентированного (ОО) проектирования и 
разберем пример одного из паттернов. Лучший способ использовать паттерны — запомнить их, а затем научиться распознавать те места ваших архитектур и существующих приложений, где их уместно применить. Таким образом, 
вместо программного кода вы повторно используете чужой опыт.
Знакомство с паттернами
Знание таких концепций, 
как абстракция, наследование и полиморфизм, еще 
не делает из вас хорошего 
ОО-проектировщика. Истинный гуру 
проектирования стремится создавать 
гибкие архитектуры, способные 
адаптироваться к изменениям.
Ваш МОЗГ
Ваш код, улучшенный 
благодаря применению 
паттернов!
Паттерны
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()
// OTHER duck-like methods...
Duck
FlyBehavior flyBehavior;
QuackBehavior quackBehavior;
<<interface>>
FlyBehavior
fly()
fly() {
 // implements duck flying
}
FlyWithWings
fly() {
 // do nothing — can’t fly!
}
FlyNoWay
<<interface>>
QuackBehavior
quack()
quack) {
 // implements duck quacking
}
Quack
quack() {
 // rubber duckie squeak
}
Squeak
quack() {
 // do nothing — can’t quack!
}
MuteQuack
display() {
// looks like a decoy duck }
Decoy Duck
display() {
// looks like a mallard }
Mallard Duck
display() {
// looks like a redhead }
Redhead Duck
display() {
// looks like a rubberduck }
Rubber Duck
Инкапсуляция поведения fly
Инкапсуляция поведения quack
Клиент
Представление
Controller
Модель Запрос
MVC
Subject Object
8
int
Dog Object
Mouse Object
Cat Objec
D
t
uck Object
Наблюдатели
8
8
8
8
Автоматические 
обновления/оповещения
Объект 
состояния
Зависимые 
объекты
НАБЛЮДАТЕЛЬ
Все началось с простого приложения SimUDuck 38
Джо думает о наследовании... 41
Как насчет интерфейса? 42
Единственная константа в программировании 44
Отделяем переменное от постоянного 46
Проектирование переменного поведения 47
Реализация поведения уток 49
Интеграция поведения c классом Duck 51
Тестирование кода Duck 54
Динамическое изменение поведения 56
Инкапсуляция поведения: общая картина 58
Отношения СОДЕРЖИТ бывают удобнее
 отношений ЯВЛЯЕТСЯ 59
Паттерн Стратегия 60
Сила единой номенклатуры 64
Как пользоваться паттернами? 65
Новые инструменты 68
Ответы к упражнениям 69
содержание
12
Обзор приложения Weather Monitoring 73
Как устроен класс WeatherData 74
Знакомство с паттерном Наблюдатель 78
Издатели + Подписчики = Паттерн Наблюдатель 79
Один день из жизни паттерна Наблюдатель 80
Определение паттерна Наблюдатель 85
Паттерн Наблюдатель: диаграмма классов 86
Сила слабых связей 88
Проектирование Weather Station 91
Реализация Weather Station 92
Реализация интерфейса Subject в WeatherData 93
Переходим к визуальным элементам 94
Тестирование Weather Station 95
Обновленный код с использованием лямбда-выражений 101
Новые инструменты 106
Ответы к упражнениям 108
2 Объекты в курсе событий
Вы ведь не хотите оставаться в неведении, когда происходит что-то интересное, верно? У нас есть паттерн, который будет держать ваши объекты в курсе, 
когда происходит нечто такое, что их интересует. Это паттерн Наблюдатель — 
один из наиболее часто встречающихся паттернов проектирования, и он к тому 
же невероятно полезен. Мы рассмотрим многие интересные аспекты паттерна 
Наблюдатель, такие как отношения типа «один ко многим» и слабое связывание. А когда эти концепции запечатлеются у вас в мозгу, вы наверняка станете 
душой вечеринок в сообществе паттернов.
Паттерн Наблюдатель
Субъект
8
int
Объект Dog
Объект Mouse
Объект Ca
О
t
бъект Duck
Наблюдатели
8
8
8
8
ОТНОШЕНИЕ «ОДИН КО МНОГИМ»
Автоматическое
обновление/оповещение
Объект
с состоянием
Зависимые
объекты
Абстракция 
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, 
что изменяется.
Предпочитайте композицию наследованию.
Программируйте на 
уровне интерфейсов.
Стремитесь к слабой 
связанности взаимодействующих объектов.
Принципы
13
3 Украшение объектов
Эту главу можно назвать «Взгляд на архитектуру для любителей наследования». Мы проанализируем типичные злоупотребления из области 
наследования, и вы научитесь декорировать свои классы во время выполнения с использованием разновидности композиции. Зачем? Затем, что 
этот прием позволяет вам наделить свои (или чужие) объекты новыми возможностями без модификации кода классов.
Паттерн Декоратор
Прежде я полагал, что 
настоящие мужчины используют 
только субклассирование. Но 
потом я осознал возможности 
динамического расширения 
на стадии выполнения. 
Посмотрите, каким я стал!
Добро пожаловать в Starbuzz 112
Принцип открытости/закрытости 118
Знакомство с паттерном Декоратор 120
Построение заказанного напитка 121
Определение паттерна Декоратор 123
Декораторы и напитки 124
Пишем код для Starbuzz 127
Программируем классы напитков 128
Программирование дополнений 129
Декораторы в реальном мире: ввод/вывод в языке Java 132
Написание собственного декоратора ввода/вывода 134
Новые инструменты 137
Ответы к упражнениям 138
содержание
14
4 Домашняя ОО-выпечка
Приготовьтесь заняться выпечкой объектов в слабосвязанных ОО-архитектурах. Создание объектов отнюдь не сводится к простому вызову оператора new. Оказывается, создание экземпляров не всегда должно осуществляться открыто; оно часто создает проблемы сильного связывания. 
А ведь вы этого не хотите, верно? Паттерн Фабрика спасет вас от неприятных зависимостей..
Паттерн Фабрика
CreateProductA()
CreateProductB()
<<interface>>
AbstractFactory
Клиент
ProductB1
<<interface>>
AbstractProductB
ProductA1
ProductB2
<<interface>>
AbstractProductA
ProductA2
CreateProductA()
CreateProductB()
ConcreteFactory2
CreateProductA()
CreateProductB()
ConcreteFactory1
Код клиента пишется для абстрактной фабрики, а затем во время выполнения связывается 
с реальной фабрикой.
Конкретные фабрики реализуют разные семейства продуктов. Чтобы создать продукт, клиент использует одну из фабрик, т. е. 
ему никогда не приходится явно создавать экземпляры продуктов.
AbstractFactory определяет интерфейс, который реализуется всеми конкретными фабриками. Интерфейс состоит из методов 
создания продуктов.
Семейство продуктов. 
Каждая конкретная
фабрика может
производить полный
набор продуктов.
Определение изменяемых аспектов 144
Инкапсуляция создания объектов 146
Построение простой фабрики для пиццы 147
Переработка класса PizzaStore 148
Определение Простой Фабрики 149
Принятие решений в субклассах 153
Объявление фабричного метода 157
Пора познакомиться с паттерном Фабричный Метод 163
Параллельные иерархии создателей и продуктов 164
Определение паттерна Фабричный Метод 166
Зависимости между объектами 170
Принцип инверсии зависимостей 171
Применение принципа 172
Семейства ингредиентов 177
Построение фабрик ингредиентов 178
Перерабатываем классы пиццы... 181
Возвращаемся к пиццериям 184
Чего мы добились? 185
Определение паттерна Абстрактная Фабрика 188
Новые инструменты 194
Ответы к упражнениям 195
15
5 Уникальные объекты
Паттерн Одиночка направлен на создание уникальных объектов, существующих только в одном экземпляре. Из всех паттернов Одиночка имеет 
самую простую диаграмму классов; собственно, вся диаграмма состоит 
из одного-единственного класса! Но не стоит расслабляться; несмотря на 
простоту с точки зрения структуры классов, его реализация требует довольно серьезных объектно-ориентированных размышлений. Приготовьтесь пошевелить мозгами — и за дело!
Паттерн Одиночка
Единственный и неповторимый 200
Вопросы и ответы 201
Классическая реализация паттерна Одиночка 203
Признания Одиночки 204
Шоколадная фабрика 205
Определение паттерна Одиночка 207
Кажется, у нас проблемы... 208
Представьте, что вы — JVM 209
Решение проблемы многопоточного доступа 210
Одиночка. Вопросы и ответы 214
Новые инструменты 216
Ответы к упражнениям 217
Стратегия — определяет 
семейство алгоритмов, ин- капсулирует и обеспечива- ет их взаимозаменяемость. 
Паттерн позволяет 
модифицировать алг
Паттерны
Наблюдатель — опреде- ляет отношение “один-комногим” между объектами 
таким образом, что при 
изменении со- стояния одного 
объекта
Decorator — Attach additional responsibilities 
to an object dynamically. 
Decorators provide a flexible 
alternative to subclassing 
for extending functionality.
Абстрактная фабрика — предосталвяет интерфейс 
для создания семейсв взаи- мосвязанных объектов без 
указания конкретных клас- сов.
Фабричный Метод — определяет интерфейс соз- дания объекта, но позво- ляет субклассам выбрать 
создаваемый экземпляр.
Одиночка гарантирует, что класс имеет только 
один экземпляр, и предо- ставляет глобальную точку 
доступа к этому экзем- пляру.
содержание
16
6 Инкапсуляция вызова
В этой главе мы выходим на новый уровень инкапсуляции — на этот раз 
будут инкапсулироваться вызовы методов. Да, все верно — вызывающему объекту не нужно беспокоиться о том, как будут выполняться его запросы. Он просто использует инкапсулированный метод для решения своей 
задачи. Инкапсуляция позволяет решать и такие нетривиальные задачи, 
как регистрация или повторное использование для реализации функции 
отмены в коде.
Паттерн Команда
Автоматизируй дом, или проиграешь 220
Пульт домашней автоматизации 221
Классы управления устройствами 222
Краткое введение в паттерн Команда 225
Рассмотрим взаимодействия чуть более подробно... 226
Роли и обязанности в кафе Объектвиля 227
От кафе к паттерну Команда 229
Наш первый объект команды 231
Определение паттерна Команда 234
Связывание команд с ячейками 237
Реализация пульта 238
Проверяем пульт в деле 240
Пора писать документацию... 243
Пора протестировать кнопку отмены! 248
Реализация отмены с состоянием 249
Реализация отмены в командах управления вентилятором 250
Переходим к тестированию вентилятора 251
На каждом пульте должен быть Режим Вечеринки! 253
Использование макрокоманд 254
Расширенные возможности паттерна Команда:
очереди запросов 257
Расширенные возможности паттерна Команда:
регистрация запросов 258
Новые инструменты 260
Ответы к упражнениям 261
Мне гамбургер
с сыром и молочный
коктейль.
Гамбургер
с сыром
Молочный
коктейль
createOrder()
takeOrder()
Гамбургер
с сыром
Молочный
коктейль
orderUp()
makeBurger(), makeShake()
результат 
Бланк с записью блюд,
заказанных посетителем.
Посетитель просматривает меню 
и создает заказ.
Получив Заказ, Официантка инициирует его
обработку вызовом метода orderUp().
Заказ содержит 
все инструкции,
необходимые для
его выполнения. 
Для передачи распоряжений Повару 
используются вызовы методов вида
makeBurger(). Повар выполняет 
инструкции, со
жащиеся в Заказ
дере,
и готовит блюда.
Начало
17
7 Умение приспосабливаться
В этой главе мы займемся всякими невозможными трюками — будем 
затыкать круглые дырки квадратными пробками. Невозможно, скажете 
вы? Только не с паттернами проектирования. Помните паттерн Декоратор? Мы 
«упаковывали» объекты, чтобы расширить их возможности. А в этой главе мы 
займемся упаковкой объектов с другой целью: чтобы имитировать интерфейс, 
которым они в действительности не обладают. Для чего? Чтобы адаптировать 
архитектуру, рассчитанную на один интерфейс, для класса, реализующего другой интерфейс. Но и это еще не все; попутно будет описан другой паттерн, 
в котором объекты упаковываются для упрощения их интерфейса.
Паттерны Адаптер и Фасад
Адаптеры вокруг нас 266
Объектно-ориентированные адаптеры 267
Как работает паттерн Адаптер 271
Определение паттерна Адаптер 273
Адаптеры объектов и классов 274
Беседа у камина: Адаптер объектов и Адаптер классов 277
Практическое применение адаптеров 278
Адаптация перечисления к итератору 279
Беседа у камина: паттерн Декоратор и паттерн Адаптер 282
Домашний кинотеатр 285
Просмотр фильма (сложный способ) 286
Свет, камера, фасад! 288
Построение фасада для домашнего кинотеатра 291
Реализация упрощенного интерфейса 292
Просмотр фильма (простой способ) 293
Определение паттерна Фасад 294
Принцип минимальной информированности 295
Новые инструменты 300
Ответы к упражнениям 301
Европейская розетка
Стандартная вилка
Адаптер
Адаптируемый объект
Клиент
Адаптер
request() translatedRequest()
Реализация клиента использует 
целевой интерфейс.
Адаптер реализует целевой 
интерфейс и хранит ссылку 
на экземпляр адаптируемого 
объекта.
целевой интерфейс
интерфейс 
адаптируемого 
объекта
TurkeyAdapter 
реализует целевой 
интерфейс Duck.
Адаптируется 
интерфейс 
Turkey.
содержание
18
8 Инкапсуляция алгоритмов
Мы уже «набили руку» на инкапсуляции; мы инкапсулировали создание объектов, вызовы методов, сложные интерфейсы, уток, пиццу... 
Что дальше? Следующим шагом будет инкапсуляция алгоритмических блоков, чтобы субклассы могли в любой момент связаться с нужным алгоритмом 
обработки. В этой главе даже будет описан принцип проектирования, вдохновленный голливудской практикой.
Паттерн Шаблонный Метод
Кофе и чай (на языке Java) 305
Абстрактный кофе и чай 308
Продолжаем переработку... 309
Абстрагирование prepareRecipe() 310
Что мы сделали? 313
Паттерн Шаблонный Метод 314
Готовим чай... 315
Что дает Шаблонный Метод? 316
Определение паттерна Шаблонный Метод 317
Перехватчики в паттерне Шаблонный Метод 320
Голливудский принцип 324
Голливудский принцип и Шаблонный Метод 325
Шаблонные методы на практике 327
Сортировка на базе Шаблонного Метода 328
Сортируем уток... 329
Что делает метод compareTo()? 329
Сравнение объектов Duck 330
Пример сортировки 331
Как сортируются объекты Duck 332
Шаблонный метод в JFrame 334
Специализированные списки и AbstractList 335
Беседа у камина: Шаблонный Метод и Стратегия 336
Новые инструменты 338
Ответы к упражнениям 339
?oi iu naaeaee?
1 Aneeiyoeou aiao
2
3
4
Caaa?eou ?ae a ai?y?ae aiaa
Ia?aeeou ?ae a ?aoeo
Aiaaaeou eeiii
1 Aneeiyoeou aiao
2
3
4
Caaa?eou eioa a ai?y?ae aiaa
Ia?aeeou eioa a ?aoeo
Aiaaaeou naoa? e iieiei
2
4
Caaa?eou ?ae a ai?y?ae aiaa
Aiaaaeou eeiii
Субкласс Tea
Субкласс 
Coffee
2
4
Caaa?eou eioa a ai?y?ae aiaa
Aiaaaeou naoa? e iieiei
1 Aneeiyoeou aiao
2
3
4
Caaa?eou
Ia?aeeou a ?aoeo
Aiaaaeou 
CaffeineBeverage
Tea
Coffee
CaffeineBeverage знает 
последовательность 
действий в рецепте; 
шаги 1 и 3 он выполняет 
самостоятельно, но при 
выполнении шагов 2 и 4 
зависит от классов Tea 
и Coffee.
Мы осознали, что два
рецепта фактически 
совпадают, хотя 
некоторые шаги 
требуют разных
реализаций.
Соответственно мы 
обобщили рецепт 
и вынесли его в базовый
класс.
обобщение
Выполнение 
некоторых шагов зависит от 
субкласса
обобщение
Выполнение 
некоторых 
шагов зависит от субкласса
19
9 Управляемые коллекции
Существует много способов создания коллекций. Объекты можно разместить в контейнере Array, Stack, List, Hashmap — выбирайте сами. Каждый способ обладает своими достоинствами и недостатками. Но в какой-то 
момент клиенту потребуется перебрать все эти объекты, и когда это произойдет, собираетесь ли вы раскрывать реализацию коллекции? Надеемся, нет! Это было бы крайне непрофессионально. В этой главе вы узнаете, как предоставить клиенту механизм перебора объектов без раскрытия 
информации о способе их хранения. Также в ней будут описаны способы 
создания суперколлекций. А если этого недостаточно, вы узнаете кое-что 
новое относительно обязанностей объектов.
Паттерны Итератор и Компоновщик
Бистро объединяется с блинной! 342
Две реализации меню 344
Спецификация официантки с поддержкой Java 346
Как инкапсулировать перебор элементов? 349
Паттерн Итератор 351
Добавление итератора в DinerMenu 352
Переработка DinerMenu с использованием итератора 353
Исправление кода Waitress 354
Тестирование кода 355
Взгляд на текущую архитектуру 357
Интеграция с java.util.Iterator 359
Определение паттерна Итератор 362
Структура паттерна Итератор 363
Принцип одной обязанности 364
Знакомьтесь: интерфейс Iterable языка Java 367
Расширенный цикл for в языке Java 368
Знакомство с классом CafeMenu 371
Итераторы и коллекции 377
Определение паттерна Компоновщик 384
Реализация MenuComponent 388
Реализация MenuItem 389
Реализация комбинационного меню 390
Новые инструменты 399
Ответы к упражнениям 400
PancakeHouseMenu DinerMenu CafeMenu
1 2 3
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
Iai? aeeiiie
MenuItem
MenuItem
MenuItem
MenuItem
Iai? eaoa
key
key
key
key
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Iai? aeno?i
Ana iai?
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Aana?oiia iai?
Коллекция ArrayList,
содержащая все
меню.
Array
ArrayList
Hashtable
содержание
20
10 Состояние дел
Малоизвестный факт: паттерны Стратегия и Состояние — близнецы, 
разлученные при рождении. Можно было бы ожидать, что их жизненные 
пути будут похожими, но паттерну Стратегия удалось построить невероятно успешный бизнес с взаимозаменяемыми алгоритмами, тогда как паттерн Состояние выбрал, пожалуй, более благородный путь – он помогает 
объектам управлять своим поведением за счет изменения своего внутреннего состояния. Но какими бы разными ни были их пути, в их внутренней 
реализации используются практически одинаковые архитектуры. Разве такое возможно? Как вы увидите, Стратегия и Состояние используются для 
совершенно разных целей. Сначала мы присмотримся к паттерну Состояние и разберемся в его сути, а в оставшейся части главы будем изучать 
отношения между этими паттернами.
Паттерн Состояние
Техника на грани фантастики 404
Краткий курс конечных автоматов 406
Программирование 408
Внутреннее тестирование 410
Кто бы сомневался... запрос на изменение! 412
Новая архитектура 416
Определение интерфейса State и классов 417
Реализация классов состояний 419
Переработка класса GumballMachine 420
А теперь полный код класса GumballMachine... 421
Реализация других состояний 422
Определение паттерна Состояние 428
Реализация игры «1 из 10» 431
Завершение реализации игры 432
Демоверсия для начальства 433
Проверка разумности 435
Новые инструменты 441
Ответы к упражнениям 442
Mighty Gumball, Inc.
Машина с жевательной
резинкой не бывает 
полупустой
Как нам кажется, контроллер автомата должен 
работать примерно так. Надеемся, вы реализуете 
эту схему на Java! Возможно, в будущем в нее будет 
добавлено новое поведение; постарайтесь сделать 
архитектуру гибкой и простой в сопровождении!
 — Инженеры Mighty Gumball
Нет
шариков
Есть
монетка
Нет
монетки
Шарик
продан
бросить
монетку
вернуть 
монетку де
за рычаг
рнуть
выдать 
шарик
шарики = 0
шарики > 0
21
11 Управление доступом к объектам
Когда-нибудь разыгрывали сценку «хороший полицейский, плохой полицейский»? Вы — «хороший полицейский», вы общаетесь со всеми любезно и по-дружески, но не хотите, чтобы все обращались к вам по каждому пустяку. Поэтому вы обзаводитесь «плохим полицейским», который 
управляет доступом к вам. Именно этим и занимаются заместители: они 
управляют доступом. Как вы вскоре увидите, существует множество способов взаимодействия заместителей с обслуживаемыми объектами. Иногда 
заместители пересылают по интернету целые вызовы методов, а иногда 
просто терпеливо стоят на месте, изображая временно отсутствующие 
объекты.
Паттерн Заместитель
<<interface>>
Subject
request()
RealSubject
request()
Proxy
request()
<<interface>>
InvocationHandler
invoke()
InvocationHandler
Теперь заместитель
состоит из двух 
классов.
Заместитель генерируется 
на уровне Java и реализует
весь интерфейс Subject. Вы предоставляете класс InvocationHandler,
которому передаются все вызовы методов 
Proxy. InvocationHandler управляет 
доступом к методам RealSubject.
invoke()
Программирование монитора 449
Тестирование монитора 450
Роль «удаленного заместителя» 452
Включение удаленного заместителя
 в код мониторинга GumballMachine 454
Регистрация в реестре RMI... 470
Определение паттерна Заместитель 477
Знакомьтесь: Виртуальный Заместитель 479
Отображение обложек альбомов 480
Класс ImageProxy 482
Создание защитного заместителя средствами Java API 491
Знакомства для гиков 492
Реализация Person 493
Общая картина: динамический заместитель для Person 496
Тестирование службы знакомств 501
Запуск кода... 502
Разновидности заместителей 504
Новые инструменты 506
Код просмотра обложек альбомов 509
содержание
22
12 Паттерны паттернов
Кто бы мог предположить, что паттерны порой работают рука об руку?
Вы уже были свидетелями ожесточенных перепалок в «Беседах у камина» 
(причем вы не видели «Смертельные поединки» паттернов — редактор заставил нас исключить их из книги!). И после этого оказывается, что мирное 
сосуществование все же возможно. Хотите верьте, хотите нет, но некоторые из самых мощных ОО-архитектур строятся на основе комбинаций нескольких паттернов.
Составные паттерны
Совместная работа паттернов 514
И снова утки 515
Диаграмма классов с высоты утиного полета 538
Паттерны проектирования — ключ к MVC 540
MVC как набор паттернов 544
Использование MVC для управления ритмом... 546
Построение компонентов 549
Представление 551
Анализ паттерна Стратегия 557
Адаптация модели 558
Можно переходить к HeartController 559
Новые инструменты 563
Ответы к упражнениям 564
Готовый код 567
BeatModel
Контроллер
setBPM()
getBPM()
on()
off()
Щелкните на 
кнопке увеличения...
Контроллер 
приказывает 
модели увеличить 
частоту на 1.
Представление оповещается
об изменении частоты. Оно 
вызывает метод getBPM() 
для получения состояния модели.
Так как установлена частота
120 BPM, представление
получает оповещения каждые
1/2 секунды.
Генерируется ритм 
с частотой 119 BPM; вы 
хотите увеличить его до 120.
...это приводит к активизации 
контроллера.
Представление обновляется
новым значением 120 BPM.
Полоса пульсирует
каждые 1/2 секунды.
Представление
Представление
23
13 Паттерны в реальном мире
Вы стоите на пороге дивного нового мира, населенного паттернами 
проектирования. Но прежде чем открывать дверь, желательно изучить 
некоторые технические тонкости, с которыми вы можете столкнуться, — 
в реальном мире жизнь немного сложнее, чем здесь, в Объектвиле. К счастью, у вас имеется хороший путеводитель, который упростит ваши первые 
шаги...
Паттерны для лучшей жизни
«Банда Четырех»
Ричард Хелм
Эрик Гамма
Джон Влиссидес
Ральф Джонсон
Руководство
по эффективному
использованию паттернов
Вашему вниманию предлагается руководство с полезными
советами, которые помогут вам использовать паттерны
в реальном программировании. В этом руководстве вы
 познакомитесь с распространенными заблуждениями
относительно определения «паттерна проектирования»;
 узнаете, что такое каталоги паттернов и для чего они
нужны;
 обойдете неприятности, связанные с несвоевременным
использованием паттернов;
 изучите классификацию паттернов;
 увидите, что построение паттернов доступно не только
экспертам; прочитайте нашу краткую сводку правил,
и вы тоже сможете создавать свои паттерны;
 узнаете состав таинственной «Банды Четырех»;
 научитесь тренировать свой разум, как истинный мастер
Дзен;
 освоите основную терминологию паттернов.
Определение паттерна проектирования 583
Подробнее об определении паттерна
 проектирования 585
Хотите создавать паттерны? 591
Классификация паттернов проектирования 593
Мыслить паттернами 598
Разум и паттерны 601
Разум новичка 601
Просветленный разум 601
Разум опытного разработчика 601
И не забудьте о единстве номенклатуры 603
Прогулка по Объектвилю с «Бандой Четырех» 605
Наше путешествие только начинается... 606
Разновидности паттернов 608
Антипаттерны и борьба со злом 610
Новые инструменты 612
Покидая Объективиль... 613
содержание
24
14 Приложение: Другие паттерны
Не каждому суждено оставаться на пике популярности. За последние 
10 лет многое изменилось. С момента выхода первого издания книги «Банды 
Четырех» разработчики тысячи раз применяли эти паттерны в своих проектах. В этом приложении представлены полноценные, первосортные паттерны от «Банды Четырех» — они используются реже других паттернов, которые рассматривались ранее. Однако эти паттерных ничем не плохи, и если 
они уместны в вашей ситуации — применяйте их без малейших сомнений. 
В этом приложении мы постараемся дать общее представление о сути этих 
паттернов.
Мост 616
Строитель 618
Цепочка Обязанностей 620
Приспособленец 622
Интерпретатор 624
Посредник 626
Хранитель 628
Прототип 630
Посетитель 632
MenuItem
Menu
Ingredient
MenuItem
Ingredient
Visitor
 Client / 
Traverser
getState()
getState()
getState()
getState()
getState()
getHealthRating()
getCalories()
getProtein()
getCarbs()
Этим классам 
остается лишь
добавить метод 
getState().
Клиент запрашивает 
у посетителя информацию 
из составной структуры... 
Новые методы включаются 
в Посетитель без изменения 
составной структуры.
Посетитель вызывает методы 
getState() разных классов; именно 
здесь добавляются новые методы,
используемые клиентом.
Traverser знает, как
управлять действиями 
посетителя с составной 
структурой.
Введение
как работать с этой книгой 
Не могу поверить,
что они включили
такое в книгу
о паттернах!
Вам нравится?
Книга стоит 
денег, которые вы 
заплатили за нее, 
и станет лучшим 
подарком.
В этом разделе мы ответим на важный вопрос:
«Почему они включили ТАКОЕ в книгу о паттернах?»
26 введение
как работать с этой книгой
Для кого написана эта книга?
1 Вы знаете Java или другой объектно-ориентированный 
язык? (Быть знатоком не обязательно.)
2 Вы хотите изучить, понять, запомнить и применять паттерны, 
а также принципы ОО-проектирования, на которых основаны 
паттерны?
...то эта книга для вас.
Кому эта книга не подойдет?
1 Вы абсолютно ничего не знаете об объектно-ориентированном 
программировании?
4
...эта книга не для вас.
Вы боитесь попробовать что-нибудь новое? Скорее пойдете 
к зубному врачу, чем наденете полосатое с клетчатым? Считаете, что 
техническая книга, в которой компоненты Java изображены в виде 
человечков, серьезной быть не может?
Если вы ответите «да» на все следующие вопросы...
Если вы ответите «да» на любой из следующих вопросов...
2 Вы — крутой ОО-проектировщик/разработчик, которому нужен 
справочник?
[Заметка от отдела продаж: 
вообще-то эта книга для любого, 
у кого есть деньги.]
3 Вы предпочитаете оживленную беседу сухим, 
скучным академическим лекциям?
3 Вы занимаетесь архитектурным проектированием и ищете 
информацию о паттернах корпоративного уровня?
Все примеры написаны 
на Java, но вы сможете 
понять основные концепции книги, если знаете другой объектноориентированный язык. 
введение
дальше  27
«Разве серьезные книги по программированию такие?»
«И почему здесь столько рисунков?»
«Можно ли так чему-нибудь научиться?»
Мы знаем, о чем вы думаете
Мозг жаждет новых впечатлений. Он постоянно ищет, анализирует, ожидает чего-то необычного. Он так устроен, и это помогает нам выжить. 
В наши дни вы вряд ли попадете на обед к тигру. Но наш мозг постоянно остается настороже. Просто мы об этом не знаем.
Как же наш мозг поступает со всеми обычными, повседневными 
вещами? Он всеми силами пытается оградиться от них, чтобы 
они не мешали его настоящей работе — сохранению того, что 
действительно важно. Мозг не считает нужным сохранять скучную информацию. Она не проходит фильтр, отсекающий «очевидно несущественное».
Но как же мозг узнает, что важно? Представьте, что вы выехали 
на прогулку и вдруг прямо перед вами появляется тигр. Что происходит в вашей голове и в теле? 
Активизируются нейроны. Вспыхивают эмоции. Происходят 
химические реакции. 
И тогда ваш мозг понимает...
Конечно, это важно! Не забывать!
А теперь представьте, что вы находитесь дома или в библиотеке, в теплом, уютном месте, где тигры не водятся. Вы учитесь — готовитесь к экзамену. Или пытаетесь освоить сложную техническую тему, на которую вам выделили неделю... 
максимум десять дней.
И тут возникает проблема: ваш мозг пытается оказать вам услугу. Он старается сделать так, чтобы на эту очевидно несущественную информацию не тратились драгоценные ресурсы. 
Их лучше потратить на что-нибудь важное. На тигров, например. Или на то, что к огню лучше не прикасаться. Или 
что на лыжах не стоит кататься в футболке и шортах.
Нет простого способа сказать своему мозгу: «Послушай, мозг, 
я тебе, конечно, благодарен, но какой бы скучной ни была эта 
книга, и пусть мой датчик эмоций сейчас на нуле, я хочу запомнить то, что здесь написано».
И мы знаем, о чем думает ваш мозг
Ваш мозг считает, 
что ЭТО важно.
Замечательно.
Еще 614 сухих,
скучных страниц. Ваш мозг полагает, 
что ЭТО можно
не запоминать.
как работать с этой книгой
28 введение
Как мы что-то узнаем? Сначала нужно это «что-то» понять, а потом не забыть. 
Затолкать в голову побольше фактов недостаточно. Согласно новейшим исследованиям в области когнитивистики, нейробиологии и психологии обучения, для 
усвоения материала требуется что-то большее, чем простой текст на странице. 
Мы знаем, как заставить ваш мозг работать.
Основные принципы серии «Head First»:
Наглядность. Графика запоминается гораздо лучше, чем обычный 
текст, и значительно повышает эффективность восприятия информации (до 89% по данным исследований). Кроме того, материал 
становится более понятным. Текст размещается на рисунках, 
к которым он относится, а не под ними или на соседней странице. 
Разговорный стиль изложения. Недавние исследования показали, что 
при разговорном стиле изложения материала (вместо формальных лекций) улучшение результатов на итоговом тестировании составляло до 40%. 
Рассказывайте историю вместо того, чтобы читать лекцию. Не относитесь 
к себе слишком серьезно. Что скорее привлечет ваше внимание: занимательная беседа за столом или лекция?
Активное участие читателя. Пока вы не начнете напрягать извилины, в вашей голове ничего не произойдет. Читатель должен быть заинтересован в результате; он должен 
решать задачи, формулировать выводы и овладевать 
новыми знаниями. А для этого необходимы упражнения 
и каверзные вопросы, в решении которых задействованы 
оба полушария мозга и разные чувства.
Привлечение (и сохранение) внимания читателя. Ситуация, знакомая каждому: «Я очень хочу 
изучить это, но засыпаю на первой странице». Мозг 
обращает внимание на интересное, странное, притягательное, неожиданное. Изучение сложной технической темы 
не обязано быть скучным. Интересное узнается намного быстрее.
Обращение к эмоциям. Известно, что наша способность запоминать в значительной 
мере зависит от эмоционального сопереживания. Мы запоминаем то, что нам небезразлично. Мы запоминаем, когда что-то чувствуем. Нет, сентименты здесь ни при чем: речь 
идет о таких эмоциях, как удивление, любопытство, интерес и чувство «Да я крут!», 
при решении задачи, которую окружающие считают сложной, — или когда вы понимаете, что разбираетесь в теме лучше, чем всезнайка Боб из технического отдела.
Эта книга для тех, кто хочет учиться.
doCalc()
Возвращаемое значение
Вызывает метод на сервере.
Сервер
выполняет
удаленный
метод. 
Плохо быть абстрактным методом. Приходится обходиться без 
тела.
 abstract void roam();
У метода нет тела!
Не забудьте поставить 
точку с запятой.
Можно ли сказать, что 
мыло СОДЕРЖИТ пену? 
Или это отношение типа 
«является частным случаем»?
введение
дальше  29
Если вы действительно хотите быстрее и глубже усваивать новые знания — задумайтесь над тем, как вы задумываетесь. Учитесь учиться.
Мало кто из нас изучает теорию метапознания во время учебы. Нам положено учиться, но нас редко этому учат.
Но раз вы читаете эту книгу, то вероятно, вы хотите изучить паттерны 
проектирования, и по возможности быстрее. Вы хотите запомнить прочитанное и применять новую информацию на практике. Чтобы извлечь 
максимум пользы из учебного процесса, нужно заставить ваш мозг воспринимать новый материал как Нечто Важное. Критичное для вашего 
существования. Такое же важное, как тигр. Иначе вам предстоит бесконечная борьба с вашим мозгом, который всеми силами уклоняется от запоминания новой информации.
Метапознание: наука о мышлении
Как бы теперь
заставить мой мозг
все это запомнить...
Как же УБЕДИТЬ мозг, что паттерны проектирования 
так же важны, как и тигр?
Есть способ медленный и скучный, а есть быстрый и эффективный. Первый основан на тупом повторении. Всем 
известно, что даже самую скучную информацию можно запомнить, 
если повторять ее снова и снова. При достаточном количестве повторений ваш мозг прикидывает: «Вроде бы несущественно, но раз одно и то же 
повторяется столько раз... Ладно, уговорил».
Быстрый способ основан на повышении активности мозга, и особенно на 
сочетании разных ее видов. Доказано, что все факторы, перечисленные на 
предыдущей странице, помогают вашему мозгу работать на вас. Например, 
исследования показали, что размещение слов внутри рисунков (а не в подписях, в основном тексте и т. д.) заставляет мозг анализировать связи между 
текстом и графикой, а это приводит к активизации большего количества нейронов. Больше нейронов = выше вероятность того, что информация будет 
сочтена важной и достойной запоминания.
Разговорный стиль тоже важен: обычно люди проявляют больше внимания, 
когда они участвуют в разговоре, так как им приходится следить за ходом беседы и высказывать свое мнение. Причем мозг совершенно не интересует, 
что вы «разговариваете» с книгой! С другой стороны, если текст сух и формален, то мозг чувствует то же, что чувствуете вы на скучной лекции в роли 
пассивного участника. Его клонит в сон.
Но рисунки и разговорный стиль — это только начало.
30 введение
как работать с этой книгой
Мы использовали рисунки, потому что мозг лучше приспособлен для восприятия графики, чем текста. С точки зрения мозга рисунок стоит 1024 слов. А когда 
текст комбинируется с графикой, мы внедряем текст прямо в рисунки, потому 
что мозг при этом работает эффективнее.
Мы используем избыточность: повторяем одно и то же несколько раз, применяя 
разные средства передачи информации, обращаемся к разным чувствам — и все 
для повышения вероятности того, что материал будет закодирован в нескольких 
областях вашего мозга.
Мы используем концепции и рисунки несколько неожиданным образом, потому 
что мозг лучше воспринимает новую информацию. Кроме того, рисунки и идеи 
обычно имеют эмоциональное содержание, потому что мозг обращает внимание на 
биохимию эмоций. То, что заставляет нас чувствовать, лучше запоминается — будь 
то шутка, удивление или интерес.
Мы используем разговорный стиль, потому что мозг лучше воспринимает информацию, когда вы участвуете в разговоре, а не пассивно слушаете лекцию. Это происходит и при чтении.
В книгу включены более 90 упражнений, потому что мозг лучше запоминает, когда вы работаете самостоятельно. Мы постарались сделать их непростыми, но интересными — то, что предпочитает большинство читателей.
Мы совместили несколько стилей обучения, потому что одни читатели любят пошаговые описания, другие стремятся сначала представить «общую картину», а третьим хватает фрагмента кода. Независимо от ваших личных предпочтений, полезно видеть несколько вариантов представления одного материала.
Мы постарались задействовать оба полушария вашего мозга; это повышает вероятность усвоения материала. Пока одна сторона мозга работает, другая часто имеет 
возможность отдохнуть; это повышает эффективность обучения в течение продолжительного времени.
А еще в книгу включены истории и упражнения, отражающие другие точки зрения. Мозг качественнее усваивает информацию, когда ему приходится оценивать 
и выносить суждения.
В книге часто встречаются вопросы, на которые не всегда можно дать простой 
ответ, потому что мозг быстрее учится и запоминает, когда ему приходится чтото делать. Невозможно накачать мышцы, наблюдая за тем, как занимаются другие. 
Однако мы позаботились о том, чтобы усилия читателей были приложены в верном направлении. Вам не придется ломать голову над невразумительными примерами или разбираться в сложном, перенасыщенном техническим жаргоном или 
слишком лаконичном тексте.
Мы руководствовались принципом 80/20. Для серьезного изучения одной книги 
все равно недостаточно, поэтому мы не пытались рассказать обо всем. Речь пойдет только о самом необходимом.
Вот что сделали МЫ
Гуру Паттернов
Subject Object
8
int
Объект Dog
Объект Mouse
Объект Ca
О
t
бъект Duck
Наблюдатели
8
8
8
8
отношение «один ко многим»
Автоматическое 
обновление/оповещение
Объект 
состояния 
Зависимые
объекты
Головоломки
КЛЮЧЕВЫЕ 
МОМЕНТЫ
введение
дальше  31
Мы свое дело сделали. Остальное за вами. Эти советы станут 
отправной точкой; прислушайтесь к своему мозгу и определите, что вам подходит, а что не подходит. Пробуйте новое.
Что можете сделать ВЫ, чтобы 
заставить свой мозг повиноваться
1 Не торопитесь. Чем больше вы поймете, тем 
меньше придется запоминать.
Просто читать недостаточно. Когда книга задает вам вопрос, не переходите к ответу. Представьте, что кто-то действительно задает вам вопрос. Чем глубже 
ваш мозг будет мыслить, тем скорее вы 
поймете и запомните материал.
2 Выполняйте упражнения, делайте заметки.
Мы включили упражнения в книгу, но выполнять их за вас не собираемся. И не разглядывайте упражнения. Берите карандаш и пишите. Физические действия во время учения 
повышают его эффективность.
3 Читайте врезки.
Это значит: читайте всё. Врезки — часть основного материала! Не пропускайте их.
4 Не читайте другие книги после этой перед сном.
Часть обучения (особенно перенос информации в долгосрочную память) происходит после того, как вы откладываете книгу. Ваш мозг 
не сразу усваивает информацию. Если во время обработки поступит новая информация, 
часть того, что вы узнали ранее, может быть 
потеряна.
5 Пейте воду. И побольше.
Мозг лучше всего работает в условиях высокой влажности. Дегидратация (которая может наступить еще до того, как вы почувствуете жажду) снижает когнитивные функции. 
6 Говорите вслух.
Речь активизирует другие участки мозга. 
Если вы пытаетесь что-то понять или получше запомнить, произнесите вслух. А еще лучше — попробуйте объяснить кому-нибудь другому. Вы будете быстрее усваивать материал 
и, возможно, откроете для себя что-то новое.
7 Прислушивайтесь к своему мозгу.
Следите за тем, когда ваш мозг начинает уставать. Если вы начинаете поверхностно воспринимать материал или забываете только 
что прочитанное — пора сделать перерыв.
9 Проектируйте!
Примените новые знания к проекту, над которым вы работаете, или переделайте старый 
проект. Просто сделайте хоть что-нибудь, чтобы приобрести практический опыт за рамками упражнений. Все, что для этого нужно, — 
это карандаш и подходящая задача.
Вырежьте и прикрепите 
на холодильник.
8 Чувствуйте!
Ваш мозг должен знать, что материал книги 
действительно важен. Переживайте за героев 
наших историй. Придумывайте собственные 
подписи к фотографиям. Поморщиться над 
неудачной шуткой все равно лучше, чем не 
почувствовать ничего.
32 введение
как работать с этой книгой
Примите к сведению
Director
getMovies
getOscars()
getKevinBaconDegrees()
Упрощенный 
псевдо-UML.
Это учебник, а не справочник. Мы намеренно убрали из книги все, что могло 
бы помешать изучению материала, над которым вы работаете. И при первом 
чтении книги начинать следует с самого начала, потому что книга предполагает наличие у читателя определенных знаний и опыта.
Мы используем упрощенную и слегка измененную версию UML. 
Скорее всего, вы уже сталкивались с UML, но знание UML не является строго обязательным для восприятия материала. Если вы никогда не имели дела 
с UML, не огорчайтесь, в книге попутно приводятся краткие пояснения. Иначе говоря, вам не придется одновременно думать о паттернах проектирования и о UML. Наши диаграммы правильнее назвать «UML-подобными»; мы 
пытаемся соблюдать правила UML, но время от времени слегка нарушаем их 
(обычно из эстетических соображений). 
Мы не описываем все когда-либо созданные паттерны.
Существует много разных паттернов проектирования: исходные основополагающие паттерны (называемые паттернами GoF), корпоративные паттерны 
Java, архитектурные паттерны, паттерны игрового проектирования и другие. 
Мы постарались глубоко и содержательно представить важнейшие паттерны 
из числа базовых. Другие паттерны (значительно реже применяемые на практике) описаны в приложении. Впрочем, после прочтения книги вы сможете 
взять любой справочник паттернов и легко освоить незнакомые темы.
Упражнения ОБЯЗАТЕЛЬНЫ. 
Упражнения являются частью основного материала книги. Одни упражнения 
способствуют запоминанию материала, другие помогают лучше понять его, 
третьи ориентированы на его практическое применение. Не пропускайте 
упражнения. 
введение
дальше  33
Повторение применяется намеренно. 
У книг этой серии есть одна принципиальная особенность: мы хотим, чтобы 
вы действительно хорошо усвоили материал. И чтобы вы запомнили все, что узнали. Большинство справочников не ставит своей целью успешное запоминание, 
но это не справочник, а учебник, поэтому некоторые концепции излагаются 
в книге по несколько раз.
Примеры кода были сделаны по возможности компактными.
Наши читатели не любят просматривать по 200 строк кода, чтобы найти две 
нужные строки. Большинство примеров книги приводится в минимальном 
контексте, чтобы та часть, которую вы непосредственно изучаете, была понятной и простой. Не ждите, что весь код будет стопроцентно устойчивым или 
даже просто завершенным, — примеры написаны в учебных целях и не всегда 
являются полнофункциональными.
Иногда в примеры не включаются все необходимые директивы импорта; любой Java-программист должен знать, что ArrayList находится в пакете java.util. Если директивы импорта не являются частью базового 
JSE API, мы упоминаем об этом в тексте. Кроме того, весь исходный код 
примеров размещен на веб-сайте. Вы можете загрузить его по адресу 
http://wickedlysmart.com/head-first-design-patterns/
Чтобы сосредоточиться на учебной стороне кода, мы не стали размещать наши 
классы в пакетах (иначе говоря, все они находятся в Java-пакете по умолчанию). 
В реальных приложениях так поступать не рекомендуется. Загрузив примеры 
кода с сайта, вы увидите, что в них все классы размещены в пакетах.
Упражнения «Мозговой штурм» не имеют ответов.
В некоторых из них правильного ответа вообще нет, в других вы должны сами 
решить, насколько правильны ваши ответы (это является частью процесса обучения). В некоторых упражнениях «Мозговой штурм» приводятся подсказки, 
которые помогут вам найти нужное направление.
34 введение
Рецензенты
редакторы первого издания
Джеф Кампс 
Джейсон Менар
Дирк Шрекман
Барни Мариспини
Валентин Креттас
Айк Ван Атта
Марк Спритцлер
Йоханнес де Йонг
Бесстрашный предводитель группы 
HFDP Extreme
Review Team
Филипп Маке
Памяти Филиппа Маке, 1960–
2004. Твои выдающиеся технические знания, энтузиазм и искренняя 
забота об учениках всегда будут 
вдохновлять нас.
дальше  35
редакторы второго издания
Сотрудникам издательства O’Reilly
Прежде всего мы благодарны Майку Лукидесу из O’Reilly за то, что он предложил исходную идею и помог преобразовать концепцию книг «Head First» в серию. Большое спасибо Тиму О’Рейли, вдохновителю серии «Head First». Спасибо «покровительнице» серии Кайл Харт, звезде рок-н-ролла Элли Фолькхаузен за творческий дизайн обложки и Колин Горман за бескомпромиссное редактирование. Также 
мы благодарим Майка Хендриксона за предложение написать книгу о паттернах проектирования и за 
подбор команды.
Нашим бесстрашным рецензентам
Мы чрезвычайно благодарны руководителю группы технического рецензирования Йоханнесу де 
Йонгу. Йоханнес, ты — наш герой. Также мы глубоко ценим вклад соуправляющего группы рецензирования Javaranch, покойного Филиппа Маке. Своими усилиями он облегчил жизнь тысячам разработчиков.
Джеф Кампс превосходно справляется с поиском недостатков в черновых вариантах глав. И на этот 
раз его замечания снова заметно повлияли на книгу. Спасибо, Джеф! Валентин Креттас (специалист 
по АОП), работавший с нами с самой первой книги из серии «Head First», доказал, насколько нам необходим его технический опыт и понимание сути вещей. Два новых участника группы рецензирования — 
Барни Мариспини и Айк Ван Атта — отлично справились со своей работой. 
Кроме того, мы получили замечательную техническую поддержку от модераторов/гуру Javaranch Марка Спритцлера, Джейсона Менара, Дирка Шрекмана, Томаса Пола и Маргариты Исаевой. И как 
всегда, спасибо «начальнику» javanranch.com Полу Уитону.
Спасибо всем участникам конкурса на оформление обложки книги. Победитель конкурса Си Брюстер написал очерк, который убедил нас выбрать женский портрет, изображенный на обложке.
В подготовке обновленной версии книги за 2014 год нам помогали научные редакторы: Джордж Хоффер (George Hoffer), Тед Хилл (Ted Hill), Тодд Бартошкевич (Todd Bartoszkiewicz), Сильвен Тенье (Sylvain 
Tenier), Скотт Дэвидсон (Scott Davidson), Кевин Райан (Kevin Ryan), Рич Уорд (Rich Ward), Марк Фрэнсис 
Ягер (Mark Francis Jaeger), Марк Масс (Mark Masse), Гленн Рэй (Glenn Ray), Баярд Фетлер (Bayard Fetler), 
Пол Хиггинс (Paul Higgins), Мэтт Карпентер (Matt Carpenter), Джулия Уильямс (Julia Williams), Мэтт Маккалох (Matt McCullough) и Мэри Энн Белармино (Mary Ann Belarmino).
Триша Джи
Благодарности
Научные редакторы второго издания
Джулиан Сетьяван
Дэвид Пауэрс
Джордж Хайнеман
Главный специалист среди 
редакторов 2-го издания
36 введение
и снова благодарности
Благодарности для второго издания
Издательству O’Reilly
Прежде всего мы благодарны Мэри Треселер (Mary Treseler) — супергероине, без которой бы ничего 
этого не случилось. Мы навечно благодарны ей за все, что она делает для O’Reilly, Head First и авторов. 
Мелисса Даффилд (Melissa Duffield) и Майкл Кронин (Michael Cronin) устранили многие препятствия 
на пути второго издания. Рэйчел Монахан (Rachel Monaghan) блестяще справилась с редактурой, отчего наш текст заиграл новыми красками. Кристен Браун (Kristen Brown) позаботилась о том, чтобы книга 
хорошо смотрелась в печатном и в электронном виде. Элли Волкхаузен (Ellie Volckhausen) оформила 
великолепную новую обложку для второго издания. Спасибо всем!
Редакторам второго издания
Мы благодарны техническим редакторам второго издания, которые продолжили работу, начатую 15 лет 
назад. Дэвид Пауэрс (David Powers) — первый, к кому мы обращаемся за редактурой (он наш, даже не думайте предлагать ему редактировать вашу книгу), потому что он не упускает ни одной мелочи. Джордж 
Хайнеман (George Heineman) делал все возможное и невозможное своими подробными комментариями, рекомендациями и обратной связью; он получает премию главного технического специалиста среди 
редакторов книги. Триша Джи (Trisha Gee) и Джулиан Сетьяван (Julian Setiawan) предоставили бесценную информацию, которая позволила нам избежать неловких и постыдных ошибок Java. Спасибо всем!
Особые благодарности
Хотим особо поблагодарить Эрика Гамму — его труды по рецензированию книги вышли далеко за рамки 
служебных обязанностей (он даже взял черновик в отпуск). Эрик, твой интерес к книге вдохновлял нас, 
а доскональный технический анализ принес неизмеримую пользу. Спасибо всей «Банде Четырех» за 
поддержку и интерес, а также за их появление в Объектвиле. Мы также многим обязаны Уорду Каннингему и участникам сообщества паттернов, создателям Портлендского хранилища паттернов — бесценного источника информации для написания книги.
Майк Лукидес, Майк Хендриксон и Мэган Бланшетт, огромное вам спасибо. Майк Л. сопровождал нас 
на каждом шагу этого пути. Его проницательные комментарии способствовали формированию концепции книги, а поддержка помогала нам двигаться вперед. Майк Х. целых пять лет уговаривал нас написать 
книгу о паттернах; мы рады тому, что книга была опубликована именно в серии «Head First». 
В завершение хотим особо поблагодарить всю группу рецензирования Javaranch за прекрасную работу 
и поддержку. Эта книга обязана вам б?ольшим, чем вы думаете.
Мы бы не справились с написанием книги из серии Head First, если бы не двое наших замечательных 
проводников: Кэти Сьерра и Берт Бэйтс. Они помогли нам отбросить все традиционные представления о написании книг и войти в мир занимательных историй, теории обучения, когнитивистики и попкультуры, в котором читатель всегда стоит на первом месте.
Наверняка вашу задачу кто-то уже решал. В этой главе вы узнаете, 
почему (и как) следует использовать опыт других разработчиков, которые уже 
сталкивались с аналогичной задачей и успешно решили ее. Заодно мы поговорим об использовании и преимуществах паттернов проектирования, познакомимся с ключевыми принципами объектно-ориентированного (ОО) проектирования и разберем пример одного из паттернов. Лучший способ использовать 
паттерны — запомнить их, а затем научиться распознавать те места ваших 
архитектур и существующих приложений, где их уместно применить. Таким 
образом, вместо программного кода вы повторно используете чужой опыт.
Добро пожаловать 
 в мир паттернов
1 Знакомство с паттернами
Теперь, когда мы переселились 
в Объектвиль, мы просто 
обязаны заняться паттернами 
проектирования... Сейчас это так 
модно! В группе Джима и Бетти
все только и будут
говорить о нас. 
38 глава 1
Все началось с простого приложения SimUDuck
Джо работает на компанию, выпустившую чрезвычайно 
успешный имитатор утиного пруда. В этой игре представлен пруд, в котором плавают и крякают утки разных видов. 
Проектировщики системы воспользовались стандартным 
приемом ООП и определили суперкласс Duck, на основе которого объявляются типы конкретных видов уток.
Duck
quack()
swim()
display()
// ДРУГИЕ общие методы...
display() {
// Конкретная версия 
// для MallardDuck }
MallardDuck
display() {
// Конкретная версия
// для RedheadDuck }
RedheadDuck Другие типы уток, 
производные от класса 
Duck. 
Подтип каждой 
конкретной разновидности реализует 
свою специфическую 
версию display().
Все утки умеют крякать 
(quack) и плавать (swim); 
суперкласс предоставляет код обобщенной реализации.
За последний год компания испытывала жесткое давление со стороны конкурентов. Через неделю долгих выездных совещаний за игрой в гольф руководство компании решило, что пришло время серьезных изменений. 
Нужно сделать что-то действительно впечатляющее, что 
можно было бы продемонстрировать на предстоящем собрании акционеров на следующей неделе.
Метод display() объявлен абстрактным, 
потому что все 
подтипы отображаются по-разному.
SimUDuck
знакомство с паттернами
дальше   39
Джо
Я добавлю метод 
fly() в класс Duck, 
и он будет унаследован всеми 
производными классами. Пора 
продемонстрировать мои 
таланты в области ООП.
Все субклассы 
наследуют fly().
Это добавил Джо.
Начальство решило, что летающие утки — именно та «изюминка», которая сокрушит всех конкурентов. И конечно, пообещало, что Джо легко соорудит что-нибудь этакое в течение 
недели. «В конце концов, он ООП-программист... Какие могут 
быть трудности?»
Теперь утки будут ЛЕТАТЬ
Другие виды уток... 
Duck
quack()
swim()
display()
fly()
// ДРУГИЕ методы...
display() {
// Конкретная версия
// для MallardDuck }
MallardDuck
display() {
// Конкретная версия
// для ReadheadDuck }
RedheadDuck
Чего мы
добиваемся.
40 глава 1
Казалось бы, в этой 
ситуации наследование 
идеально подходит для 
повторного использования кода —
но с сопровождением
возникают проблемы. 
В моей иерархии есть 
небольшой просчет.
А вообще симпатично 
получилось... Может,
сделать вид, что так
и было задумано?
Джо, я на собрании акционеров. 
В демоверсии по экрану летают 
резиновые утки. Это что, шутка 
такая? На премию можешь 
не рассчитывать...
Джо не сообразил, что летать
должны не все субклассы Duck. 
Новое поведение, добавленное 
в суперкласс Duck, оказалось неподходящим для некоторых субклассов. И теперь в программе 
начали летать неодушевленные 
объекты.
Локальное изменение кода привело 
к нелокальному побочному эффекту 
(летающие резиновые утки!).
Что произошло? 
quack()
swim()
display()
fly()
// ДРУГИЕ общие методы...
display() {
// Конкретная версия
// для MallardDuck }
MallardDuck
display() {
// Конкретная версия
// для RedheadDuck }
RedheadDuck
quack() {
 // Переопределение
}
display() {
// Конкретная версия
// для Rubberduck }
RubberDuck
Duck
Резиновые утки не 
крякают, поэтому 
метод quack() переопредеделяется.
При размещении fly() 
в суперклассе летать 
начинают ВСЕ утки, 
включая тех, которые 
летать явно не должны.
Но тут все пошло наперекосяк...
что-то сделано не так
дальше   41
знакомство с паттернами
Джо думает о наследовании...
Я всегда могу 
переопределить метод
fly() в классе RubberDuck, 
по аналогии с quack() ...
quack() { // Squeak}
display() { // RubberDuck }
fly() {
 // Пустое
 // переопределение
 // ничего не делает }
RubberDuck
? A. Дублирование кода в субклассах.
? B. Трудности с изменением поведения на стадии выполнения.
? C. Уток нельзя научить танцевать.
? D. Трудности с получением информации 
обо всех аспектах поведения уток.
? E. Утки не могут летать и крякать одновременно.
? F. Изменения могут оказать непредвиденное влияние на другие классы.
Какие из перечисленных недостатков относятся к применению
наследования для реализации Duck? (Укажите все варианты.)
quack() {
 // Пустое переопределение
}
display() { // DecoyDuck }
fly() {
 //Пустое переопределение}
}
DecoyDuck
Еще один класс
в иерархии; деревянные 
утки не летают
и не крякают.
Но что произойдет, если 
в программу добавятся 
деревянные утки-приманки? 
Они не должны ни летать,
ни крякать...
Возьми в руку карандаш
42 глава 1
Я исключу метод fly() из 
суперкласса Duck и определю 
интерфейс Flyable() с методом 
fly(). Только те утки, которые должны
летать, реализуют интерфейс и содержат 
метод fly()... А я с таким же успехом 
могу определить интерфейс Quackable, 
потому что не все утки крякают.
display() 
fly()
quack()
MallardDuck
display()
fly()
quack()
RedheadDuck
display()
quack()
RubberDuck
swim()
display()
// ДРУГИЕ общие методы...
Duck
display()
DecoyDuck
fly()
Flyable quack()
Quackable
Как насчет интерфейса?
Джо понял, что наследование не решит проблему: он только что получил служебную записку, 
в которой говорится, что продукт должен обновляться каждые 6 месяцев (причем начальство еще не знает, как именно). Джо знает, что 
спецификация будет изменяться, а ему придется искать (и, возможно, переопределять) методы fly() и quack() для каждого нового субкласса, 
включаемого в программу... бесконечно. 
Итак, ему нужен более простой способ заставить летать или крякать только некоторых (но 
не всех!) уток.
А что ВЫ думаете об этой архитектуре?
наследование не решает проблему
знакомство с паттернами
дальше   43
По-моему, это самая дурацкая из твоих 
идей. Как насчет дублирования кода?
Тебе не хочется переопределять несколько 
методов, но как тебе понравится вносить 
маленькое изменение в поведении fly()... 
во всех 48 «летающих» субклассах Duck?!
А как бы ВЫ поступили на месте Джо?
Мы знаем, что не все субклассы должны реализовывать методы fly() 
или quack(), так что наследование не является оптимальным решением. С другой стороны, реализация интерфейсов Flyable и (или) 
Quackable решает проблему частично (резиновые утки перестают летать), но полностью исключает возможность повторного использования кода этих аспектов поведения, а следовательно, создает другой
кошмар из области сопровождения. Не говоря уже о том, что даже 
летающие утки могут летать по-разному...
Вероятно, вы ждете, что сейчас паттерн проектирования явится 
на белом коне и всех спасет. Но какой интерес в готовом рецепте? 
Нет, мы самостоятельно вычислим решение, руководствуясь канонами 
ОО-проектирования.
А как было бы хорошо, если бы
программу можно было написать так, 
чтобы вносимые изменения оказывали 
минимальное влияние на существующий 
код... Мы тратили бы меньше времени 
на переработку и больше — на всякие
интересные вещи...
44 глава 1
На что всегда можно рассчитывать в ходе работы над проектом?
В какой бы среде, над каким бы проектом, на каком угодно языке вы ни работали —
что всегда будет неизменно присутствовать в вашей программе?
Единственная константа в программировании
изменения
(ответ можно прочитать в зеркале)
Как бы вы ни спроектировали свое приложение, со временем оно должно 
развиваться и изменяться — иначе оно умрет.
Изменения могут быть обусловлены многими факторами. Укажите 
некоторые причины для изменения кода в приложениях (чтобы вам 
было проще, мы привели пару примеров). Сверьтесь с ответами 
в конце главы, прежде чем двигаться дальше.
Клиенты или пользователи требуют реализации новой 
или расширенной функциональности.
Компания переходит на другую СУБД, а данные будут приобретаться 
у другого поставщика в новом формате. Ужас!
постоянны только изменения
Возьми в руку карандаш
знакомство с паттернами
дальше   45
Итак, наследование нам не подошло, потому что утиное 
поведение изменяется в субклассах, а некоторые аспекты поведения присутствуют не во всех субклассах. Идея 
с интерфейсами Flyable и Quackable на первый взгляд 
выглядит заманчиво, но интерфейсы Java не имеют реализации, что исключает повторное использование кода. 
И если когда-нибудь потребуется изменить аспект поведения, вам придется искать и изменять его во всех субклассах, где он определяется, — скорее всего, с внесением новых ошибок!
К счастью, для подобных ситуаций существует полезный 
принцип проектирования.
Захожу на цель...
Иначе говоря, если некий аспект кода изменяется (допустим, с введением новых требований), то его необходимо отделить от тех аспектов, которые остаются неизменными. 
Другая формулировка того же принципа: выделите переменные составляющие и инкапсулируйте их, чтобы позднее 
их можно было изменять или расширять без воздействия на 
постоянные составляющие. 
При всей своей простоте эта концепция лежит в основе 
почти всех паттернов проектирования. Все паттерны обеспечивают возможность изменения некоторой части системы 
независимо от других частей.
Итак, пришло время вывести утиное поведение за пределы классов Duck!
Выделите то, что изменяется, 
и «инкапсулируйте» эти 
аспекты, чтобы они
не влияли на работу 
остального кода.
Результат? Меньше 
непредвиденных последствий 
от изменения кода, б?ольшая 
гибкость ваших систем!
 Принцип проектирования
Выделите аспекты приложения, которые 
могут изменяться, и отделите их от тех, 
которые всегда остаются постоянными. 
Первый из многих принципов
проектирования, которые 
встречаются в этой книге.
46 глава 1
Отделяем переменное от постоянного
Класс Duck
Класс Duck остается 
суперклассом для всех уток, но 
некоторые аспекты поведения 
выделяются в отдельную 
структуру классов.
Разные реализации 
поведения.
Для каждого переменного 
аспекта создается свой 
набор классов.
Аспекты поведения
Умение крякать
Умение летать
Bыделение
переменных аспектов 
С чего начать? Если не считать проблем с fly() и quack(), класс Duck работает хорошо, и другие его аспекты вряд ли будут часто изменяться. Таким образом, если не 
считать нескольких второстепенных модификаций, класс Duck в целом остается неизменным.
Чтобы отделить «переменное от постоянного», мы создадим два набора классов (совершенно независимых от Duck): один для fly, другой для quack. Каждый набор классов содержит реализацию соответствующего поведения.
Мы знаем, что fly() и quack() — части класса Duck, 
изменяющиеся в зависимости от субкласса.
Чтобы отделить эти аспекты поведения от класса Duck, мы 
выносим оба метода за пределы класса Duck и создаем новый 
набор классов для представления каждого аспекта.
отделить переменное
знакомство с паттернами
дальше   47
Как же спроектировать набор классов, реализующих переменные аспекты поведения ? 
Нам хотелось бы сохранить максимальную гибкость; в конце 
концов, все неприятности возникли именно из-за отсутствия 
гибкости в поведении Duck. Например, желательно иметь возможность создать новый экземпляр MallardDuck и инициализировать его с конкретным типом поведения fly(). И раз уж на 
то пошло, почему бы не предусмотреть возможность динамического изменения поведения? Иначе говоря, в классы Duck 
следует включить методы выбора поведения, чтобы способ 
полета MallardDuck можно было изменить во время выполнения.
Так мы переходим ко второму принципу проектирования.
Проектирование переменного поведения 
Принцип проектирования
Программируйте на уровне интерфейса, а не на уровне реализации.
Для представления каждого аспекта поведения (например, 
FlyBehavior или QuackBehavior) будет использоваться интерфейс, а каждая реализация аспекта поведения будет представлена реализацией этого интерфейса. 
Итак, на этот раз интерфейсы реализуются не классами Duck. 
Вместо этого мы создаем набор классов, единственным смыслом которых является представление некоторого поведения. 
И теперь интерфейс поведения реализуется классом поведения, 
а не классом Duck.
Такой подход отличается от того, что делалось прежде, когда поведение предоставлялось либо конкретной реализацией 
в суперклассе Duck, либо специализированной реализацией 
в самом субклассе. В обоих случаях возникала зависимость 
от реализации. Мы были вынуждены использовать именно эту 
реализацию, и изменить поведение было невозможно (без написания дополнительного кода).
В новом варианте архитектуры субклассы Duck используют 
поведение, представленное интерфейсом (FlyBehavior или 
QuackBehavior), поэтому фактическая реализация этого поведения (то есть конкретное поведение, запрограммированное в классе, реализующем FlyBehavior или QuackBehavior) не 
привязывается к субклассу Duck.
Отныне аспекты поведения Duck будут находиться 
в отдельных классах,
реализующих интерфейс
конкретного аспекта.
В этом случае классам 
Duck не нужно знать подробности реализации своих 
аспектов поведения.
<<interface>> 
FlyBehavior
fly()
fly() {
 // Реализация полета
}
FlyWithWings
fly() {
 // Пустая реализация -
 // не умеет летать!
}
FlyNoWay
48 глава 1
Слово интерфейс имеет несколько смыслов. Наряду 
с концепцией интерфейса существует конструкция Java 
interface. Программирование на уровне интерфейса 
может не использовать Java-конструкцию interface. 
Собственно, главной целью применения полиморфизма 
посредством программирования на уровне супертипа является как раз отсутствие жесткой привязки к конкретному объекту во время выполнения. Или, другими словами, «переменные должны объявляться с супертипом 
(обычно абстрактным классом или интерфейсом), чтобы присваиваемые им объекты могли относиться к любой конкретной реализации супертипа». 
Вероятно, вам все это хорошо известно, но просто для 
того, чтобы убедиться в общности наших представлений, 
рассмотрим пример использования полиморфного типа. 
Допустим, имеется абстрактный класс Animal с двумя 
конкретными реализациями: Dog и Cat. 
Программирование на уровне реализации
выглядит так:
Dog d = new Dog();
d.bark();
Программирование на уровне интерфейса/супертипа:
Animal animal = new Dog();
animal.makeSound();
Или еще лучше, вместо жесткой фиксации подтипа 
в коде (new Dog()), объект конкретной реализации 
присваивается во время выполнения:
a = getAnimal();
a.makeSound();
«Интерфейс» в данном случае означает 
«супертип».
makeSound()
Animal
makeSound() {
 bark();
}
bark() { // Гав-гав }
Dog
makeSound() {
 meow();
}
meow() { // Мяу }
Cat
Абстрактный супертип 
(может быть абстрактным 
классом ИЛИ интерфейсом).
Конкретные
реализации
Объявление «d» с типом Dog 
требует программирования 
на уровне конкретной 
реализации Animal.
Полиморфное 
использование ссылки.
Фактический подтип Animal 
неизвестен... Важно лишь то, 
что он умеет реагировать 
на makeSound().
программировать для интерфейса
Не понимаю, зачем 
использовать интерфейс для 
FlyBehavior? То же самое можно 
сделать при помощи абстрактного 
суперкласса. Ведь полиморфизм для 
этого и существует!
знакомство с паттернами
дальше   49
Интерфейс FlyBehavior 
реализуется всеми классами, 
способными летать. От 
нового класса требуется лишь 
реализация метода fly.
Реализация fly() 
для всех летающих 
уток.
Реализация для уток, 
которые летать
не умеют.
Утки, 
которые 
крякают.
Утки, которые 
пищат. Утки, которые 
не издают звуков.
Аналогичный интерфейс 
с методом quack(), 
который должен быть 
реализован классом.
<<interface>>
FlyBehavior
fly()
fly() {
 // Реализация полета
}
FlyWithWings
fly() {
 // Пустая реализация
}
FlyNoWay
<<interface>>
QuackBehavior
quack()
quack() {
 // Кряканье
}
Quack
quack() {
 // Резиновые утки пищат
}
Squeak
quack() {
 // Пустая реализация!
}
MuteQuack
Реализация поведения уток
Интерфейсы FlyBehavior и QuackBehavior вместе с соответствующими классами, реализующими каждое конкретное поведение.
Все преимущества 
ПОВТОРНОГО 
ИСПОЛЬЗОВАНИЯ без 
недостатков, присущих 
наследованию!
Такая архитектура позволяет использовать 
поведение fly() и quack() в других типах объектов, потому что это поведение не скрывается 
в классах Duck!
Кроме того, мы можем добавлять новые 
аспекты поведения без изменения существующих классов поведения и без последствий 
для классов Duck, использующих существующее поведение.
50 глава 1
В: Так я всегда должен сначала реализовать приложение, 
посмотреть, что в нем изменяется, а затем вернуться, выделить и инкапсулировать переменные составляющие?
О: Не всегда; в ходе проектирования приложения часто удается заранее выявить изменяющиеся аспекты и включить гибкие 
средства для работы с ними в программный код. Общие принципы и паттерны применимы на любой стадии жизненного цикла 
разработки.
В: Может, Duck тоже стоит преобразовать в интерфейс?
О: Не в этом случае. Структура, в которой Duck не является 
интерфейсом, имеет свои преимущества: она позволяет конкретным подклассам уток (например, MallardDuck) наследовать общие свойства и методы. После исключения переменных аспектов 
из иерархии Duck мы пользуемся преимуществами этой структуры без всяких проблем.
В: Класс, представляющий поведение, выглядит немного 
странно. Разве классы не должны представлять сущности? 
И разве классы не должны обладать состоянием И поведением?
О: Действительно, в ОО-системах классы представляют сущности, которые обычно обладают как состоянием (переменными 
экземпляров), так и методами. И в данном случае сущностью 
оказывается поведение. Однако даже поведение может обладать состоянием и методами; скажем, поведение полета может 
использовать переменные экземпляров, представляющие атрибуты полета (количество взмахов крыльев в минуту, максимальная высота и скорость и т. д.).
Ответы: 
- Создайте класс FlyRocket 1. 
Powered, реализующий 
интерфейс FlyBehavior.
Например, утиный манок 2. 
- (охотничье устройство, под
ражающее кряканью).
Как бы вы поступили в новой архитектуре, если бы вам 
потребовалось включить в приложение SimUDuck полеты на реактивной тяге?
1
Какой класс мог бы повторно использовать поведение 
quack(), не являясь при этом уткой?
2
поведение в классе
Возьми в руку карандаш
часто Задаваемые вопросы
знакомство с паттернами
дальше   51
public abstract class Duck {
 QuackBehavior quackBehavior;
 // ...
 public void performQuack() {
 quackBehavior.quack();
 }
}
Интеграция поведения c классом Duck
Начнем с добавления двух переменных экземпляров с типами FlyBehavior 
и QuackBehavior — назовем их flyBehavior и quackBehavior. Каждый конкретный 
объект утки будет присваивать значения этих переменных в определенный 
момент выполнения — например, FlyWithWings для полета и Squeak для кряканья.
Методы fly() и quack() удаляются из класса Duck (и всех субклассов), потому 
что это поведение перемещается в классы FlyBehavior и QuackBehavior. 
В классе Duck методы fly() и quack() заменяются двумя аналогичными методами: performFly() и performQuack(); вскоре вы увидите, как они работают.
У новой структуры есть одна принципиальная особенность: 
класс Duck теперь делегирует свои аспекты поведения 
(вместо простого использования методов, определенных 
в классе Duck или его субклассах). 
Вот как это делается:
1
2
Эти методы 
заменяют fly() 
и quack().
Во время выполнения переменной присваивается 
ссылка на конкретное поведение.
Реализация performQuack()
performQuack()
swim()
display()
performFly()
// ДРУГИЕ методы...
Duck
FlyBehavior flyBehavior
QuackBehavior quackBehavior
Аспекты поведения
QuackBehavior
FlyBehavior
Объект Duck делегирует 
поведение объекту, на который 
ссылается quackBehavior.
Все просто, верно? Вместо того чтобы выполнять действие самостоятельно, объект Duck просто поручает эту работу объекту, на 
который ссылается quackBehavior. В этой части нас совершенно не 
интересует, что это за объект, — важно лишь, чтобы он умел выполнять quack()!
Каждый объект Duck содержит 
ссылку на реализацию интерфейса 
QuackBehavior.
Переменные 
объявляются
с типом 
ИНТЕРФЕЙСА 
поведения.
52 глава 1
Подробнее об интеграции...
3 Пора разобраться с тем, как присваиваются значения переменным flyBehavior и quackBehavior. Рассмотрим фрагмент класса MallardDuck:
public class MallardDuck extends Duck {
 public MallardDuck() {
 quackBehavior = new Quack();
 flyBehavior = new FlyWithWings();
 }
 public void display() {
System.out.println("I’m a real Mallard duck");
 }
}
При создании экземпляра MallardDuck конструктор инициализирует унаследованную переменную экземпляра quackBehavior 
новым экземпляром типа Quack (класс конкретной реализации QuackBehavior).
То же самое происходит и с другим аспектом поведения: конструктор MallardDuck инициализирует переменную flyBehavior экземпляром типа FlyWithWings (класс конкретной реализации FlyBehavior).
MallardDuck использует класс 
Quack для выполнения действия, 
так что при вызове performQuack() 
ответственность за выполнение 
возлагается на объект Quack.
А в качестве реализации FlyBehavior 
используется тип FlyWithWings.
Запомните, что MallardDuck 
наследует переменные quackBehavior 
и flyBehavior от класса Duck.
интеграция утиного поведения
знакомство с паттернами
дальше   53
Все верно, именно так мы и поступаем... пока.
Позднее в книге будут описаны другие паттерны, которые помогут решить эту проблему.
А пока стоит заметить, что хотя аспекты поведения 
связываются с конкретными реализациями (мы создаем экземпляр класса поведения типа Quack или 
FlyWithWings и присваиваем его ссылочной переменной), эти реализации можно легко менять во время выполнения.
Таким образом, гибкость инициализации переменных экземпляров оставляет желать лучшего. Но поскольку переменная экземпляра quackBehavior относится к интерфейсному типу, мы можем (благодаря 
волшебству полиморфизма) динамически присвоить 
другой класс реализации QuackBehavior во время выполнения.
Остановитесь на минуту и подумайте, как бы вы реализовали динамическое изменение поведения. (Пример 
кода будет приведен через несколько страниц.)
Секундочку, но вы же только 
что говорили, что мы НЕ ДОЛЖНЫ 
программировать на уровне реализации? 
А что происходит в конструкторе? 
Мы создаем новый экземпляр конкретной 
реализации Quack!
54 глава 1
Тестирование кода Duck
Введите и откомпилируйте класс Duck (Duck.java, см. ниже) 
и класс MallardDuck class (MallardDuck.java, приводился 
две страницы назад).
1
public abstract class Duck {
 FlyBehavior flyBehavior;
 QuackBehavior quackBehavior;
 public Duck() {
 }
 public abstract void display();
 public void performFly() {
 flyBehavior.fly();
 }
 public void performQuack() {
 quackBehavior.quack();
 } 
 public void swim() {
 System.out.println("All ducks float, even decoys!");
 }
}
Объявляем две ссылочные 
переменные с типами 
интерфейсов поведения. 
Переменные наследуются всеми 
субклассами Duck (в том же 
пакете). 
Делегирование операции 
классам поведения.
Введите и откомпилируйте интерфейс FlyBehavior 
(FlyBehavior.java) и два класса реализации поведения 
(FlyWithWings.java и FlyNoWay.java).
2
public interface FlyBehavior {
 public void fly();
}
public class FlyWithWings implements FlyBehavior { 
 public void fly() {
System.out.println("I’m flying!!");
 }
}
public class FlyNoWay implements FlyBehavior {
 public void fly() {
 System.out.println("I can’t fly");
 }
}
Интерфейс реализуется 
всеми классами.
Реализация поведения для 
уток, которые УМЕЮТ 
летать...
Реализация поведения для уток, 
которые НЕ ЛЕТАЮТ (например, 
резиновых).
тестирование поведения
знакомство с паттернами
дальше   55
File Edit Window Help Yadayadayada
%java MiniDuckSimulator
Quack
I’m flying!!
public class MiniDuckSimulator {
 public static void main(String[] args) {
 Duck mallard = new MallardDuck();
 mallard.performQuack();
 mallard.performFly();
 }
}
5 Выполните код!
Вызов метода performQuack(), 
унаследованного классом MallardDuck; 
метод делегирует выполнение операции 
по ссылке на QuackBehavior (то есть 
вызывает quack() через унаследованную 
переменную quackBehavior).
Затем то же самое происходит 
с методом performFly(), также 
унаследованным классом MallardDuck.
Введите и откомпилируйте тестовый класс 
(MiniDuckSimulator.java).
4
Тестирование кода Duck продолжается...
Введите и откомпилируйте интерфейс QuackBehavior 
(QuackBehavior.java) и три класса реализации поведения 
(Quack.java, MuteQuack.java и Sqeak.java).
3
public interface QuackBehavior {
 public void quack();
}
public class Quack implements QuackBehavior {
 public void quack() {
 System.out.println("Quack");
 }
}
public class MuteQuack implements QuackBehavior {
 public void quack() {
System.out.println("<< Silence >>");
 }
}
public class Squeak implements QuackBehavior {
 public void quack() {
System.out.println("Squeak");
 }
}
56 глава 1
Динамическое изменение поведения
Согласитесь, обидно было бы наделить наших уток возможностями динамической смены поведения и не использовать их! Предположим, вы 
хотите, чтобы тип поведения задавался set-методом подкласса (вместо 
создания экземпляра в конструкторе).
1 Добавьте два новых метода в класс Duck:
Вызывая эти методы в любой момент, мы можем изменить поведение утки «на лету».
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()
// ДРУГИЕ методы...
Duck
FlyBehavior flyBehavior;
QuackBehavior quackBehavior;
public void setFlyBehavior(FlyBehavior fb) {
 flyBehavior = fb;
}
public void setQuackBehavior(QuackBehavior qb) {
 quackBehavior = qb;
}
public class ModelDuck extends Duck { 
 public ModelDuck() {
 flyBehavior = new FlyNoWay();
quackBehavior = new Quack();
 }
 public void display() {
 System.out.println("I’m a model duck");
 }
}
public class FlyRocketPowered implements FlyBehavior {
 public void fly() {
 System.out.println("I’m flying with a rocket!");
 }
}
2
Утка-приманка 
изначально летать
не умеет...
Определяем новое 
поведение —
реактивный полет.
Создайте новый субкласс Duck (ModelDuck.java).
3 Определите новый тип FlyBehavior 
(FlyRocketPowered.java).
утки с динамическим поведением
знакомство с паттернами
дальше   57
public class MiniDuckSimulator {
 public static void main(String[] args) {
 Duck mallard = new MallardDuck();
 mallard.performQuack();
 mallard.performFly();
 
 Duck model = new ModelDuck();
 model.performFly();
 model.setFlyBehavior(new FlyRocketPowered());
 model.performFly(); 
 }
}
Первый вызов performFly() 
передается реализации, 
заданной в конструкторе 
ModelDuck, то есть 
экземпляру FlyNoWay.
File Edit Window Help Yabadabadoo
%java MiniDuckSimulator
Quack
I’m flying!!
I can’t fly
I’m flying with a rocket
4
5 Поехали!
Внесите изменения в тестовый класс (MiniDuckSimulator.
java), добавьте экземпляр ModelDuck и переведите его 
на реактивную тягу.
Вызываем set-метод, 
унаследованный классом 
ModelDuck, и... уткаприманка вдруг взлетает
на реактивном двигателе!
Способность утки-приманки 
к полету переключается 
динамически! Если бы 
реализация находилась в 
иерархии Duck, ТАКОЕ было 
бы невозможно.
Поведение утки во время 
выполнения изменяется 
простым вызовом set-метода.
до
после
58 глава 1
Ниже изображена вся переработанная структура классов. В ней есть все, 
чего можно ожидать: классы уток, расширяющие Duck, а также классы 
поведения, реализующие FlyBehavior и QuackBehavior.
Стоит заметить, что мы начинаем рассматривать происходящее с несколько иной точки зрения. Поведение утки уже рассматривается не как 
совокупность аспектов поведения, а как семейство алгоритмов. В архитектуре 
SimUDuck алгоритмы представляют то, что делают утки (как они летают, крякают и т. д.), однако эту методологию с таким же успехом можно 
применить к набору классов для вычисления налога с продаж в разных 
штатах.
Обратите особое внимание на отношения между классами. А еще лучше — 
возьмите ручку и подпишите тип отношения (ЯВЛЯЕТСЯ, СОДЕРЖИТ 
или РЕАЛИЗУЕТ) над каждой стрелкой на диаграмме.
Инкапсуляция поведения: общая картина
Мы основательно повозились с конкретной 
архитектурой. Пора сделать шаг назад
и взглянуть на картину в целом.
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()
// ДРУГИЕ методы...
Duck
FlyBehavior flyBehavior
QuackBehavior quackBehavior
<<interface>>
FlyBehavior
fly()
fly() {
 // Реализация полета
}
FlyWithWings
fly() {
 // Не летает!
}
FlyNoWay
<<interface>>
QuackBehavior
quack()
quack() {
 // Утка крякает
}
Quack
quack() {
 // Резиновая утка пищит
}
Squeak
quack() {
 // Не издает звуков!
}
MuteQuack
display() {
// для DecoyDuck }
DecoyDuck
display() {
// для MallardDuck }
MallardDuck
display() {
// для RedheadDuck }
RedheadDuck
display() {
// для RubberDuck }
RubberDuck
Инкапсуляция fly
Инкапсуляция quack
Каждый 
набор можно 
рассматривать 
как семейство 
алгоритмов.
Клиент 
Эти аспекты 
алгоритмы 
взаимозаменяемы.
Клиент использует 
инкапсулированные 
алгоритмы.
общая картина
Не ленитесь и сделайте.
знакомство с паттернами
дальше   59
Каждая утка СОДЕРЖИТ экземпляры FlyBehavior и QuackBehavior, которым делегируется выполнение соответствующих операций.
Подобные связи между двумя классами означают, что вы 
используете механизм композиции. Поведение не наследуется, а предоставляется правильно выбранным объектом.
На самом деле это очень важный момент; мы вплотную 
подошли к третьему принципу проектирования.
Принцип проектирования
Отдавайте предпочтение композиции перед наследованием.
Утиный манок используется охотниками для имитации утиного кряканья. Как бы вы реализовали 
собственную версию утиного манка, которая не 
является производной от класса Duck?
Как вы убедились, системы, созданные на основе композиции, обладают значительно большей гибкостью. Они 
позволяют не только инкапсулировать семейства алгоритмов, но и изменять поведение во время выполнения — при 
условии, что объект, подключенный посредством композиции, реализует правильный интерфейс.
Композиция используется во многих паттернах проектирования. Мы еще не раз вернемся к ее достоинствам и недостаткам в этой книге.
Гуру и Ученик...
Гуру: Расскажи, что 
ты узнал о сущности 
объектно-ориентированного подхода.
Ученик: Учитель, я узнал, что он открывает путь к повторному использованию.
Гуру: Продолжай...
Ученик: Наследование позволяет повторно использовать многие полезные 
вещи, а время разработки исчезает 
так же стремительно, как срубленные 
стебли бамбука.
Гуру: Когда мы тратим больше времени: до или после завершения разработки?
Ученик: После, о Учитель. На сопровождение и доработку программ всегда 
уходит больше времени, чем на начальную разработку.
Гуру: Не значит ли это, что повторному использованию следует уделять 
больше внимания, чем удобству сопровождения и расширения?
Ученик: Полагаю, это так.
Гуру: Вижу, тебе еще далеко 
до просветления. Иди и продолжай 
медитировать на наследовании. 
У наследования есть свои недостатки, и повторное использование 
может быть достигнуто другими 
средствами.
Отношения СОДЕРЖИТ бывают удобнее отношений ЯВЛЯЕТСЯ
Мозговой
штурм
60 глава 1
Поздравляем 
с первым 
паттерном!
Вы только что применили свой первый паттерн проектирования СТРАТЕГИЯ. Да, вы не ошиблись: при 
переработке приложения SimUDuck был использован 
паттерн Стратегия. Благодаря ему проект готов к любым изменениям, возникающим в фантазии вашего начальства.
А теперь, когда мы прошли довольно долгий путь к конечной цели, приведем формальное определение:
Паттерн Стратегия определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо 
от их использования на стороне клиента.
Кстати, о паттернах...
Используйте ЭТО 
определение, когда вам 
понадобится произвести 
впечатление на друзей 
или начальство.
паттерн стратегия
знакомство с паттернами
дальше   61
Ниже изображены перепутанные классы и интерфейсы, используемые для 
программирования приключенческой игры. В иерархию входят классы 
игровых персонажей и разных типов вооружения. Каждый персонаж в любой момент времени использует только один вид оружия, но может свободно 
менять оружие в ходе игры. Восстановите отсутствующие связи.
(Ответы приведены в конце главы.)
Character
WeaponBehavior weapon;
setWeapon(WeaponBehavior w) {
 this.weapon = w;
}
fight();
KnifeBehavior
useWeapon() { // Реализация 
удара ножом }
Queen
fight() { ... }
King
fight() { ... } Troll
fight() { ... }
BowAndArrowBehavior
useWeapon() { // Реализация 
выстрела из лука }
Knight
fight() { ... }
<<interface>>
WeaponBehavior
useWeapon();
AxeBehavior
useWeapon() { // Реализация 
удара топором }
SwordBehavior
useWeapon() { // Реализация 
удара мечом }
1. Организуйте классы в иерархию.
2. Найдите один абстрактный класс, один интерфейс и восемь классов.
3. Соедините классы стрелками.
1. Отношение наследования («расширяет»):
2. Отношение реализации интерфейса:
3. Отношение типа «СОДЕРЖИТ»:
4. Включите метод setWeapon() в правильный класс.
1
2
3
4
Ваша задача:
Головоломка
62 глава 1
В местном бистро...
Чем различаются эти два заказа? Да ничем! Они абсолютно одинаковые, если не считать того, что Элис произнесла вдвое больше слов и едва не вывела из себя старого 
ворчливого официанта.
Что есть у Фло, чего нет у Элис? Единая номенклатура с официантом. Она не только упрощает общение, но и помогает официанту запомнить заказ, потому что все 
паттерны блюд хранятся у него в голове.
Паттерны проектирования формируют единую номенклатуру для разработчиков. 
Когда вы овладеете этой номенклатурой, вам будет проще общаться с другими разработчиками, а у тех, кто паттернов не знает, появится лишний стимул для их изучения. Кроме того, вы начнете воспринимать архитектуру на более высоком уровне
паттернов, а не на уровне объектов.
Фло
Элис
разговор в бистро
Мне шоколадную содовую с ванильным 
мороженым, горячий сэндвич с сыром и 
беконом, салат с тунцом на гренке, банановый 
сплит с мороженым и ломтиками бананов, 
кофе со сливками и двумя кусочками сахара... 
и приготовьте гамбургер на гриле!
Дайте 
«черное с белым», 
«Джека Бенни», «радио», 
«плавучий дом», стандартный 
кофе и зажарьте одну штуку!
знакомство с паттернами
дальше   63
Какие еще примеры использования единой терминологии вам известны, кроме 
ОО-проектирования и заказов в бистро? 
(Подсказка: вспомните об автомашинах, 
столярных работах, управлении воздушным движением.) Какие характеристики 
передаются при помощи специальных 
терминов?
А какие аспекты ОО-проектирования передаются в именах паттернов? Какие 
характеристики передаются в названии 
паттерна Стратегия?
В соседнем офисе...
Рик
А проще 
говоря, ты 
применила паттерн 
Наблюдатель?
Мозговой
штурм
Верно. Если ты будешь
использовать паттерны 
в общении, то другие разработчики 
немедленно и точно поймут, 
о чем идет речь. Только не перестарайся... А то некоторые начинают 
использовать паттерны в программе 
«Hello World»...
И тогда я создал класс, который ведет 
список всех объектов-слушателей и при 
поступлении новых данных отправляет 
сообщение каждому слушателю. Причем 
слушатели могут в любой момент присоединяться к рассылке или отсоединяться 
от нее. Все происходит динамически,
с минимальной привязкой!
64 глава 1
Номенклатуры паттернов обладают большой 
ВЫРАЗИТЕЛЬНОСТЬЮ. Используя паттерны в общении с другим разработчиком или группой, вы 
передаете не только название паттерна, но и целый 
набор характеристик, качеств и ограничений, представленных данным паттерном.
Паттерны позволяют сказать больше, используя 
меньшее количество слов. Когда вы используете 
паттерн в описании, другие разработчики моментально понимают суть решения, о котором вы говорите.
Общение на уровне паттернов помогает дольше 
оставаться «на уровне архитектуры». Описание 
программной системы с использованием паттернов 
позволяет вести обсуждение на более абстрактном 
уровне, не отвлекаясь на второстепенные подробности реализации объектов и классов.
Единая номенклатура повышает эффективность 
разработки. Группа, хорошо разбирающаяся в паттернах проектирования, быстрее продвигается вперед, а ее участники лучше понимают друг друга.
Единые номенклатуры помогают новичкам-разработчикам быстрее войти в курс дела. Новички 
берут пример с опытных разработчиков. Если опытный разработчик применяет паттерны в своей работе, у новичков появляются дополнительные стимулы для их использования. Создайте сообщество 
пользователей паттернов в своей организации.
Сила единой номенклатуры
Использование паттернов в общении не сводится 
к общей ТЕРМИНОЛОГИИ.
«Для реализации разных вариантов 
поведения используется паттерн 
Стратегия». Из этой фразы мы 
узнаем, что поведение инкапсулируется 
в отдельном наборе классов, который 
легко расширяется и изменяется — 
при необходимости даже во время 
выполнения.
Сколько совещаний по проектированию, 
в которых вам довелось участвовать, 
быстро вырождалось в обсуждение 
подробностей реализации?
Подумайте о создании группы 
изучения паттернов в своей 
организации — возможно, время 
учебы даже будет оплачиваться...
В процессе обмена идеями и опытом, 
выраженными в виде паттернов, 
формируется сообщество 
пользователей паттернов.
единая номенклатура
знакомство с паттернами
дальше   65
Все мы пользовались готовыми библиотеками и инфраструктурами. Мы берем их, пишем 
код с использованием функций API, компилируем и извлекаем пользу из кода, написанного 
другими людьми. Достаточно вспомнить, какую функциональность предоставляет Java API: 
сеть, графические интерфейсы, ввод/вывод и т. д. Однако библиотеки и инфраструктуры не 
помогают нам структурировать приложения так, чтобы они становились более понятными, 
гибкими и простыми в сопровождении. Для достижения этой цели применяются паттерны 
проектирования.
Паттерны не сразу воплощаются в вашем коде — сначала они должны проникнуть в ваш 
МОЗГ. Когда вы начнете достаточно хорошо разбираться в паттернах, вы сможете применять их в своих новых архитектурах, а также перерабатывать старый код, который со временем превращается в хаотическое месиво.
Как пользоваться паттернами?
В: Если паттерны так хороши, почему никто не оформил их в виде библиотеки?
О: Паттерны относятся к более высокому уровню, чем библиотеки. Они 
определяют способы структурирования 
классов и объектов для решения некоторых задач, а наша задача — адаптировать их для своих конкретных приложений.
В: А библиотеки и фреймворки не 
являются паттернами проектирования? 
О: Нет, не являются; они предоставляют конкретные реализации, которые 
мы связываем со своим кодом. Впрочем, иногда паттерны используются 
в реализациях библиотек. И это очень 
хорошо, потому что понимание паттернов поможет быстрее разобраться
в API, архитектура которых базируется 
на паттернах.
В: Так, значит, библиотек паттернов не существует? 
О: Нет, но позднее вы узнаете о каталогах паттернов, которые могут применяться в ваших приложениях.
Ваш МОЗГ
Ваш код, улучшенный 
благодаря применению 
паттернов!
Паттерны
swim()
display()
performQuack()
performFly()
setFlyBehavior()
setQuackBehavior()
// OTHER duck-like methods...
Duck
FlyBehavior flyBehavior;
QuackBehavior quackBehavior;
<<interface>>
FlyBehavior fly()
fly() {
 // implements duck flying
}
FlyWithWings
fly() {
 // do nothing — can’t fly!
}
FlyNoWay
<<interface>>
QuackBehavior
quack()
quack) {
 // implements duck quacking
}
Quack
quack() {
 // rubber duckie squeak
}
Squeak
quack() {
 // do nothing — can’t quack!
}
MuteQuack
display() {
// looks like a decoy duck }
Decoy Duck
display() {
// looks like a mallard 
}
Mallard Duck
display() {
// looks like a redhead 
}
Redhead Duck
display() {
// looks like a rubberduck }
Rubber Duck
Инкапсуляция поведения fly
Инкапсуляция поведения quack
Клиент
Представление
Controller
Модель
Запрос
MVC
Subject Object
8
int
Dog Object
Mouse Object
Cat Objec
D
t
uck Object
Наблюдатели
8
8
8
8
Автоматические 
обновления/оповещения
Объект 
состояния
Зависимые 
объекты
НАБЛЮДАТЕЛЬ
часто Задаваемые вопросы
66 глава 1
Программист-скептик Гуру паттернов
Разработчик:Хм, но разве дело не сводится к ОО-проектированию? 
Если я следую принципам инкапсуляции, знаю об абстракции, наследовании и полиморфизме, то зачем мне думать о паттернах проектирования? Для чего тогда были нужны те курсы ОО-проектирования? 
Я думаю, паттерны проектирования полезны только тем, кто не разбирается в ОО-проектировании.
Гуру: О, это одно из известных заблуждений объектно-ориентированной разработки, что знание основ ООП автоматически позволит 
вам строить гибкие, удобные в сопровождении и пригодные к повторному использованию системы.
Разработчик: Нет?
Гуру: Hет. Более того, принципы построения ОО-систем, обладающих такими свойствами, далеко не всегда очевидны.
Разработчик: Кажется, я начинаю понимать. И на основе этих неочевидных принципов построения объектно-ориентированных систем были сформулированы...
Гуру: ...да, были сформулированы паттерны проектирования.
зачем нужны паттерны?
Паттерны — 
не что иное, как 
применение принципов 
ОО-проектирования... Распространенное
заблуждение, не все так 
просто. Тебе еще многое 
предстоит узнать...
знакомство с паттернами
дальше   67
Разработчик: Выходит, зная паттерны, я могу пропустить 
все технические подробности, а мои решения всегда будут работать?
Гуру: Да, до определенной степени, но не забывайте: проектирование — это искусство, а не ремесло. Компромиссы неизбежны, но если вы будете использовать хорошо продуманные и проверенные временем схемы, ваша работа значительно 
упростится. 
Разработчик: А если я не могу найти подходящий паттерн?
Гуру: Существуют некоторые объектно-ориентированные 
принципы, заложенные в основу паттернов. Знание этих принципов поможет найти выход из ситуации, для которой вам не 
удается найти подходящий паттерн.
Разработчик: Принципы? Не считая абстракции, инкапсуляции и...
Гуру: Да, один из секретов построения гибких ОО-систем заключается в прогнозировании их возможных будущих изменений. В этом нам и помогают принципы, о которых я говорю.
Знание таких концепций, как
абстракция, наследование и полиморфизм, еще не делает из вас хорошего 
ОО-проектировщика. Истинный гуру проектирования стремится создавать гибкие 
архитектуры, способные адаптироваться 
к изменениям.
68 глава 1
Новые инструменты
  Знание основ ООП не 
сделает из вас хорошего 
ОО-проектировщика.
  Хорошие ОО-архитектуры 
хорошо расширяются, 
просты в сопровождении 
и пригодны для повторного 
использования.
  Паттерны показывают, как 
строить системы с хорошими качествами ОО-проектирования.
  Паттерны содержат проверенный опыт ОО-проектирования.
  Паттерны описывают общие 
решения проблем проектирования и применяются 
в конкретных приложениях.
  Паттерны не придумывают — их находят.
  Большинство паттернов 
и принципов направлено на 
решение проблем изменения программных архитектур.
  Многие паттерны основаны 
на инкапсуляции переменных аспектов системы.
  Паттерны образуют единую 
номенклатуру, которая 
повышает эффективность 
вашего общения с другими 
разработчиками.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции ООП
Инкапсулируйте то, что 
изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне 
интерфейсов, а не реализации.
Принципы
Стратегия — определяет семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. Паттерн позволяет 
модифицировать алгоритмы независимо от их использования на 
стороне клиента.
Паттерны
Предполагается, что 
вы уже понимаете 
основные концепции ООП: 
полиморфное использование 
классов, инкапсуляция и т. д.
Мы рассмотрим эти 
принципы более подробно, 
а также дополним список 
новыми принципами.
Один паттерн пройден, но впереди еще много!
Во время чтения 
обращайте 
внимание на 
связь паттернов 
с основами и 
принципами ООП.
Первая глава почти завершена! В ней ваш ОО-инструментарий дополнился несколькими новыми инструментами. Давайте вспомним их, прежде чем переходить к главе 2.
инструментарий проектирования
КЛЮЧЕВЫЕ 
МОМЕНТЫ
знакомство с паттернами
дальше   69
<<interface>> 
WeaponBehavior
Character — абстрактный суперкласс для всех классов персонажей (King, Queen, Knight и Troll), а интерфейс WeaponBehavior 
реализуется всеми классами поведения оружия. Все классы персонажей и оружия являются конкретными.
Чтобы сменить оружие, персонаж вызывает метод setWeapon(), 
определяемый в суперклассе Character. Во время сражения для 
текущего оружия персонажа вызывается метод useWeapon().
Character
WeaponBehavior weapon;
fight();
setWeapon(WeaponBehavior w) {
 this.weapon = w;
}
King
fight() { ... }
Queen
fight() { ... }
Knight
fight() { ... }
Troll
fight() { ... }
useWeapon();
BowAndArrowBehavior
useWeapon() { // Реализация 
выстрела из лука } AxeBehavior
useWeapon() { // Реализация 
удара топором }
SwordBehavior
useWeapon() { // Реализация 
удара мечом } KnifeBehavior
useWeapon() { // Реализация 
удара ножом }
Ответы к упражнениям
Обратите внимание: 
интерфейс WeaponBehavior 
может быть реализован 
ЛЮБЫМ объектом, будь 
то скрепка, тюбик зубной 
пасты или рыба-мутант.
абстрактный
Character СОДЕРЖИТ 
WeaponBehavior.
70 глава 1
ответы к упражнениям
? A. Дублирование кода в субклассах.
? B. Трудности с изменением поведения на стадии выполнения.
? C. Уток нельзя научить танцевать.
? D. Трудности с получением информации 
обо всех аспектах поведения уток.
? E. Утки не могут летать и крякать одновременно.
? F. Изменения могут оказать непредвиденное влияние на другие классы.
Какие из перечисленных недостатков относятся к применению наследования
для реализации Duck? (Укажите все варианты.)
Какие факторы могут вызвать изменения в вашем приложении? Возможно, ваш 
список будет выглядеть совершенно иначе... А может, и в нашем списке многое 
покажется знакомым?
Клиенты или пользователи требуют реализации новой или 
расширенной функциональности.
Компания переходит на другую СУБД, а данные будут приобретаться 
у другого поставщика в новом формате. Ужас!
Технология изменилась, и код необходимо изменить для использования 
новых протоколов.
В ходе построения системы мы получили много полезной информации. 
Теперь мы хотим вернуться и немного доработать исходную 
архитектуру.
Возьми в руку карандаш
 Решение
Возьми в руку карандаш
 Решение
Вы ведь не хотите оставаться в неведении, когда происходит 
что-то интересное, верно? У нас есть паттерн, который будет держать 
ваши объекты в курсе, когда происходит нечто такое, что их интересует. 
Это паттерн Наблюдатель — один из наиболее часто встречающихся паттернов проектирования, и он к тому же невероятно полезен. Мы рассмотрим многие интересные аспекты паттерна Наблюдатель, такие как отношения типа «один ко многим» и слабое связывание. А когда эти концепции 
запечатлеются у вас в мозгу, вы наверняка станете душой вечеринок в сообществе паттернов.
Объекты в курсе
 событий
2 Паттерн Наблюдатель
Привет, Джерри. Я обзваниваю всех, чтобы сообщить: встреча 
нашей группы изучения паттернов 
переносится на воскресенье. Мы
будем обсуждать паттерн Наблюдатель. Это самый лучший
паттерн! Серьезно, Джерри,
ЛУЧШИЙ!
72 глава 2
Weather-O-Rama, Inc.
100 Main Street
Tornado Alley, OK 45021
Техническое задание
Поздравляем, вашей группе поручена разработка ПО метеорологической станции следующего поколения!
Метеостанция работает на базе запатентованного объекта 
WeatherData, отслеживающего текущие погодные условия 
(температура, влажность, атмосферное давление). Вы должны 
создать приложение, которое изначально отображает три визуальных элемента: текущую сводку, статистику и простой прогноз. Все данные обновляются в реальном времени, по мере 
того как объект WeatherData получает данные последних измерений.
Кроме того, погодная станция должна быть расширяемой. 
Weather-O-Rama хочет, чтобы другие разработчики могли писать собственные приложения для вывода прогнозов погоды и 
подключать их к существующей системе. А значит, очень важно, чтобы в будущем разработчик мог легко добавить собственное приложение вывода данных.
Наша фирма полагает, что нам удалось создать весьма удачную 
бизнес-модель: когда клиенты привыкнут к нашему сервису, мы 
планируем взимать отдельную плату за каждый элемент.
Надеемся в ближайшее время получить описание архитектуры 
и альфа-версию.
Искренне ваш,
Джо Харрикейн, исполнительный директор.
P. S. Прилагаю файлы с исходным кодом WeatherData.
Поздравляем! 
Ваша группа только что выиграла контракт на построение
программного обеспечения метеостанции
следующего поколения.
проект weather station
паттерн наблюдатель
дальше   73
Обзор приложения Weather Monitoring
Рассмотрим приложение Weather Monitoring, которое нам поручено создать, — и то, что Weather-O-Rama нам предоставляет, и то, что нам предстоит построить или расширить. Система состоит из трех компонентов: 
метеостанции (физического устройства, занимающегося сбором данных), 
объекта WeatherData (отслеживает данные, поступающие от метеостанции, и обновляет отображаемую информацию), и экрана, на котором выводится текущая информация о погоде.
Объект
WeatherData Метеостанция Визуальный элемент
Датчик
температуры
Датчик 
влажности
Датчик
давления
получает
данные
отображает Текущее 
состояние
Tмп: 22°
Влажность: 60
Давление:
Объект WeatherData написан в компании Weather-O-Rama; он умеет взаимодействовать с физической погодной станцией для получения обновленных 
данных. Объект WeatherData необходимо адаптировать, чтобы он умел обновлять выводимые данные. Будем надеяться, что Weather-O-Rama расскажет нам, как это делать в исходном коде. Не забудьте, что мы отвечаем за 
реализацию трех разных элементов: текущей сводки погоды (температура, 
влажность и давление), статистики и простого прогноза.
Пользователь может 
просматривать данные 
в одном из трех режимов: 
текущая сводка погоды, 
статистика или прогноз 
погоды.
Наша задача — создать приложение, которое использует 
данные объекта WeatherData для обновления текущих условий, статистики и прогноза погоды.
Это предоставляет 
Weather-O-Rama.
Это необходимо реализовать.
Также необходимо будет 
интегрировать объект 
WeatherData с экраном.
74 глава 2
Как устроен класс WeatherData
WeatherData
getTemperature()
getHumidity()
getPressure()
measurementsChanged()
// Другие методы
Посмотрим исходный код, который нам прислали из компании 
заказчика. Начнем с класса WeatherData.
Эти три метода возвращают новейшие значения температуры, влажности и атмосферного 
давления соответственно.
Нас не интересует, КАК задаются их значения; 
объект WeatherData знает, как получить обновленную информацию от метеостанции.
Каждый раз, когда WeatherData обновляет значения, вызывается метод measurementsChanged().
А это метод measurementsChanged(), 
который, как говорилось выше, вызывается каждый раз, когда WeatherData 
получает новые значения температуры, 
влажности и давления.
/* 
 *
 * Метод вызывается при каждом 
 * обновлении показаний датчиков
 * 
 */
public void measurementsChanged() {
 // Здесь размещается ваш код
}
WeatherData.java
Элемент
Текущее 
состояние
Tмп: 22°
Влажность: 60
Давление: Итак, наша задача – изменить метод measurementsChanged() так, 
чтобы он обновлял изображение для трех элементов: текущего 
состояния, статистики и прогноза.
Экран вывода, который мы скоро
реализуем.
класс погодных данных
Класс WeatherData.
Похоже, заказчик пометил в комментариях 
место для вставки кода. Вероятно, в этом 
месте будет происходить обновление экрана 
(когда мы его реализуем).
дальше   75
паттерн наблюдатель
Наша цель
Мы знаем, что нам поручено реализовать вывод данных, а потом сделать так, 
чтобы объект WeatherData обновлял вывод при каждом появлении новых данных, или, другими словами, при каждом вызове метода measurementsChanged(). 
Но как? Давайте подумаем, чего мы пытаемся добиться:
y Мы знаем, что класс WeatherData содержит get-методы для трех основных метрик: температуры, влажности и атмосферного давления.
y Мы знаем, что метод measurementsChanged() вызывается каждый раз, 
когда появляются новые погодные данные. (Еще раз: мы не знаем, как 
вызывается этот метод, да нас это и не интересует; мы знаем только то, 
что он вызывается.)
y Требуется реализовать три элемента вывода, использующих погодные 
данные: текущую сводку погоды, экран статистики и экран прогноза. 
Эти экраны должны обновляться каждый раз, когда у WeatherData появляются новые данные.
y Для обновления выводимых данных нужно будет добавить код в метод 
measurementsChanged().
Первый элемент
Текущее 
состояние
Тмп: 72°
Влажность: 60
Давление:
Второй элемент
Статистика
Срд. тмп: 62°
Мин. тмп 50°
Макс. тмп: 78°
Третий элемент
Прогноз
TT
T
Будущие элементы
?
Цель на будущее
Но давайте также задумаемся о будущем — помните то единственное, что остается постоянным в ходе разработки? 
Можно предположить, что приложение окажется успешным и в будущем тремя экранами дело уже не ограничится, 
так почему бы не предусмотреть возможность для включения дополнительных экранов? Итак, стоит включить еще 
одну цель:
y Расширяемость — возможно, другие разработчики захотят создать новые, нестандартные экраны. 
Почему бы не разрешить пользователям добавлять 
(или удалять) столько экранных элементов, сколько 
им захочется? В настоящее время нам известны три 
исходных типа экранов (сводка, статистика и прогноз), но в будущем ожидается процветающий рынок для новых экранов.
76 глава 2
public class WeatherData {
 // Объявления переменных экземпляров
 public void measurementsChanged() {
 float temp = getTemperature();
 float humidity = getHumidity();
 float pressure = getPressure();
 currentConditionsDisplay.update(temp, humidity, pressure);
 statisticsDisplay.update(temp, humidity, pressure);
 forecastDisplay.update(temp, humidity, pressure);
 }
 // Другие методы WeatherData
}
...вызовом своего метода 
update, которому переда
ются самые свежие данные.
-
Сначала мы получаем новейшие измерения вызовом 
get-методов WeatherData. Каждое значение присваивается переменной с соответствующим именем.
Первая, неправильная реализация
Ниже приведена первая возможная реализация — как упоминалось ранее, наш 
код будет добавлен в метод measurementsChanged() в классе WeatherData:
? A. Мы программируем на уровне реализаций, а не интерфейсов.
? B. Для каждого нового элемента придется изменять код.
? C. Элементы не могут добавляться 
(или удаляться) во время выполнения.
? D. Элементы не реализуют единый интерфейс.
? E. Переменные аспекты архитектуры 
не инкапсулируются. 
? F. Нарушается инкапсуляция класса 
WeatherData.
Какие из следующих утверждений относятся к первой 
реализации? (Укажите все варианты.)
Затем каждый экран 
обновляется...
первая попытка
Возьми в руку карандаш
Метод measurementsChanged().
А это добавленный нами код...
паттерн наблюдатель
дальше   77
Вернемся к концепциям и принципам, описанным в главе 1, — какие из них здесь нарушаются, а какие 
нет? Обратите особое внимание на последствия изменений в коде. Попробуем проанализировать ход 
мыслей во время просмотра кода:
Чем плоха такая реализация?
public void measurementsChanged() {
 float temp = getTemperature();
 float humidity = getHumidity();
 float pressure = getPressure();
 currentConditionsDisplay.update(temp, humidity, pressure);
 statisticsDisplay.update(temp, humidity, pressure);
 forecastDisplay.update(temp, humidity, pressure);
}
Программируя на уровне конкретной реализации, мы не сможем 
добавлять и удалять визуальные 
элементы без внесения изменений 
в программу.
Похоже на область потенциальных изменений. Этот фрагмент 
необходимо инкапсулировать.
Нечто похожее на общий интерфейс 
взаимодействия с экранными элементами... Каждый элемент имеет 
метод update(), которому передаются значения температуры, влажности 
и давления.
Хорошая мысль. Давайте познакомимся с паттерном Наблюдатель.
Посмотрим еще раз…
А если потребуется добавить 
или удалить экраны во время 
выполнения? Здесь набор экранов жестко фиксируется.
Ммм... Я, конечно, новичок, но раз уж глава посвящена паттерну Наблюдатель, так, 
может, мы им воспользуемся?
78 глава 2
Знакомство с паттерном Наблюдатель
Всем известно, как работает подписка на газету или 
журнал:
Издатель открывает свое дело и начинает выпускать газету.
Вы оформляете подписку у конкретного издателя. Каждый раз, когда выходит новый номер, он доставляется 
вам. Пока подписка действует, вы получаете новые выпуски газеты.
Если вы не хотите больше получать газету, вы прекращаете подписку. 
Пока газета продолжает публиковаться, люди, гостиницы, авиалинии и т. д. постоянно оформляют и прекращают подписку.
1
2
3
4
знакомство с паттерном наблюдатель
Никак нельзя упускать
последние новости. 
Конечно, мы подпишемся!
паттерн наблюдатель
дальше   79
Объекты-наблюдатели
Наблюдатели регистрируются у субъекта, чтобы получать оповещения при изменении его данных.
Субъект управляет 
некими данными.
Субъект
2
int
Объект Dog
Объект Mouse
Объект Cat
Если вы понимаете, как работает газетная подписка, вы в значительной мере понимаете и паттерн Наблюдатель, только 
в данном случае издатель называется СУБЪЕКТОМ, а подписчики — НАБЛЮДАТЕЛЯМИ. 
Присмотримся повнимательнее.
2
2
2
Когда данные субъекта изменяются, наблюдатели получают 
оповещения.
При изменении данных новые 
значения передаются наблюдателям.
Объект Duck
А этот объект не является 
наблюдателем, поэтому он не 
получает оповещений при изменении данных субъекта.
Издатели + Подписчики = Паттерн Наблюдатель
80 глава 2
Один день из жизни паттерна Наблюдатель
Объект Duck сообщает 
субъекту, что он хочет 
стать наблюдателем.
Объект Duck хочет быть в курсе 
дела; эти значения int, которые 
субъект рассылает при изменении состояния, выглядят так 
интересно...
Наблюдатели
Субъект
2
int
Объект Dog
Объект Mouse
Объект Cat
Объект Duck
Субъект
2
int
Наблюдатели
Объект Dog
Объект Mouse
Объект Ca
Об
t
ъект Duck
Объект Duck стал 
официальным 
наблюдателем.
Объект Duck включен в список... 
Теперь он с нетерпением ждет 
следующего оповещения, с которым он получит интересующее его значение int.
Субъект
8
int
Объект Dog
Объект Mouse
Объект Ca
О
t
бъект Duck
У субъекта появились 
новые данные!
Duck и все остальные наблюдатели оповещаются об изменении состояния субъекта.
Наблюдатели
8
8
8
8
«Зарегистрируй меня»
один день из жизни паттерна наблюдатель
паттерн наблюдатель
дальше   81
Объект Mouse требует 
исключить его из числа 
наблюдателей.
Объекту Mouse надоело получать 
оповещения, и он решил, что 
пришло время выйти из числа 
наблюдателей.
Mouse уходит!
Субъект принимает запрос объекта Mouse и исключает его из числа наблюдателей.
Субъект
14
int
Объект Dog
Объект Mouse
Объект Ca
Об
t
ъект Duck
У субъекта появилось новое 
значение int.
Все наблюдатели получают очередное оповещение, кроме объекта Mouse, который исключен 
из списка. Не говорите никому, 
но он тайно скучает по этим 
оповещениям... и, возможно, когда-нибудь снова войдет в число 
наблюдателей.
Наблюдатели
Субъект
8
int
Объект Dog
Объект Mouse
Объект Cat
Наблюдатели
Субъект
8
int
Объект Dog
Объект Mouse
Объект Ca
Об
t
ъект Duck
Наблюдатели
14
14
14
«Исключите меня»
Объект Duck
82 глава 2
Программист № 1
3
Программист № 2
Субъект/«Охотник за головами»
2
1
4
Субъект
Пятиминутная драма: субъект для наблюдения
В сегодняшней серии два программиста, переживших крах «доткомов», 
встречают настоящего «охотника за головами»...
пятиминутная драма
Говорит 
Лори, я ищу вакансию 
программиста на Java. 
У меня пятилетний опыт 
работы, а еще...
Да, у тебя... и у всех 
остальных. Включаю 
тебя в мой список Javaпрограммистов. И не звони 
мне, я сам тебе позвоню!
Привет, это Джил. 
Я занималась EJBсистемами, и меня интересует 
любая работа, связанная 
с программированием на Java.
Включаю в список. 
Буду оповещать, как 
и всех остальных.
паттерн наблюдатель
дальше   83
6
Субъект
Субъект 9
7
Наблюдатель Наблюдатель
Наблюдатель
5 Тем временем жизнь Лори и Джил 
продолжается. Если появится вакансия Java-программиста, они об этом 
узнают — ведь они стали наблюдателями.
Джил нашла себе работу!
8
Гррр! Попомни мои 
слова, Джил, я никогда не 
буду искать для тебя работу. 
Ты исключена из списка 
навсегда!!!
Исключайте меня 
из списка, у меня 
есть работа!
Эй, наблюдатели, 
на JavaBeans-R-Us 
появилось место — 
хватайте, пока есть!
Спасибо, 
я немедленно 
вышлю резюме.
Сплошные 
понты, а толку 
никакого. Я сама найду 
себе работу.
Ха-ха, я получил 
свой процент!
84 глава 2
Джил вышла из числа наблюдателей 
и наслаждается жизнью. Кроме того, она 
получила неплохую поощрительную 
премию при вступлении в должность, 
потому что компании не пришлось 
оплачивать услуги «охотника за головами».
Прошло две недели...
А что случилось с нашей дорогой Лори? 
Говорят, она сама стала подрабатывать 
поиском вакансий. Теперь она не только 
остается в списке, но и завела собственный список. Таким образом, Лори одновременно является и субъектом, и наблюдателем.
продолжение пятиминутной драмы
паттерн наблюдатель
дальше   85
Паттерн Наблюдатель определяет отношение 
«один ко многим» между объектами таким образом, 
что при изменении состояния одного объекта происходит автоматическое оповещение и обновление всех зависимых объектов.
Определение паттерна Наблюдатель
Если вы пытаетесь мысленно представить паттерн Наблюдатель, модель подписки с издателями и подписчиками дает неплохое представление о ней.
А в реальном мире паттерн Наблюдатель обычно определяется так:
Субъект и наблюдатели определяют отношение «один ко многим». Имеется один субъект, который уведомляет многих наблюдателей об изменениях в субъекте. Наблюдатели зависят от 
субъекта: при изменении состояния последнего наблюдатели 
получают оповещения. 
Как вы вскоре увидите, существует много разных вариантов 
реализации паттерна Наблюдатель, но большинство из них 
строится на основе классов, реализующих интерфейсы субъекта или наблюдателя.
Паттерн Наблюдатель 
определяет отношение типа 
«один ко многим» между 
объектами.
Когда состояние одного 
объекта изменяется, все 
зависимые объекты получают оповещения.
Попробуем связать это определение с нашим представлением о паттерне.
Субъект
8
int
Объект Dog
Объект Mouse
Объект Ca
О
t
бъект Duck
Наблюдатели
8
8
8
8
ОТНОШЕНИЕ «ОДИН КО МНОГИМ»
Автоматическое
обновление/оповещение
Объект
с состоянием
Зависимые
объекты
86 глава 2
<<interface>>
Subject
registerObserver()
removeObserver()
notifyObservers()
<<interface>>
Observer
update()
registerObserver() {...}
removeObserver() {...}
notifyObservers() {...}
getState()
setState()
ConcreteSubject
Интерфейс субъекта.
Используется объектами 
для регистрации в качестве 
наблюдателя, а также исключения из списка.
Каждый потенциальный наблюдатель должен реализовать 
интерфейс Observer. Интерфейс содержит единственный метод update(), который 
вызывается при изменении 
состояния субъекта.
Наблюдатели могут относиться к любому классу, реализующему интерфейс 
Observer. Каждый наблюдатель регистрируется у конкретного субъекта 
для получения обновлений.
Субъект реализует интерфейс 
Subject. Кроме методов регистрации и исключения, субъект также реализует метод 
notifyObservers(), оповещающий 
всех текущих наблюдателей об 
изменении состояния.
update()
// Другие методы конкретного наблюдателя
ConcreteObserver
Паттерн Наблюдатель: диаграмма классов
Субъект также может иметь 
get- и set-методы для изменения состояния (см. далее).
наблюдатели
субъект
Каждый субъект 
может иметь много 
наблюдателей.
В: При чем здесь отношения «один 
ко многим»?
О: В паттерне Наблюдатель субъект 
обладает состоянием и управляет им. 
Таким образом, существует ОДИН субъект, обладающий состоянием. С другой 
стороны, наблюдатели используют состояние, хотя и не обладают им. Они 
зависят от субъекта, который оповещает 
их об изменении состояния. Возникает 
отношение, в котором участвует ОДИН 
субъект и МНОГО наблюдателей.
В: При чем здесь зависимости?
О: Так как субъект является единоличным владельцем данных, работа наблюдателей зависит от субъекта, оповещающего их об изменении данных. Так 
формируется элегантная ОО-структура, 
в которой многие объекты используют 
одни и те же данные.
В: Я также слышал о паттерне Публикация-подписка. Это другое название паттерна Наблюдатель?
О: Нет, хотя они связаны. Публикация-подписка — более сложный паттерн, который позволяет подписчикам 
выразить свой интерес к сообщениям 
определенного типа и способствует 
дальнейшему отделению публикаторов 
от подписчиков. Этот паттерн часто применяется в промежуточных (middleware) 
системах.
паттерн наблюдатель
часто Задаваемые вопросы
Рассмотрим структуру паттерна Наблюдатель с классами Subject 
и Observer. Диаграмма классов выглядит так:
паттерн наблюдатель
дальше   87
Гуру и ученик...
Гуру: Мы уже говорили о слабых связях?
Ученик: Гуру, я не припоминаю такого.
Гуру: Представь себе плотно сплетенную корзину. Она 
жесткая или гибкая?
Ученик: Жесткая, гуру.
Гуру: А какая корзина проще разделяется на части — 
жесткая или гибкая?
Ученик: Гибкая разделяется проще.
Гуру: А если в наших программных архитектурах объекты 
будут менее прочно сплетены друг с другом, будет ли 
архитектура проще делиться на составные части?
Ученик: Гуру, я понимаю, о чем вы. Но что это означает — 
объекты «менее прочно связаны»?
Гуру: Обычно это называется «слабой связанностью».
Ученик: Вот как!
Гуру: Мы говорим, что объект сильно связан с другим 
объектом, если он слишком зависит от этого объекта.
Ученик: Выходит, слабо связанный объект не может 
зависеть от другого объекта?
Гуру: Обратись к природе; все живые существа зависят 
друг от друга. Точно так же все объекты зависят от других 
объектов. Однако слабо связанный объект почти ничего не 
знает о внутреннем устройстве другого объекта, да ему 
это и не нужно.
Ученик: Но гуру, что в этом хорошего? Конечно, не знать —
хуже, чем знать.
Гуру: Вижу, ты добился определенных успехов, но тебе еще 
многое предстоит узнать. Если ты ничего не знаешь о 
других объектах, то ты сможешь создавать архитектуры, 
которые лучше справляются с изменениями. Архитектуры, 
которые обладают большей гибкостью, — как неплотно 
сплетенная корзина.
Ученик: Конечно, я уверен, что вы правы. А можно пример?
Гуру: На сегодня хватит.
88 глава 2
слабые связи
Сила слабых связей
Когда два объекта слабо связаны, они могут взаимодействовать друг с другом, но обычно обладают минимумом информации друг о друге. Как вы вскоре увидите, архитектуры со слабыми связями часто 
обладают большой гибкостью (подробности чуть ниже). И как выясняется, паттерн Наблюдатель является отличным примером слабого связывания. А теперь посмотрим, каким образом этот паттерн 
достигает слабого связывания:
На базе слабосвязанных архитектур строятся 
гибкие ОО-системы, которые хорошо адаптируются к изменениям благодаря минимальным 
зависимостям между объектами.
Принцип проектирования
Стремитесь к слабой связанности 
взаимодействующих объектов.
Смотрите-ка! Новый принцип 
проектирования!
Единственное, что знает субъект о наблюдателе, — то, что тот реализует некоторый интерфейс (Observer). Ему не нужно знать ни конкретный 
класс наблюдателя, ни его функциональность... ничего. 
Новые наблюдатели могут добавляться в любой момент. Так как субъект 
зависит только от списка объектов, реализующих интерфейс Observer, вы 
можете добавлять новых наблюдателей по своему усмотрению. Любого наблюдателя во время выполнения можно заменить другим наблюдателем или 
исключить его из списка — субъект этого не заметит. 
Добавление новых типов наблюдателей не требует модификации субъекта. Допустим, у нас появился новый класс, который должен стать наблюдателем. Вносить изменения в субъект не потребуется — достаточно 
реализовать интерфейс Observer в новом классе и зарегистрировать его 
в качестве наблюдателя. Субъект будет доставлять оповещения любому объекту, реализующему интерфейс Observer.
Субъекты и наблюдатели могут повторно использоваться независимо 
друг от друга. Между ними не существует сильных связей, что позволяет 
повторно использовать их для других целей.
Изменения в субъекте или наблюдателе не влияют на другую сторону.
Благодаря слабым связям мы можем вносить любые изменения на любой из 
двух сторон — при условии, что объект реализует необходимый интерфейс 
субъекта или наблюдателя.
Сколько разных 
видов изменений 
вы здесь насчитаете?
паттерн наблюдатель
дальше   89
Прежде чем двигаться дальше, попробуйте составить предварительную диаграмму классов проекта Weather Station, включая класс WeatherData и его визуальные элементы. На диаграмме должны быть обозначены связи между всеми 
компонентами, а также механизмы реализации визуальных элементов другими 
разработчиками.
Если вам понадобится помощь, обратитесь к следующей странице. На ней 
ваши коллеги уже обсуждают архитектуру Weather Station.
Возьми в руку карандаш
90 глава 2
разговоры о погоде
Разговор в офисе
Мэри: Надо воспользоваться паттерном Наблюдатель.
Сью: Верно... Но как мы будем его применять?
Мэри: Хмм... Давай еще раз взглянем на определение:
Мэри: В принципе, вполне логично. Класс WeatherData — «один», а разные визуальные элементы, использующие данные метеостанции, — «многие».
Сью: Точно. Класс WeatherData обладает состоянием — это температура, влажность 
и давление. И безусловно, состояние будет изменяться.
Мэри: И при изменении состояния мы оповещаем визуальные элементы, чтобы 
они могли поступить с новыми данными по своему усмотрению.
Сью: Отлично. Я вижу, что паттерн Наблюдатель подходит для нашей задачи.
Мэри: Однако некоторые моменты мне пока непонятны.
Сью: Например?
Мэри: Скажем, как мы будем передавать обновленные данные визуальным элементам?
Сью: Давай-ка еще раз посмотрим на диаграмму паттерна Наблюдатель... Если сделать объект WeatherData субъектом, а визуальные элементы наблюдателями, то элементы будут регистрироваться у объекта WeatherData для получения нужной информации?
Мэри: Да... и если субъект будет располагать информацией о визуальном элементе, 
то он сможет просто вызвать его метод для передачи данных.
Сью: Но визуальные элементы такие разные... Похоже, здесь уместно воспользоваться общим интерфейсом. Хотя все компоненты относятся к разным типам, они 
реализуют общий интерфейс, поэтому объект WeatherData всегда будет знать, как 
передать им обновленные данные.
Мэри: Выходит, каждый визуальный элемент будет поддерживать метод... допустим, 
update(), который будет вызываться объектом WeatherData?
Сью: Да, причем метод update() будет определяться в общем интерфейсе, который 
реализуется всеми элементами.
Паттерн Наблюдатель определяет отношение «один ко многим» между объектами таким 
образом, что при изменении состояния одного объекта происходит автоматическое оповещение и обновление всех зависимых объектов.
Тем временем ваши коллеги по проекту Weather Station уже начали обдумывать проблему...
Ну и как мы будем Сью
строить эту штуку?
паттерн наблюдатель
дальше   91
Проектирование Weather Station
<<interface>>
Subject
registerObserver()
removeObserver()
notifyObservers()
<<interface>>
Observer
update()
registerObserver() 
removeObserver() 
notifyObservers()
getTemperature()
getHumidity()
getPressure()
measurementsChanged()
WeatherData
update()
display() { // Вывод текущих 
параметров }
CurrentConditionsDisplay
update() 
display() { // Вывод статистики }
StatisticsDisplay
update()
display() { // Вывод прогноза }
ForecastDisplay
Интерфейс субъекта
выглядит знакомо.
Все погодные элементы 
реализуют интерфейс 
Observer. С этим интерфейсом взаимодействует субъект, когда 
приходит время обновления наблюдателей.
Элемент выводит 
текущие значения 
переменных объек
та WeatherData.
-
Элемент вычисляет 
и выводит минимальное, среднее и максимальное значения.
Элемент выводит прогноз погоды по показаниям барометра.
Объкт WeatherData 
реализует интерфейс Subject.
наблюдатели
субъект
update()
display() { // Вывод другой 
информации на основании 
полученных данных }
ThirdPartyDisplay
Разработчики реализуют 
интерфейсы Observer 
и Display для 
создания собственных
визуальных
элементов.
<<interface>>
DisplayElement
display()
Также определяем интерфейс, реализуемый всеми 
визуальными элементами. 
Каждый элемент должен 
реализовать метод display().
Эти три элемента также должны содержать указатель на объект WeatherData, но тогда диаграмма
станет слишком запутанной.
Похожа ли эта диаграмма на ту, которую нарисовали вы?
92 глава 2
public interface DisplayElement {
 public void display();
}
public interface Observer {
 public void update(float temp, float humidity, float pressure);
}
Реализация Weather Station
Итак, теперь у вас есть рекомендации от Мэри и Сью (парой страниц ранее) и диаграмма с описанием общей структуры классов. Можно начать 
работу над нашей реализацией погодной станции. Начнем с интерфейсов:
Оба метода получают в аргументе реализацию Observer 
(регистрируемый или исключаемый наблюдатель).
Этом метод вызывается для оповещения наблюдателей об изменении 
состояния субъекта.
Интерфейс Observer 
реализуется всеми наблюдателями; таким 
образом, все наблюдатели должны реализовать метод update().
Данные состояния, передаваемые наблюдателям при изменении состояния 
субъекта.
Интерфейс DisplayElement содержит всего один метод display(), 
который вызывается для отображения визуального элемента.
public interface Subject {
 public void registerObserver(Observer o);
 public void removeObserver(Observer o);
 public void notifyObservers();
}
реализация погодной станции
Мозговой
штурм
Мэри и Сью считают, что прямая передача данных наблюдателям является 
самым простым способом обновления состояния. Насколько это разумно, 
по вашему мнению? Подсказка: может ли эта область приложения измениться в будущем? А если изменится, то будут ли изменения надежно инкапсулированы или изменения придется вносить во многих местах кода?
Можете ли вы предложить другие способы передачи обновленного состояния наблюдателям?
Мы еще вернемся к этому аспекту архитектуры после завершения исходной реализации.
паттерн наблюдатель
дальше   93
public class WeatherData implements Subject {
 private ArrayList observers;
 private float temperature;
 private float humidity;
 private float pressure;
 
 public WeatherData() {
 observers = new ArrayList();
 }
 
 public void registerObserver(Observer o) {
 observers.add(o);
 }
 
 public void removeObserver(Observer o) {
 observers.remove(o);
 }
 
 public void notifyObservers() {
 for (Observer observer : observers) {
 observer.update(temperature, humidity, pressure);
 }
 }
 
 public void measurementsChanged() {
 notifyObservers();
 }
 
 public void setMeasurements(float temperature, float humidity, float pressure) {
 this.temperature = temperature;
 this.humidity = humidity;
 this.pressure = pressure;
 measurementsChanged();
 }
 
 // Другие методы WeatherData
}
Реализация интерфейса Subject в WeatherData
Оповещение наблюдателей
о появлении новых данных.
Помните нашу первую попытку реализации класса 
WeatherData в начале главы? Пора вернуться и привести 
ее в порядок, ориентируясь на паттерн Наблюдатель.
Теперь WeatherData реализует 
интерфейс Subject.
Новые наблюдатели просто
добавляются в конец списка.
Если наблюдатель хочет отменить 
регистрацию, мы просто удаляем
его из списка.
Самое интересное: оповещение наблюдателей об изменении состояния через метод update(), реализуемый всеми наблюдателями. 
Приложить метеостанцию к каждому экземпляру книги нам не разрешили, поэтому 
вместо чтения данных с устройства мы 
воспользуемся тестовым методом. При 
желании вы можете написать код для
загрузки погодных данных из интернета.
Добавляем контейнер ArrayList 
для хранения наблюдателей
и создаем его в конструкторе.
Реализация интерфейса Subject.
ВНИМАНИЕ: директивы import 
и package в листингах не приводятся. Полный исходный код 
можно загрузить на сайте 
https://wickedlysmart.com/
headfirst-design-patterns/.
94 глава 2
public class CurrentConditionsDisplay implements Observer, DisplayElement {
 private float temperature;
 private float humidity;
 private Subject weatherData;
 
 public CurrentConditionsDisplay(Subject weatherData) {
 this.weatherData = weatherData;
 weatherData.registerObserver(this);
 }
 
 public void update(float temperature, float humidity, float pressure) {
 this.temperature = temperature;
 this.humidity = humidity;
 display();
 }
 
 public void display() {
 System.out.println("Current conditions: " + temperature 
 + "F degrees and " + humidity + "% humidity");
 }
}
Переходим к визуальным элементам
Элемент реализует Observer, 
чтобы получать данные от 
объекта WeatherData.
При вызове update() мы сохраняем 
значения температуры и влажности, 
после чего вызываем display().
Метод display() просто 
выводит текущие значения 
температуры и влажности.
Итак, мы разобрались с классом WeatherData; пришло время заняться визуальными элементами. В задании перечислены три элемента: для вывода текущего состояния, статистики 
и прогноза. Начнем с текущего состояния; когда вы достаточно хорошо поймете его код, 
рассмотрите другие примеры из архива на сайте книги — они очень похожи.
Также он реализует интерфейс 
DisplayElement, как и все визуальные элементы в нашем API.
Конструктору передается 
объект WeatherData, который 
используется для регистрации 
элемента в качестве наблюдателя.
В: Правильно ли вызывать display() 
в методе update()?
О: В нашем простом примере метод 
display() логично вызывать при изменении 
данных. Однако вы правы, существуют 
и более элегантные способы проектирования отображения данных. Они будут 
представлены при рассмотрении паттерна 
Модель–Представление–Контроллер.
В: Зачем сохранять ссылку на Subject, 
если она не используется после вызова 
конструктора?
О: Верно, но в будущем мы реализуем 
отмену регистрации наблюдателей. Для 
этого будет удобно иметь готовую ссылку 
на реализацию Subject.
построение экранов
часто Задаваемые вопросы
паттерн наблюдатель
дальше   95
Тестирование Weather Station
%java WeatherStation
Current conditions: 80.0F degrees and 65.0% humidity
Avg/Max/Min temperature = 80.0/80.0/80.0
Forecast: Improving weather on the way!
Current conditions: 82.0F degrees and 70.0% humidity
Avg/Max/Min temperature = 81.0/82.0/80.0
Forecast: Watch out for cooler, rainy weather
Current conditions: 78.0F degrees and 90.0% humidity
Avg/Max/Min temperature = 80.0/82.0/78.0
Forecast: More of the same
%
File Edit Window Help StormyWeather
public class WeatherStation {
 public static void main(String[] args) {
 WeatherData weatherData = new WeatherData();
 
 CurrentConditionsDisplay currentDisplay = 
 new CurrentConditionsDisplay(weatherData);
 StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
 ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);
 weatherData.setMeasurements(80, 65, 30.4f);
 weatherData.setMeasurements(82, 70, 29.2f);
 weatherData.setMeasurements(78, 90, 29.2f);
 }
}
Первая версия Weather Station готова; нужен лишь код, который свяжет воедино все компоненты. Вскоре мы добавим новые экраны и 
немного обобщим код. А пока рассмотрим первый вариант:
1 Для начала напишем тестовую программу.
2 Выполняем код и следим за тем, как работает паттерн Наблюдатель.
Сначала создаем 
объект WeatherData.
Создаем три визуальных 
элемента, передавая им 
объект WeatherData.
Имитация новых 
погодных данных.
Если вы не 
хотите загружать код 
с сайта, закомментируйте эти две 
строки.
96 глава 2
Субъект и Наблюдатель обсуждают механизм 
получения данных состояния.
Субъект Наблюдатель
Я рад, что у нас наконец-то появилась возможность побеседовать лично. Правда? Я думал, что вы не обращаете никакого 
внимания на нас, наблюдателей.
Ну я же делаю свое дело, верно? Я всегда сообщаю вам о том, что происходит... И хотя я не 
знаю, кто вы, это не значит, что мне это безразлично. К тому же я знаю самое главное — вы реализуете интерфейс Observer.
Да, но это далеко не все. К тому же о вас я знаю 
намного больше...
Вот как? Например? Вы постоянно передаете нам, наблюдателям, 
данные состояния, чтобы мы знали, что у вас 
происходит. Иногда это начинает слегка раздражать...
Ах, извините. Я должен передавать свое состояние с оповещениями, чтобы ленивые наблюдатели были в курсе дела! Одну минуту; во-первых, мы не ленивые, просто 
нам приходится заниматься другими делами 
между вашими важными оповещениями. А вовторых, почему бы вам не разрешить нам обращаться за данными, когда мы этого захотим, 
вместо того чтобы заталкивать их насильно?
В принципе такое возможно. Но мне придется 
ослабить ограничения доступа, чтобы вы, наблюдатели, могли прийти и получить нужную информацию. А это, знаете ли, рискованно. Я не могу позволить всем желающим копаться в своих личных 
данных.
беседа у камина: субъект и наблюдатель
Беседа у камина
паттерн наблюдатель
дальше   97
Субъект Наблюдатель
Почему бы вам не предоставить открытые getметоды, которые позволят нам получить необходимые данные состояния?
Да, я могу разрешить вам запрашивать данные 
состояния. Но разве это не будет менее удобно 
для вас? Возможно, для получения всех необходимых данных вам придется многократно обращаться ко мне с вызовами. Вот почему я предпочитаю активную доставку... Все необходимое 
отправляется за один вызов.
Существует много разных наблюдателей; невозможно заранее предвидеть все, что нам может 
понадобиться. Если нам нужна только часть 
данных, не обязательно загружать все состояние. Кроме того, упрощается внесение изменений в будущем. Если в программе вводятся 
новые данные состояния, не нужно изменять 
вызовы update() на каждом наблюдателе — просто включите в свою реализацию get-методы 
для чтения дополнительного состояния.
Что ж, как я люблю говорить: «Не звоните нам, 
мы вам сами позвоним!» Но пожалуй, об этом 
стоит подумать.
Я молчать не стану...
Почем знать, чудеса иногда случаются.
Понятно, последнее слово оставляем за собой.
Еще бы.
98 глава 2
программирование теплового индекса
%java WeatherStation
Current conditions: 80.0F degrees and 65.0% humidity
Avg/Max/Min temperature = 80.0/80.0/80.0
Forecast: Improving weather on the way!
Heat index is 82.95535
Current conditions: 82.0F degrees and 70.0% humidity
Avg/Max/Min temperature = 81.0/82.0/80.0
Forecast: Watch out for cooler, rainy weather
Heat index is 86.90124
Current conditions: 78.0F degrees and 90.0% humidity
Avg/Max/Min temperature = 80.0/82.0/78.0
Forecast: More of the same
Heat index is 83.64967
%
File Edit Window Help OverdaRainbow
Вам только что звонили из руководства Weather-O-Rama — в приложение необходимо добавить 
новый визуальный элемент для отображения теплового индекса. Подробности:
Тепловым индексом называется показатель эффективной (то есть субъективно воспринимаемой) 
температуры, который вычисляется по значениям температуры T и относительной влажности RH. 
Формула вычисления теплового индекса выглядит так:
Начинайте вводить! 
Шутка. Не беспокойтесь, вам не придется вводить эту формулу; создайте файл HeatIndexDisplay.
java и скопируйте в него формулу из файла heatindex.txt. 
Как работает эта формула? Понятия не имеем. Попробуйте спросить кого-нибудь в Национальной 
метеорологической службе (или воспользуйтесь поиском Google).
В новой версии результат будет выглядеть так:
Изменения
 16.923 + 1.85212 * 10–1 * T + 5.37941 * RH – 1.00254 * 10–1 * T * 
RH + 9.41695 * 10–3 * T2 + 7.28898 * 10–3 * RH2 + 3.45372 * 10–4 * T2
* RH – 8.14971 * 10–4 * T * RH2 + 1.02102 * 10–5 * T2 * RH2 – 3.8646 * 
10–5 * T3 + 2.91583 * 10–5 * RH3 + 1.42721 * 10–6 * T3 * RH + 1.97483 
* 10–7 * T * RH3 – 2.18429 * 10–8 * T3 * RH2 + 8.43296 * 10–10 * T2 * 
RH3 – 4.81975 * 10–11 * T3 * RH3
Файл heatindex.txt можно загрузить на сайте wickedlysmart.com
heatindex =
Возьми в руку карандаш
паттерн наблюдатель
дальше   99
Паттерн Наблюдатель в естественной среде
Паттерн Наблюдатель — один из самых популярных паттернов, и вы найдете 
множество примеров использования этого паттерна в разных библиотеках 
и фреймворках. Например, если взглянуть на код JDK (Java Development Kit), 
паттерн Наблюдатель используется в библиотеках JavaBeans и Swing. Паттерн 
также не ограничивается языком Java; он используется в событиях JavaScript, 
в Cocoa, в протоколе отслеживания ключей/значений Swift… и это далеко не 
полный список. Одно из преимуществ знания паттернов проектирования — 
умение распознавать и быстро понимать причины тех или иных архитектурных 
решений в ваших любимых библиотеках. Ненадолго отвлечемся на библиотеку 
Swing и посмотрим, как в ней используется паттерн Наблюдатель.
Приложение довольно простое: при нажатии кнопки с вопросом слушатели (наблюдатели) 
могут ответить на вопрос так, как считают нужным. Мы реализовали двух таких Наблюдателей: 
AngelListener и DevilListener. Вот как работает приложение:
Если вас интересует поддержка паттерна Наблюдатель 
в JavaBeans, присмотритесь к интерфейсу PropertyChangeListener.
Вероятно, вы уже знаете, что Swing — GUI-инструментарий для построения пользовательских 
интерфейсов на языке Java. Один из основополагающих компонентов этого инструментария — класс 
JButton. Присмотревшись к коду суперкласса JButton (AbstractButton), можно заметить, что он 
содержит множество методов добавления/удаления слушателей. Эти методы позволяют добавлять 
и удалять слушателей и прослушивать различные типы событий, происходящих с компонентом 
Swing. Например, ActionListener позволяет прослушивать различные типы действий, выполняемых 
с кнопками (например, нажатий). Разные типы слушателей часто встречаются в Swing API.
Библиотека Swing
Судьбоносное решение
%java SwingObserverExample
Come on, do it!
Don’t do it, you might regret it!
%
Данные, выводимые при 
нажатии кнопки.
Лаконичный интерфейс.
Совет ангела
Совет дьявола
File Edit Window Help HeMadeMeDoIt
100 глава 2
использование наблюдателей для слушателей действий
public class SwingObserverExample {
 JFrame frame;
 public static void main(String[] args) {
 SwingObserverExample example = new SwingObserverExample();
 example.go();
 }
 public void go() {
 frame = new JFrame();
 JButton button = new JButton("Should I do it?");
 button.addActionListener(new AngelListener());
 button.addActionListener(new DevilListener());
 // Set frame properties here
 }
 class AngelListener implements ActionListener {
 public void actionPerformed(ActionEvent event) {
 System.out.println("Don't do it, you might regret it!");
 }
 }
 class DevilListener implements ActionListener {
 public void actionPerformed(ActionEvent event) {
 System.out.println("Come on, do it!");
 }
 }
}
Наше приложение требует минимума кода. Все, что от нас потребуется, — создать объект JButton, 
добавить его в JFrame и настроить Слушателей. В качестве слушателей будут использоваться внутренние 
классы (типичный прием в программировании Swing). Если вы еще не знакомы с внутренними 
классами или Swing, вам стоит прочитать главу о Swing в вашем любимом справочнике по Java.
Программирование маленького шедевра
Простое приложение Swing создает 
панель и размещает на ней кнопку.
Назначает объекты слушателями (наблюдателями) событий кнопки.
Здесь размещается код подготовки фрейма.
Определения наблюдателей 
в виде внутренних классов 
(хотя возможны и другие 
способы).
При изменении состояния субъекта (в данном случае кнопки) 
вместо update() вызывается 
метод actionPerformed().
паттерн наблюдатель
дальше   101
public class SwingObserverExample {
 JFrame frame;
 public static void main(String[] args) {
 SwingObserverExample example = new SwingObserverExample();
 example.go();
 }
 public void go() {
 frame = new JFrame();
 JButton button = new JButton("Should I do it?");
 button.addActionListener(event -> 
 System.out.println("Don't do it, you might regret it!"));
 button.addActionListener(event -> 
 System.out.println("Come on, do it!"));
 // Set frame properties here
 }
}
Обновленный код с использованием лямбда-выражений:
Лямбда-выражения появились в Java 8. 
Если вы с ними не знакомы, не огорчайтесь; вы можете продолжить 
пользоваться внутренними классами 
для наблюдателей Swing.
Как насчет того, чтобы сделать следующий шаг в использовании паттерна Наблюдатель? 
Если использовать лямбда-выражение вместо внутреннего класса, можно обойтись без 
создания объекта ActionListener. С лямбда-выражением вместо этого создается объект 
функции, и объект функции становится наблюдателем. При передаче этого объекта функции 
addActionListener() Java проверяет, что его сигнатура соответствует actionPerformed() — 
единственному методу интерфейса ActionListener.
Когда пользователь щелкнет на кнопке, объект кнопки оповещает об этом своих наблюдателей, включая объекты функций, созданные лямбда-выражениями, и вызывает метод 
actionPerformed() каждого слушателя.
А теперь посмотрим, как использовать лямбда-выражения в качестве наблюдателей для упрощения приведенного кода.
Мы заменили объекты 
AngelListener и DevilListener 
лямбда-выражениями, которые реализуют ту же 
функциональность, что 
и прежде.
Когда пользователь 
щелкает на кнопке, объекты функций, созданные 
лямбда-выражениями, 
получают оповещения об 
этом событии, после чего 
выполняется реализуемый 
ими метод.
С лямбда-выражениями 
этого код становится 
намного более компактным.
Два класса ActionListener (DevilListener 
и AngelListener) полностью исключены.
За дополнительной информацией о лямбда-выражениях 
обращайтесь к документации Java и главе 6.
Для любознательных
102 глава 2
снова об отправке и получении данных
Я вспомнил то обсуждение отправки/
получения данных, которое приводилось 
выше. Нельзя ли слегка обобщить код, если 
разрешить экранам получать свои данные 
от объекта WeatherData по мере надобности? 
Такой подход может упростить добавление 
новых экранов в будущем.
В: Я думал, что в Java есть классы Observer и Observable?
О: Хороший вопрос. Когда-то язык Java предоставлял класс 
Observable (субъект) и интерфейс Observer, которые можно было 
использовать для интеграции паттерна Наблюдатель в ваш код. 
Класс Observable предоставлял методы для добавления, удаления 
и уведомления наблюдателей, чтобы вам не приходилось писать 
этот код самостоятельно. А интерфейс Observer предоставлял 
такой же интерфейс, как у нас, с единственным методом 
update(). Начиная с Java 9, эти классы считаются устаревшими. 
Разработчики либо считали, что им проще поддерживать базовый 
паттерн Наблюдатель в своем коде, либо хотели чего-то более 
надежного, поэтому классы Observer/Observable уходят в небытие.
В: Java предоставляет другую встроенную поддержку 
паттерна Наблюдатель для замены этих классов?
О: JavaBeans предлагает такую встроенную поддержку в виде 
событий PropertyChangeEvent. Эти события генерируются, когда 
Bean-компонент изменяет конкретный тип свойства и отправляет 
уведомления слушателям PropertyChangeListener. Также другие 
компоненты «публикатор/подписчик» существуют в Flow API для 
управления асинхронными потоками.
В: Можно ли рассчитывать на то, что уведомления от 
субъекта к наблюдателям будут поступать в определенном 
порядке?
О: Что касается реализации Observer в Java, разработчики JDK 
специально рекомендуют не зависеть от какого-либо конкретного 
порядка уведомлений. 
Хорошая мысль. 
В нашей текущей архитектуре все три значения данных отправляются методу update() 
в экранах, даже если какие-то из них этим экранам не нужны. Но что, если позднее 
Weather-O-Rama добавит другое значение данных, например скорость ветра? Тогда 
нам придется изменять все методы update() во всех экранах, даже если многим из них 
данные о скорости ветра не нужны.
Теперь вопрос о том, будет ли использоваться отправка или получение данных 
Observer, становится подробностью реализации, но во многих случаях будет разумно 
разрешить наблюдателям получать нужные данные, вместо того чтобы отправлять 
все больше и больше данных методом update(). Со временем эта область может 
измениться и разрастись до неуправляемости. И мы знаем, что заказчик собирается 
расширять приложение и продавать новые варианты экранов. А значит, стоит лишний 
раз проанализировать архитектуру и посмотреть, нельзя ли упростить ее возможные 
расширения в будущем.
Обновление кода позволит наблюдателям достаточно прямолинейно получать нужные 
им данные. Все, что для этого нужно, — убедиться в том, что у субъекта имеются getметоды для его данных, а затем изменить наблюдателей, чтобы они могли использоваться 
для получения данных в соответствии с тем, что им требуется. Давайте займемся этим.
.
часто Задаваемые вопросы
паттерн наблюдатель
дальше   103
Чтобы наблюдатель получал уведомления...
Чтобы субъект отправлял уведомления…
Изменим метод notifyObservers() в WeatherData, чтобы он вызывал 
метод update() наблюдателей без аргументов: 
public void notifyObservers() {
for (Observer observer : observers) {
observer.update();
}
}
Затем следует изменить интерфейс Observer и изменить сигнатуру 
метода update(), чтобы он вызывался без параметров: 
public interface Observer {
public void update();
}
1
И наконец, в каждом конкретном объекте Observer следует изменить сигнатуру 
соответствующего метода update() и получать погодные данные от субъекта при помощи 
get-методов WeatherData. Новый код класса CurrentConditionsDisplay выглядит так:
2
public void update() {
this.temperature = weatherData.getTemperature();
this.humidity = weatherData.getHumidity();
display();
}
1
Тем временем в Weather-O-Rama...
Существует и другой способ обработки данных в субъекте: положиться на то, что 
наблюдатели будут получать их от субъекта по мере надобности. В настоящее время 
при изменении данных субъекта новые значения температуры, влажности и давления 
отправляются наблюдателям, для чего эти данные передаются вызовом update().
Изменим код так, чтобы при получении уведомления об изменениях наблюдатель 
вызывал бы get-методы субъекта для получения требуемых изменений.
Чтобы переключиться на использование активного получения данных, необходимо 
внести в существующий код ряд небольших изменений. 
Здесь используются get-методы 
Subject, которые 
были предоставлены 
с кодом WeatherData 
из Weather-O-Rama.
104 глава 2
ну и задачка
Магниты с кодами
Код класса ForecastDisplay полностью перепутан. Сможете ли вы 
расставить фрагменты в правильном порядке? Некоторые фигурные скобки упали на пол. Они слишком малы, чтобы их подбирать, — добавьте столько скобок, сколько считаете нужным!
public void display() {
 // код вывода данных
}
weatherData.registerObserver(this);
public ForecastDisplay(WeatherData 
weatherData) {
display();
public class ForecastDisplay implements 
Observer, DisplayElement {
lastPressure = currentPressure;
currentPressure = weatherData.getPressure();
private float currentPressure = 29.92f; 
private float lastPressure;
this.weatherData = weatherData;
public void update() {
private WeatherData weatherData;
}
паттерн наблюдатель
дальше   105
Тест-драйв
File Edit Window Help TryThisAtHome
%java WeatherStation
Current conditions: 80.0F degrees and 65.0% humidity
Avg/Max/Min temperature = 80.0/80.0/80.0
Forecast: Improving weather on the way!
Current conditions: 82.0F degrees and 70.0% humidity
Avg/Max/Min temperature = 81.0/82.0/80.0
Forecast: Watch out for cooler, rainy weather
Current conditions: 78.0F degrees and 90.0% humidity
Avg/Max/Min temperature = 80.0/82.0/78.0
Forecast: More of the same
%
Осталось обновить еще один экран со статистикой (среднее/минимум/
максимум). Так сделайте это!
Просто для уверенности запустим новый код…
Weather-O-Rama, Inc.
100 Main Street
Tornado Alley, OK 45021
Ого! 
Превосходная работа. Вы не только быстро создали все 
три экрана, которые мы заказывали, но и разработали об
щую архитектуру, которая позволяет любому разработчику 
-
создавать новый экран и даже добавлять и удалять экраны 
во время выполнения!
Гениально!
До следующей совместной работы,
Полученный результат.
Смотрите! Только что 
пришло письмо!
106 глава 2
инструментарий разработки
Новые инструменты
Подошла к концу глава 2. В ваш
ОО-инструментарий добавились новые 
инструменты...   Паттерн Наблюдатель определяет отношение «один ко 
многим» между объектами.
  Субъекты обновляют наблюдателей через общий интерфейс.
  В паттерне могут участвовать 
наблюдатели любого конкретного типа — при условии, что они 
реализуют интерфейс Observer.
  Наблюдатели слабо связаны: субъекту о них ничего не 
известно кроме того, что они 
реализуют интерфейс Observer.
  При использовании паттерна 
возможен как запрос, так и 
активная доставка данных от 
субъекта (запрос считается 
более «правильным»).
  Swing, как и многие GUIинфраструктуры, широко применяет паттерн Наблюдатель.
  Паттерн также встречается в 
других местах, включая RxJava, 
JavaBeans и RMI, и в других 
фреймворках, включая Cocoa, 
Swift и события JavaScript.
  Паттерн Наблюдатель связан 
с паттерном Публикация-подписка, предназначенным для 
более сложных ситуаций с 
несколькими субъектами и (или) 
типами сообщений.
  Паттерн Наблюдатель часто 
применяется на практике. Мы 
еще встретимся с ним при изучении паттерна Модель-Представление-Контроллер.
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Абстракция 
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, 
что изменяется.
Отдавайте предпочтение композиции перед 
наследованием.
Программируйте на 
уровне интерфейсов.
Стремитесь к слабой 
связанности взаимодействующих объектов.
Принципы
Паттерны
Новый принцип. 
Помните: слабосвязанные структуры более гибки 
и лучше выдерживают изменения.
Новый паттерн для слабосвязанного 
оповещения групп объектов об изменении состояния. Мы еще вернемся 
к паттерну Наблюдатель, когда речь 
пойдет о MVC!
Стратегия — определяет 
семейство алгоритмов, 
инкапсулирует и обеспечивает их 
взаимозаменяемость. Паттерн 
позволяет модифицировать 
алгоритмы независимо от 
их использования на стороне 
клиента.
Наблюдатель определяет 
отношение «один ко многим» 
между объектами таким образом, что при изменении состояния одного объекта происходит 
автоматическое оповещение 
и обновление всех зависимых объектов
паттерн наблюдатель
дальше   107
Упражнение
Принцип проектирования
Определите аспекты вашего приложения, 
которые могут изменяться, и отделите 
их от тех, которые будут оставаться неизменными. 
Принцип проектирования
Программируйте на уровне интерфейсов, 
а не на уровне реализаций.
Принцип проектирования
Отдавайте предпочтение композиции 
перед наследованием.
Проверка принципов проектирования
Опишите, как каждый из принципов проектирования используется в паттерне Наблюдатель.
Сложная задача. Подсказка: подумайте, 
как наблюдатели взаимодействуют 
с субъектами.
108 глава 2
ответы к упражнениям
Принцип проектирования
Определите аспекты вашего приложения, которые могут изменяться, 
и отделите их от тех, которые будут 
оставаться неизменными. 
Принцип проектирования
Программируйте на уровне интерфейсов, а не на уровне реализаций.
Принцип проектирования
Отдавайте предпочтение композиции 
перед наследованием.
Переменные аспекты — состояние субъекта, количество 
и тип наблюдателей. Паттерн 
позволяет изменять объекты, зависящие от состояния 
субъекта, без изменения самого 
субъекта.
И субъект, и наблюдатели используют интерфейсы. Субъект 
отслеживает объекты, реализующие интерфейс Observer, 
а наблюдатели регистрируются 
и оповещаются через интерфейс 
Subject.
Отношения наблюдателей 
с субъектом не определяются 
иерархией наследования, а задаются во время выполнения 
посредством композиции!
Проверка принципов
проектирования. Решение
? A. Мы программируем на уровне реализаций, а не интерфейсов.
? B. Для каждого нового элемента придется изменять код.
? C. Элементы не могут добавляться 
(или удаляться) во время выполнения.
? D. Элементы не реализуют единый 
интерфейс.
? E. Переменные аспекты архитектуры не инкапсулируются.
? F. Нарушается инкапсуляция класса 
WeatherData.
Какие из следующих утверждений относятся к первой реализации? 
(Укажите все варианты.)
Возьми в руку карандаш
 Решение
паттерн наблюдатель
дальше   109
public void display() {
 // код вывода данных
}
weatherData.registerObserver(this);
display();
public class ForecastDisplay implements 
Observer, DisplayElement {
lastPressure = currentPressure;
currentPressure = weatherData.getPressure();
private float currentPressure = 29.92f; 
private float lastPressure;
public void update() {
private WeatherData weatherData;
}
}
}
public ForecastDisplay(WeatherData 
weatherData) {
this.weatherData = weatherData;
Магниты с кодами.
Решение

Эту главу можно назвать «Взгляд на архитектуру для любителей наследования». Мы проанализируем типичные злоупотребления из 
области наследования, и вы научитесь декорировать свои классы во время 
выполнения с использованием разновидности композиции. Зачем? Затем, 
что этот прием позволяет вам наделить свои (или чужие) объекты новыми 
возможностями без модификации кода классов.
Украшение объектов 
3 Паттерн Декоратор
Прежде я полагал, что 
настоящие мужчины используют 
только субклассирование. Но 
потом я осознал возможности 
динамического расширения 
на стадии выполнения. 
Посмотрите, каким 
я стал!
112 глава 3
Сеть кофеен Starbuzz стремительно развивается. Если вы 
увидите одну из этих кофеен на углу, посмотрите через дорогу — и вы наверняка увидите другую.
Из-за бурного роста руководству Starbuzz никак не удается 
привести свою систему заказов в соответствие с реальным 
ассортиментом.
Когда бизнес только начинался, иерархия классов выглядела примерно так...
Добро пожаловать в Starbuzz!
Абстрактный класс 
Beverage субклассируется 
всеми классами напитков.
Каждый субкласс реализует метод cost(),
возвращающий цену напитка.
cost()
Espresso
cost()
Decaf
cost()
DarkRoast
cost()
HouseBlend
Beverage
description
getDescription()
cost()
// Другие методы...
Переменная description задается в каждом субклассе 
и содержит описание напитка.
Для получения описания используется метод 
getDescription(). 
Метод cost() тоже 
является абстрактным; субклассы 
должны предоставить собственную 
реализацию.
история starbuzz
паттерн декоратор
дальше   113
Beverage
description
getDescription()
cost()
// Другие методы...
К кофе можно заказать различные дополнения (пенка, шоколад и т. д.), да еще украсить все сверху взбитыми сливками. Дополнения не бесплатны, поэтому они должны 
быть встроены в систему оформления заказов. 
Первая попытка...
cost()
HouseBlendWithSteamedMilk
andCaramel
cost()
HouseBlendWithMocha
cost()
HouseBlendWithWhipandMocha
cost()
HouseBlendWithSteamedMilk
andSoy
cost()
HouseBlendWithSteamedMilk
cost()
HouseBlendWithSteamedMilk
andMocha
cost()
HouseBlendWithSoy
cost()
HouseBlendWithWhip
cost()
HouseBlendWithSteamedMilk
andWhip
cost()
HouseBlendWithSoyandMocha
cost()
HouseBlendWithWhipandSoy
cost()
DarkRoastWithSteamedMilk
andCaramel
cost()
DarkRoastWithMocha cost()
DarkRoastWithWhipandMocha
cost()
DarkRoastWithSteamedMilk
andSoy
cost()
DarkRoastWithSteamedMilk
cost()
DarkRoastWithSteamedMilk
andMocha
cost()
DarkRoastWithSoy
cost()
DarkRoastWithWhip
cost()
DarkRoastWithSteamedMilk
andWhip
cost()
DarkRoastWithSoyandMocha
cost()
DarkRoastWithWhipandSoy
cost()
DecafWithSteamedMilk
andCaramel
cost()
DecafWithMocha cost()
DecafWithWhipandMocha
cost()
DecafWithSteamedMilk
andSoy
cost()
DecafWithSteamedMilk
cost()
DecafWithSteamedMilk
andMocha
cost()
DecafWithSoy
cost()
DecafWithWhip
cost()
DecafWithSteamedMilk
andWhip
cost()
DecafWithSoyandMocha
cost()
DecafWithWhipandSoy
cost()
DarkRoastWithSoy
cost()
EspressoWithSteamedMilk
andCaramel
cost()
EspressoWithMocha cost()
EspressoWithWhipandMocha
cost()
EspressoWithSteamedMilk
andSoy
cost()
EspressoWithSteamedMilk
cost()
EspressoWithSteamedMilk
andMocha
cost()
DecafWithSoy
cost()
EspressoWhip
cost()
EspressoWithSteamedMilk
andWhip
cost()
DecafWithSoyandMocha
cost()
EspressoWithWhipandSoy
Каждый метод cost вычисляет 
стоимость кофе вместе со 
всеми дополнениями.
Ого! Классы 
стремительно 
размножаются?
114 глава 3
Давайте попробуем. Начнем с базового класса Beverage и добавим 
переменные, которые указывают, присутствует ли в кофе то или 
иное дополнение...
Понятно, что сопровождение классов Starbuzz станет сущим кошмаром. 
А если молоко подорожает? И что произойдет, если в меню появится новая 
карамельная добавка? 
Даже если отвлечься от проблем с сопровождением — какие принципы 
проектирования нарушает такой подход?
Подсказка: нарушены два принципа, и притом серьезно!
Beverage
description
milk
soy
mocha
whip
getDescription()
cost()
hasMilk()
setMilk()
hasSoy()
setSoy()
hasMocha()
setMocha()
hasWhip()
setWhip()
// Другие методы... Эти методы читают 
и устанавливают флаги
дополнений.
Логическая переменная для каждого 
дополнения.
Теперь мы реализуем cost() в Beverage, чтобы метод вычислял суммарную стоимость 
напитка вместе со всеми дополнениями. 
Субклассы по-прежнему переопределяют 
cost(), но они также вызывают версию суперкласса для вычисления общей стоимости 
базового напитка со всеми дополнениями.
нарушение принципов проектирования
Мозговой
штурм
Глупо; зачем нужны все 
эти классы? Разве для отслеживания дополнений нельзя использовать переменные экземпляров 
в суперклассе и наследование?
дальше   115
паттерн декоратор
cost()
Espresso
cost()
Decaf
cost()
DarkRoast
cost()
HouseBlend
Добавляем суперклассы, по одному 
для каждого напитка в меню:
Каждый метод cost() вычисляет стоимость напитка, а затем 
прибавляет к ней стоимость всех 
дополнений, полученную вызовом 
реализации cost() из суперкласса.
public class Beverage {
 public double cost() {
 }
}
public class DarkRoast extends Beverage {
 public DarkRoast() {
 description = "Most Excellent Dark Roast";
 }
 public double cost() {
 }
}
Beverage
description
milk
soy
mocha
whip
getDescription()
cost()
hasMilk()
setMilk()
hasSoy()
setSoy()
hasMocha()
setMocha()
hasWhip()
setWhip()
// Другие методы...
Версия cost() суперкласса 
вычисляет стоимость всех 
дополнений, а переопределенная версия cost() добавляет 
стоимость конкретного 
типа напитка.
Напишите реализации cost( ) для следующих классов (достаточно псевдокода Java):
Возьми в руку карандаш
116 глава 3
Какие изменения требований или других факторов могут отразиться
на работоспособности этой архитектуры?
Изменение цены дополнений потребует модификации существующего кода.
При появлении новых дополнений нам придется добавлять новые методы и изменять реализацию cost в суперклассе.
Для некоторых новых напитков (холодный чай?) дополнения могут оказаться 
неуместными, но субкласс Tea все равно будет наследовать hasWhip() и другие 
методы.
А если клиент захочет двойную порцию шоколада?
Ваша очередь:
Как было показано 
в главе 1, это крайне 
нежелательно.
возможное изменение
Возьми в руку карандаш
Видишь, всего 
пять классов. Нужно 
действовать именно так.
Я не уверен; чтобы 
понять потенциальные недостатки 
такого подхода, достаточно подумать, 
как эта архитектура может измениться 
в будущем.
паттерн декоратор
дальше   117
Гуру и ученик...
Гуру: С момента нашей встречи прошло много времени. Ты 
усердно медитировал на наследовании?
Ученик: Да, учитель. Наследование обладает большими возможностями, 
но я осознал, что оно не всегда приводит к самой гибкой или удобной в сопровождении архитектуре. 
Гуру: Да, ты кое-чего достиг. Тогда скажи мне, можно ли обеспечить повторное использование кода без наследования?
Ученик: Учитель, я узнал о механизмах «наследования» поведения посредством композиции и делегирования. 
Гуру: Продолжай...
Ученик: Поведение, унаследованное посредством субклассирования, задается статически на стадии компиляции. Кроме того, оно должно наследоваться всеми субклассами. Расширение поведения объекта посредством композиции может осуществляться динамически.
Гуру: Очень хорошо, ты начинаешь видеть силу композиции.
Ученик: Да, я могу наделить объект новыми возможностями, даже теми, 
которые не были предусмотрены при проектировании суперкласса. 
И мне не придется изменять его код!
Гуру: Что ты узнал о влиянии композиции на простоту сопровождения 
твоего кода?
Ученик: Динамическая композиция объектов позволяет добавлять новую функциональность посредством написания нового кода (вместо 
изменения существующего). Так как мы не изменяем готовый код, риск 
введения ошибок или непредвиденных побочных эффектов значительно снижается.
Гуру: Очень хорошо. Иди и медитируй дальше... Помни: код должен быть 
закрытым (для изменений), словно цветок лотоса на закате, но при этом 
открытым (для расширения), словно цветок лотоса на утренней заре.
118 глава 3
Принцип открытости/закрытости
Принцип проектирования
Классы должны быть открыты 
для расширения, но закрыты для 
изменения.
Заходите, мы 
открыты. Не стесняйтесь, расширяйте наши классы любым 
нужным поведением. Если ваши потребности изменятся (а это наверняка произойдет), просто создайте собственное 
расширение. 
Извините, мы закрыты. Мы потратили 
много времени на проверку и отладку этого кода и не можем позволить вам изменять его. Код должен остаться 
закрытым для изменения. Если вас это не 
устраивает, обратитесь к директору.
Мы подошли к одному из важнейших принципов проектирования:
Наша цель заключается в том, чтобы классы можно было легко 
расширять новым поведением без изменения существующего кода. 
Что это нам дает? Архитектуры, устойчивые к изменениям и достаточно гибкие для поддержки новой функциональности в соответствии с изменившимися требованиями.
принцип открытости/закрытости
паттерн декоратор
дальше   119
В: Открыты для расширений и закрыты 
для изменения? Звучит весьма противоречиво. Разве такое возможно?
О: Хороший вопрос. Ведь чем труднее изменить что-либо, тем меньше возможностей 
для расширения, верно?
Однако некоторые ОО-приемы позволяют 
расширять системы даже в том случае, если 
вы не можете изменить их базовый код. 
Вспомните главу 2: добавляя новых Наблюдателей, мы можем в любой момент расширить субъект без добавления в него нового 
кода. Вы еще увидите немало других способов расширения поведения с применением 
других методов ОО-проектирования.
В: Хорошо, я могу понять расширение 
субъектов, но как спроектировать архитектуру, рассчитанную на расширение, но закрытую для изменения?
О: Многие паттерны представляют собой 
надежные, проверенные временем механизмы расширения поведения без изменения 
кода.
В: Но как обеспечить соблюдение принципа открытости/закрытости во всех компонентах моей архитектуры?
О: Обычно это невозможно. Чтобы ООархитектура была гибкой и открытой для 
расширения без изменения существующего 
кода, обычно приходится затратить немало 
времени и усилий. Следование принципу открытости/закрытости обычно приводит к введению новых уровней абстракции, усложняющих код. Лучше сосредоточиться только на 
тех областях вашей архитектуры, которые с 
наибольшей вероятностью будут изменяться, и применять принципы именно там. 
В: Как узнать, какие области изменений 
более важны?
О: Отчасти это зависит от опыта проектирования ОО-систем и знания предметной 
области. Знакомство с другими примерами 
поможет вам выявить переменные области 
в ваших собственных архитектурах.
На первый взгляд формулировка принципа 
кажется противоречивой, однако существуют приемы, обеспечивающие возможность 
расширения кода без его модификации.
Будьте осторожны с выбором расширяемых 
областей. ПОВСЕМЕСТНОЕ применение 
принципа открытости/закрытости неэффективно и расточительно, оно приводит 
к созданию сложного, малопонятного кода.
часто Задаваемые вопросы
120 глава 3
Знакомство с паттерном Декоратор
Итак, схема вычисления стоимости напитка с дополнениями 
посредством наследования обладает рядом недостатков: это 
и разрастание классов, и негибкая архитектура, и присутствие 
в базовом классе функциональности, неуместной в некоторых 
субклассах.
Поэтому мы поступим иначе: начнем с базового напитка и «декорируем» его на стадии выполнения. Например, если клиент заказывает кофе темной обжарки (Dark Roast) с шоколадом (Mocha) 
и взбитыми сливками (Whip), мы
1
2
начинаем с объекта DarkRoast;
декорируем его объектом Mocha;
3 декорируем его объектом Whip;
4 вызываем метод cost() и пользуемся делегированием для прибавления стоимости дополнений.
Хорошо, но как «декорировать» объект и как в этой схеме работает делегирование? Давайте разберемся...
знакомство с паттерном декоратор
Хватит лекций 
по ОО-проектированию, у нас тут 
реальные проблемы. Вы еще не забыли о Starbuzz? Как вы думаете, ваши 
принципы проектирования способны 
нам помочь?
паттерн декоратор
дальше   121
Напоминаем, что DarkRoast 
наследует от Beverage и содержит метод cost() для вычисления стоимости напитка.
DarkRoast
cost()
Mocha
cost()
Whip
cost()
Mocha
cost()
1
2
Начинаем с объекта DarkRoast.
Клиент заказывает шоколад, поэтому мы создаем 
объект Mocha и «заворачиваем» в него DarkRoast.
3 Клиент также хочет взбитые сливки, поэтому мы создаем 
объект Whip и «заворачиваем» в него Mocha.
Объект Mocha является декоратором. Его тип повторяет тип 
декорируемого объекта, в данном 
случае Beverage.
Объект Mocha тоже содержит метод cost(), а благодаря полиморфизму 
он может интерпретироваться как 
Beverage (так как Mocha является субклассом Beverage).
Декоратор Whip также повторяет тип DarkRoast и содержит 
метод cost().
Построение заказанного напитка
Таким образом, объект DarkRoast, «завернутый» 
в Mocha и Whip, сохраняет признаки Beverage и с ним 
можно делать все, что можно делать с DarkRoast, 
включая вызов метода cost().
DarkRoast
cost()
DarkRoast
cost()
122 глава 3
Сначала cost() вызывается 
для внешнего декоратора 
Whip.
Whip
Mocha
DarkRoast
Пришло время вычислить общую стоимость напитка. Для этого мы вызываем метод cost() внешнего декоратора Whip, а последний делегирует 
вычисление декорируемым объектам. Получив результат, он прибавляет к нему стоимость взбитых сливок.
Whip вызывает метод cost()
для объекта Mocha.
Объект Mocha прибавляет свою 
стоимость (20 центов) к результату, 
полученному от DarkRoast, 
и возвращает сумму $1.19.
4
$1.29 .10 .20 .99
Объект Whip прибавляет 
свою стоимость (10 центов) 
к полученному результату 
и возвращает сумму $1.29.
1
2
5
6
Что нам уже известно...
  Декораторы имеют тот же супертип, что и декорируемые объекты.
  Объект можно «завернуть» в один или несколько декораторов.
  Так как декоратор относится к тому же супертипу, что и декорируемый объект, 
мы можем передать декорированный объект вместо исходного.
  Декоратор добавляет свое поведение до и (или) после делегирования операций 
декорируемому объекту, выполняющему остальную работу.
  Объект может быть декорирован в любой момент времени, так что мы 
можем декорировать объекты динамически и с произвольным количеством 
декораторов.
А теперь давайте посмотрим на паттерн Декоратор в действии и немного попрограммируем.
3 Объект Mocha вызывает 
метод cost() для объекта 
DarkRoast.
Объект DarkRoast 
возвращает свою 
стоимость — 
99 центов.
4
(Подробности через 
пару страниц.)
Очень 
важно!
характеристики декоратора
cost() cost() cost()
паттерн декоратор
дальше   123
Паттерн Декоратор динамически наделяет объект новыми 
возможностями и является гибкой альтернативой субклассированию в области расширения функциональности.
Определение паттерна Декоратор
Декораторы реализуют 
тот же интерфейс 
или абстрактный класс, 
что и декорируемый 
компонент.
methodA()
methodB()
// Другие методы
ConcreteComponent
methodA() компонент
methodB()
// Другие методы
Component
methodA()
methodB()
// Другие методы
Decorator
ConcreteDecorator наследует (от класса Decorator) 
переменную экземпляра для 
сущности, которую он декорирует (объект Component, 
оберткой для которого становится Decorator).
Декораторы могут добавлять новые методы, однако 
новое поведение обычно добавляется до или после вызова существующего метода компонента.
Декоратор СОДЕРЖИТ 
компонент (ссылка на
компонент хранится в 
переменной экземпляра).
ConcreteComponent — 
объект, поведение которого мы собираемся 
расширять динамически. Является субклассом 
Component.
Начнем, как обычно, с описания паттерна Декоратор.
Приведенное определение описывает роль паттерна Декоратор, но ничего не говорит 
о том, как применять паттерн в наших реализациях. Следующая диаграмма классов выглядит более содержательно (а на следующей странице эта структура применена к классам напитков).
Компонент может использоваться как сам
по себе, так и «завернутым» в декоратор.
Декораторы могут 
расширять состояние 
компонента.
ConcereteDecoratorB
methodA()
methodB()
// Другие методы
Component wrappedObj
Object newState
ConcereteDecoratorA
methodA()
methodB()
newBehavior()
// Другие методы
Component wrappedObj
124 глава 3
Декораторы и напитки
Переработаем иерархию напитков Starbuzz с использованием паттерна Декоратор.
компонент
Четыре конкретных 
компонента, по одному 
на каждую разновидность 
кофе.
Декораторы представляют собой дополнения к кофе. 
Обратите внимание: они должны реализовать не только 
cost(), но и getDescription(). Вскоре мы увидим, почему 
это необходимо...
Beverage — абстрактный 
класс компонента.
декораторы и напитки
Мозговой
штурм
Прежде чем двигаться дальше, подумайте, как бы вы реализовали метод cost() в классах напитков и дополнений. А как бы вы реализовали 
метод getDescription() для дополнений?
Ссылка на объект Beverage, 
обертками для которого 
станут декораторы.
Beverage beverage
CondimentDecorator
getDescription()
cost()
// other useful methods
Beverage
description
cost()
getDescription()
Milk
cost()
HouseBlend
cost()
DarkRoast
cost()
Decaf
cost()
Espresso
Mocha
getDescription()
Soy Whip
cost()
getDescription()
cost()
getDescription()
cost()
getDescription()
паттерн декоратор
дальше   125
Разговор в офисе
Путаница с наследованием и композицией
Мэри
Сью: Что ты имеешь в виду?
Мэри: Посмотри на диаграмму классов. CondimentDecorator расширяет класс 
Beverage. Это наследование, верно?
Сью: Верно. Здесь принципиально то, что декораторы должны относиться к тому 
же супертипу, что и декорируемые объекты. Таким образом, наследование применяется для согласования типов, а не для обеспечения поведения.
Мэри: Хорошо, я понимаю, что декораторы должны обладать таким же «интерфейсом», что и компоненты, потому что они должны использоваться вместо компонентов. Но откуда тогда берется поведение?
Сью: Объединяя декоратор с компонентом, мы добавляем новое поведение. Это поведение приобретается не наследованием от суперкласса, а композицией объектов.
Мэри: Выходит, мы субклассируем абстрактный класс Beverage только для приведения к нужному типу, а не для наследования его поведения. Поведение формируется 
в результате композиции декораторов с базовыми компонентами и другими декораторами.
Сью: Точно.
Мэри: О-о-о, начинаю понимать. Композиция объектов дает нам значительную гибкость в смешении напитков и дополнений. Очень элегантно.
Сью: Да. Если бы мы воспользовались наследованием, то все поведение определялось бы статически во время компиляции. Другими словами, мы могли бы использовать только то поведение, которое нам предоставляет суперкласс или которое мы 
переопределяем в субклассе. Композиция делает возможным произвольное смешивание декораторов... во время выполнения.
Мэри: И насколько я поняла, мы можем в любой момент реализовать новые декораторы для добавления нового поведения.
Сью: Вот именно.
Мэри: Остался последний вопрос. Если наследуется только тип компонента, то почему не воспользоваться интерфейсом вместо абстрактного класса Beverage?
Сью: Потому что когда нам передали этот код, у Starbuzz уже был абстрактный класс 
Beverage. Изменения в существующем коде всегда нежелательны; не стоит «исправлять» код, если можно просто воспользоваться абстрактным классом.
Похоже, я чего-то не понимаю...
Мне казалось, что в основе этого 
паттерна лежит композиция, а не 
наследование.
126 глава 3
Сделай 
мне латте с двойным
шоколадом, соей 
и взбитыми сливками.
Обучение бариста
Сначала cost() вызывается 
для внешнего декоратора 
Whip.
Whip
cost()
Mocha
DarkRoast
cost() cost()
Whip вызывает cost() для Mocha.
Mocha прибавляет свою 
стоимость (20 центов) 
к результату, полученному 
от DarkRoast, и возвращает 
новую сумму — $1.19.
$1.29 .10 .20 .99
Whip прибавляет свою 
стоимость (10 центов) 
к результату, полученному 
от Mocha, и возвращает новую 
сумму — $1.29.
1 2
5
6
3
DarkRoast возвращает 
свою стоимость 
(99 центов).
4
Mocha вызывает cost() для DarkRoast.
Нарисуйте, как будет вычисляться цена заказа «латте с двойным шоколадом, соей и взбитыми сливками». Возьмите цены из меню и нарисуйте свою схему в формате, который мы использовали несколько 
страниц назад.
Starbuzz Coffee
Кофе
Домашняя смесь
Темн.обжарка
Без кофеина
Эспрессо
Дополнения
Молочная пена
Шоколад
Соя
Взбитые сливки
 .89
 .99
1.05
1.99
 .10
 .20
 .15
 .10
Нарисуйте здесь свою схему.
«Темная обжарка + 
+ шоколад + взбитые сливки»
применение паттерна декоратор
Возьми в руку карандаш
Starbuzz C
S eeff o
tarbuzz Coffee
ПОДСКАЗКА: чтобы 
сделать «латте с двойным 
шоколадом, соей и взбитыми 
сливками», следует 
объединить объекты 
HouseBlend, Soy, два Mocha 
и Whip! 
паттерн декоратор
дальше   127
Пишем код для Starbuzz
Пора воплотить наши замыслы в реальном коде. 
Начнем с класса Beverage, который достался нам из исходной 
архитектуры Starbuzz. Он выглядит так:
public abstract class Beverage {
 String description = "Unknown Beverage";
 
 public String getDescription() {
 return description;
 }
 public abstract double cost();
}
public abstract class CondimentDecorator extends Beverage {
 Beverage beverage;
 public abstract String getDescription();
Как видите, класс Beverage достаточно прост. Давайте реализуем 
абстрактный класс для дополнений:
Beverage — абстрактный 
класс с двумя методами: 
getDescription() и cost().
Метод getDescription 
уже реализован, а метод cost() необходимо 
реализовать в субклассах.
Объекты должны быть взаимозаменяемы с Beverage, поэтому 
расширяем класс Beverage.
Также все декораторы должны заново реализовать метод 
getDescription(). Зачем? Скоро 
узнаете...
Объект Beverage, который будет «заворачиваться» 
в каждый Decorator. Обратите внимание: мы используем 
подтип Beverage, чтобы декоратор мог быть оберткой для 
любого напитка.
128 глава 3
Программируем классы напитков
public class Espresso extends Beverage {
 
 public Espresso() {
 description = "Espresso";
 }
 
 public double cost() {
 return 1.99;
 }
}
Starbuzz Coffee
 .89
 .99
1.05
1.99
 .10
 .20
 .15
 .10
public class HouseBlend extends Beverage {
 public HouseBlend() {
 description = "House Blend Coffee";
 }
 public double cost() {
 return .89;
 }
}
Разобравшись с базовыми классами, переходим к реализации некоторых напитков. 
Начнем с эспрессо. Как говорилось ранее, мы должны задать описание конкретного напитка в методе getDescription() и реализовать метод cost().
Все классы конкретных напитков расширяют Beverage.
Описание задается в конструкторе класса. Стоит напомнить, что 
переменная description наследуется 
от Beverage.
Остается вычислить стоимость напитка. В этом 
классе беспокоиться о дополнениях не нужно, поэтому мы просто возвращаем стоимость «базового» 
эспрессо — $1.99.
Другой класс напитка. От нас 
требуется лишь назначить подходящее описание и вернуть правильную стоимость.
Два других класса напитков (DarkRoast 
и Decaf ) создаются аналогично.
реализация классов напитков
Кофе
Домашняя смесь
Темн.обжарка
Без кофеина
Эспрессо
Дополнения
Молочная пена
Шоколад
Соя
Взбитые сливки
паттерн декоратор
дальше   129
Программирование дополнений
Взглянув на диаграмму классов паттерна Декоратор, вы увидите, что мы написали абстрактный компонент (Beverage), конкретные компоненты (HouseBlend) и абстрактный 
декоратор (CondimentDecorator). Пришло время реализации конкретных декораторов. 
Код декоратора Mocha:
Класс декоратора расширяет 
CondimentDecorator. При создании экземпляра Mocha 
будет использоваться ссылка на 
Beverage.
Не забудьте: этот класс наследует переменную экземпляра 
Beverage для хранения внутреннего 
напитка.
Этой переменной экземпляра присваивается внутренний объект 
Beverage. В данном случае он передается конструктору декоратора.
Теперь необходимо вычислить стоимость напитка с шоколадом. Сначала вызов делегируется 
декорируемому объекту, а затем стоимость 
шоколада прибавляется к результату.
В описании должно содержаться 
не только название напитка (допустим, «Dark Roast»), но и все 
дополнения, например «Dark Roast, 
Mocha». Таким образом, мы сначала 
получаем описание, делегируя вызов 
декорируемому объекту, а затем 
присоединяем к нему строку
«, Mocha».
На следующей странице мы создадим экземпляр
напитка и декорируем его дополнениями, но сначала...
Не забудьте, что 
CondimentDecorator расширяет Beverage.
Напишите и откомпилируйте код для дополнений Soy и Whip. Он необходим для завершения 
и тестирования приложения.
Упражнение
public class Mocha extends CondimentDecorator {
 public Mocha(Beverage beverage) {
 this.beverage = beverage;
 }
 public String getDescription() {
 return beverage.getDescription() + ", Mocha";
 }
 public double cost() {
 return beverage.cost() + .20;
 }
}
130 глава 3
Поздравляем. Можно устроиться поудобнее, заказать кофе и полюбоваться гибкой архитектурой, построенной на основе паттерна Декоратор.
Тестовый код для оформления заказов:
public class StarbuzzCoffee {
 public static void main(String args[]) {
 Beverage beverage = new Espresso();
 System.out.println(beverage.getDescription() 
 + " $" + beverage.cost());
 Beverage beverage2 = new DarkRoast();
 beverage2 = new Mocha(beverage2);
 beverage2 = new Mocha(beverage2);
 beverage2 = new Whip(beverage2);
 System.out.println(beverage2.getDescription() 
 + " $" + beverage2.cost());
 Beverage beverage3 = new HouseBlend();
 beverage3 = new Soy(beverage3);
 beverage3 = new Mocha(beverage3);
 beverage3 = new Whip(beverage3);
 System.out.println(beverage3.getDescription() 
 + " $" + beverage3.cost());
 }
}
Готовим кофе
% java StarbuzzCoffee
Espresso $1.99
Dark Roast Coffee, Mocha, Mocha, Whip $1.49
House Blend Coffee, Soy, Mocha, Whip $1.34
%
Заказываем эспрессо без дополнений, выводим описание и стоимость.
Создаем объект DarkRoast.
Напоследок заказываем «домашнюю смесь» с соей, шоколадом и взбитыми сливками.
Получаем свой заказ:
* Более элегантный способ создания декорированных объектов будет представлен при описании 
паттерна Фабрика (а также паттерна Строитель в приложении).
File Edit Window Help CloudsInMyCoffee
«Заворачиваем» в объект Mocha...
...Потом во второй...
...И еще в объект Whip.
тестирование напитков
*
паттерн декоратор
дальше   131
Наши друзья из Starbuzz ввели в меню разные размеры порций. Теперь кофе можно 
заказать в маленькой, средней или большой чашке. Starbuzz считает размер порции неотъемлемой частью класса кофе, поэтому в класс Beverage были добавлены два новых 
метода: setSize() и getSize(). Стоимость дополнений также зависит от размера порции, 
так что, скажем, добавка сои должна стоить 10, 15 или 20 центов для маленькой, средней или большой порции соответственно. Обновленный класс напитков показан ниже.
Как бы вы изменили классы декораторов в соответствии с новыми требованиями?
В: Как быть с кодом, который проверяет конкретную разновидность компонента (скажем, HouseBlend) и выполняет 
некоторые действия (допустим, оформляет скидку)? После декорирования 
объекта такой код перестанет работать.
О: Абсолютно точно. Если код зависит 
от типа конкретного компонента, декораторы нарушат его работоспособность. 
Пока код пишется для типа абстрактного 
компонента, использование декораторов 
остается прозрачным для кода. Впрочем, 
если вы начинаете программировать на 
уровне конкретных компонентов, вам стоит переосмыслить архитектуру приложения и использования в нем декораторов.
В: Нет ли опасности, что клиент получит ссылку, которая не относится к самому внешнему декоратору? Допустим, 
если имеется компонент DarkRoast с 
декораторами Mocha, Soy и Whip, ктонибудь по неосторожности может использовать ссылку на Soy вместо Whip, 
и тогда внешний декоратор не будет учтен в заказе.
О: В паттерне Декоратор возрастает 
количество объектов, а следовательно, и опасность проблем, связанных с 
ошибками программирования. Однако 
декораторы обычно создаются при использовании других паттернов (таких, 
как Фабрика или Строитель). Создание 
конкретных компонентов с декораторами 
в них хорошо инкапсулировано, а ошибки 
такого рода маловероятны.
В: Могут ли декораторы располагать 
информацией о других декораторах 
в цепочке? Допустим, если я хочу, чтобы метод getDecription() вместо строки 
«Mocha, Whip, Mocha» выводил строку 
«Whip, Double Mocha»?
О: Декораторы предназначены для расширения поведения декорируемых объектов. Получение информации с других 
уровней цепочки декораторов выходит 
за рамки их традиционного назначения. 
Впрочем, такие ситуации возможны — допустим, декоратор CondimentPrettyPrint 
может разбирать итоговое описание и выводить его в нужном виде. Для упрощения 
реализации приведенного примера метод 
getDecription() может возвращать объект 
ArrayList с описаниями.
часто Задаваемые вопросы
Возьми в руку карандаш
public abstract class Beverage {
 public enum Size { TALL, GRANDE, VENTI };
 Size size = Size.TALL;
 String description = "Unknown Beverage";
 public String getDescription() {
 return description;
 }
 public void setSize(Size size) {
 this.size = size;
 }
 public Size getSize() {
 return this.size;
 }
 public abstract double cost();
}
132 глава 3
Декораторы в реальном мире: ввод/вывод в языке Java
Количество классов в пакете java.io... устрашает. Если вы сказали «ого!» при первом 
взгляде на этот API (а также при втором и третьем), не огорчайтесь, вы не одиноки. 
Но теперь, когда вы знакомы с паттерном Декоратор, классы ввода/вывода смотрятся 
более осмысленно, потому что пакет java.io в основном базируется на паттерне Декоратор. Типичный набор объектов, использующих декораторы для расширения функциональности чтения данных из файла:
ZipInputStream
BufferedInputStream
FileInputStream
FileInputStream — декорируемый 
компонент. Библиотека ввода/вывода Java предоставляет базовые компоненты FileInputStream, 
StringBufferInputStream, 
ByteArrayInputStream, предназначенные для чтения байтов данных.
BufferedInputStream 
представляет собой 
конкретный декоратор. 
BufferedInputStream расширяет FileInputStream 
поведением буферизации; 
входные данные буферизуются для повышения 
быстродействия.
ZipInputStream также является конкретным 
декоратором. Он добавляет возможность чтения 
элементов zip-файла при 
чтении данных из zipфайлов.
Текстовый файл.
BufferedInputStream и LineNumberInputStream расширяют FilterInputStream —
абстрактный класс декоратора.
декораторы в системе ввода/вывода java
паттерн декоратор
дальше   133
FileInputStream StringBufferInputStream ByteArrayInputStream FilterInputStream
InputStream
PushbackInputStream BufferedInputStream DataInputStream LineNumberInputStream
Абстрактный компонент
FilterInputStream — 
абстрактный
декоратор
Эти разновидности 
InputStream — конкретные компоненты, к которым будут применяться декораторы. И наконец, конкретные декораторы.
Как видите, архитектура не так уж сильно отличается от архитектуры Starbuzz. 
Полученной информации вполне достаточно для того, чтобы просмотреть документацию java.io и составить декораторы для различных входных потоков. 
Выходные потоки используют аналогичную архитектуру. Вероятно, вы уже поняли, что потоки Reader/Writer (для символьных данных) довольно близко отражают архитектуру потоковых классов (с небольшими различиями и расхождениями, но достаточно, чтобы вы могли разобраться в происходящем).
Библиотека ввода/вывода Java также подчеркивает один из недостатков паттерна Декоратор: иерархии, построенные с использованием этого паттерна, часто 
состоят из множества мелких классов, в которых трудно разобраться разработчику, пытающемуся использовать API. Но теперь вы знаете, как работает Декоратор, представляете общую картину и при использовании чужого API на базе 
паттерна Декоратор разберетесь в структуре его классов, чтобы получить доступ 
к нужному поведению.
Декорирование классов java.io
134 глава 3
Написание собственного декоратора ввода/вывода
Итак, вы знаете паттерн Декоратор и видели диаграмму 
классов ввода/вывода. У вас есть все необходимое для написания собственного декоратора. Нет проблем. 
Нужно расширить класс 
FilterInputStream и переопределить метод read().
public class LowerCaseInputStream extends FilterInputStream {
 public LowerCaseInputStream(InputStream in) {
 super(in);
 }
 public int read() throws IOException {
 int c = in.read();
 return (c == -1 ? c : Character.toLowerCase((char)c));
 }
 
 public int read(byte[] b, int offset, int len) throws IOException {
 int result = in.read(b, offset, len);
 for (int i = offset; i < offset+result; i++) {
 b[i] = (byte)Character.toLowerCase((char)b[i]);
 }
 return result;
 }
}
Давайте напишем декоратор, который преобразует все 
символы верхнего регистра во входном потоке к нижнему регистру. Другими словами, если из потока читается 
строка «I know the Decorator Pattern therefore I RULE!», то 
наш декоратор преобразует ее к виду «i know the decorator 
pattern therefore i rule!». 
Начнем с расширения FilterInputStream — 
абстрактного декоратора
для всех объектов InputStream.
Теперь необходимо реализовать два метода read. Они 
получают байт (или массив 
байтов) и преобразуют каждый символ верхнего регистра к нижнему регистру.
Не забудьте импортировать java.io... (директива 
не показана).
написание собственного декоратора ввода/вывода
НАПОМИНАЕМ: директивы import и package
в листингах не приводятся. Полный исходный
код примеров можно загрузить на сайте
http://wickedlysmart.com/head-first-design-patterns/.
паттерн декоратор
дальше   135
public class InputTest {
 public static void main(String[] args) throws IOException {
 int c;
 try {
 InputStream in = 
 new LowerCaseInputStream(
 new BufferedInputStream(
 new FileInputStream("test.txt")));
 while((c = in.read()) >= 0) {
 System.out.print((char)c);
 }
 in.close();
 } catch (IOException e) {
 e.printStackTrace();
 }
 }
}
Пишем короткий фрагмент кода для тестирования декоратора:
% java InputTest
i know the decorator pattern therefore i rule!
%
File Edit Window Help DecoratorsRule
Проверяем:
Создаем объект 
FileInputStream и декорируем его — сначала декоратором BufferedInputStream, 
затем нашим фильтром 
LowerCaseInputStream.
Просто используем поток для чтения символов до конца файла и выводим 
символы в процессе чтения.
I know the Decorator Pattern therefore I RULE!
test.txt file
Тестирование декоратора ввода/вывода
Необходимо создать этот 
файл.
136 глава 3
HeadFirst: Добро пожаловать. Говорят, в последнее время вы находитесь в подавленном настроении?
Декоратор: Да, я знаю, что меня считают модным паттерном проектирования... 
Но знаете, у меня тоже есть свои проблемы. 
HeadFirst: Может, поделитесь с нами своими трудностями?
Декоратор: Конечно. Вам известно, что я могу сделать архитектуру более гибкой, 
это бесспорно, но у меня есть и своя темная сторона. Видите ли, иногда я добавляю в архитектуру много мелких классов, и разобраться в ней становится весьма 
непросто.
HeadFirst: Приведете пример?
Декоратор: Возьмем библиотеки ввода/вывода Java. Известно, как трудно на первых порах в них разбираться. Но когда разработчик видит, что классы представляют собой набор «оберток» для InputStream, его задача заметно упрощается.
HeadFirst: Выходит, все не так уж плохо. Вы остаетесь замечательным паттерном, 
а проблема решается повышением квалификации?
Декоратор: К сожалению, это еще не все. Инода пользователи берут клиентский 
код, работа которого зависит от конкретных типов, и расширяют его декораторами, не продумав все до конца. Одно из моих главных достоинств заключается в том, 
что декораторы обычно вводятся в архитектуру прозрачно, а клиенту даже не нужно знать, 
что он имеет дело с декоратором. Если код зависит от конкретных типов, а вы применяете обобщенные декораторы, дело добром не кончится.
HeadFirst: Надеемся, все понимают, что при использовании декораторов необходима осмотрительность. Не стоит из-за этого переживать.
Декоратор: Стараюсь. Но есть и другие проблемы: скажем, введение декораторов усложняет код создания экземпляра компонента. Если в архитектуре участвуют декораторы, необходимо не только создать компонент, но и «завернуть» его 
в сколько-то Декораторов.
HeadFirst: На следующей неделе мы будем беседовать с паттернами Фабрика 
и Строитель. Говорят, они очень помогают в решении этой задачи?
Декоратор: Верно. Мне следовало бы почаще общаться с ними.
HeadFirst: Что ж, мы все считаем, что вы — выдающийся паттерн для создания 
гибких архитектур и соблюдения принципа открытости/закрытости. Не вешайте 
нос и смотрите на жизнь веселей!
Декоратор: Спасибо, я постараюсь.
Интервью недели:
Признания Декоратора
Паттерны
	 для всех
интервью с паттерном декоратор
паттерн декоратор
дальше   137
Паттерны
Стратегия — определяет семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. Паттерн позволяет 
модифицировать алгоритмы независимо от их использования на 
стороне клиента.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Новые инструменты
  Наследование — одна из 
форм расширения, но оно не 
всегда обеспечивает гибкость 
архитектуры.
  Следует предусмотреть 
возможность расширения 
поведения без изменения 
существующего кода.
  Композиция и делегирование 
часто используются для динамического добавления нового 
поведения.
  Паттерн Декоратор предоставляет альтернативу 
субклассированию в области 
расширения поведения.
  Типы декораторов соответствуют типам декорируемых 
компонентов (соответствие 
достигается посредством наследования или реализации 
интерфейса).
  Декораторы изменяют поведение компонентов, добавляя 
новую функциональность 
до и (или) после (или даже 
вместо) вызовов методов 
компонентов.
  Компонент может декорироваться любым количеством 
декораторов.
  Декораторы обычно прозрачны для клиентов компонента 
(если клиентский код не 
зависит от конкретного типа 
компонента).
Инкапсулируйте то, что 
изменяется.
Отдавайте предпочтение 
композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты для расширения, но 
закрыты для изменения.
Принципы
Подошла к концу очередная глава, а в вашем
ОО-инструментарии появился новый принцип 
и паттерн.
Согласно принципу открытости/закрытости системы должны 
проектироваться так, 
чтобы их закрытые 
компоненты были изолированы от новых 
расширений.
Наш первый паттерн для создания архитектур, удовлетворяющих принципу открытости/закрытости. Или не первый? 
А может, один из описанных ранее паттернов тоже следовал этому принципу?
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Наблюдатель — определяет отношение «один-комногим» между объектами 
таким образом, что при изменении состояния одного объекта 
происходит автоматическое 
оповещение и обновление всех зависимых объектов
Декоратор — динамически 
наделяет объект новыми возможностями и является гибкой 
альтернативой субклассированию 
в области расширения функциональности.
138 глава 3
 public class Beverage {
 // Объявление переменных экземпляров для milkCost,
 // soyCost, mochaCost и whipCost, а также
 // get/set-методов для дополнений
 public double cost() {
 double condimentCost = 0.0;
 if (hasMilk()) {
 condimentCost += milkCost;
 }
 if (hasSoy()) {
 condimentCost += soyCost;
 }
 if (hasMocha()) {
 condimentCost += mochaCost;
 }
 if (hasWhip()) {
 condimentCost += whipCost;
 }
 return condimentCost;
 }
}
public class DarkRoast extends Beverage {
 public DarkRoast() {
 description = "Most Excellent Dark Roast";
 }
 public double cost() {
 return 1.99 + super.cost();
 }
}
ответы к упражнениям
Возьми в руку карандаш
 Решение Напишите методы cost() для следующих 
классов (подойдет и псевдокод Java). Наше 
решение выглядит так:
паттерн декоратор
дальше   139
Star
buzz Coffee
Mocha
HouseBlend
Mocha
Soy
Whip
cost() cost() cost() cost() cost()
.15 .89 .20 .20 $1.54 .10
Сначала cost() вызывается для 
внешнего декоратора Whip.
Whip вызывает cost() для Mocha.
Последнее дополнение! 
Soy вызывает cost() для 
HouseBlend.
Наконец, результат возвращается 
методу cost() объекта Whip, который 
прибавляет еще 10 центов, и мы 
получаем итоговую стоимость $1.54.
1
2
5
10
3 Mocha вызывает cost() для другого 
объекта Mocha.
4 Теперь Mocha вызывает cost() для Soy.
Обучение бариста
«латте с двойным шоколадом, соей и взбитыми сливками»
Метод cost() объекта 
HouseBlend возвращает 
89 центов на предыдущий 
уровень стека.
6
Метод cost() объекта 
Soy прибавляет 
15 центов и возвращает 
результат.
7
Метод cost() второго 
объекта Mocha прибавляет 
20 центов и возвращает 
результат.
8
Метод cost() первого объекта Mocha 
прибавляет 20 центов и возвращает 
результат.
9
Возьми в руку карандаш
 Решение
140 глава 3
ответы к упражнениям
Мы добавили метод getSize() 
для декораторов, которые 
просто возвращают объем 
напитка.
Здесь мы получаем размер 
напитка (вызов передается 
вниз до уровня конкретного 
напитка), после чего прибавляем стоимость.
Наши друзья из Starbuzz ввели в меню разные размеры порций. Теперь кофе можно 
заказать в маленькой, средней или большой чашке. Starbuzz считает размер порции 
неотъемлемой частью класса кофе, поэтому в класс Beverage были добавлены два новых метода: setSize() и getSize(). Стоимость дополнений также зависит от размера 
порции, так что, скажем, добавка сои должна стоить 10, 15 или 20 центов для маленькой, средней или большой порции соответственно.
Как бы вы изменили классы декораторов в соответствии с новыми требованиями?
Возьми в руку карандаш
 Решение
public abstract class CondimentDecorator extends Beverage {
 public Beverage beverage;
 public abstract String getDescription();
 
 public Size getSize() {
 return beverage.getSize();
 }
}
public class Soy extends CondimentDecorator {
 public Soy(Beverage beverage) {
 this.beverage = beverage;
 }
 public String getDescription() {
 return beverage.getDescription() + ", Soy";
 }
 public double cost() {
 double cost = beverage.cost();
 if (beverage.getSize() == Size.TALL) {
 cost += .10;
 } else if (beverage.getSize() == Size.GRANDE) {
 cost += .15;
 } else if (beverage.getSize() == Size.VENTI) {
 cost += .20;
 }
 return cost;
 }
}
4 Паттерн Фабрика
Приготовьтесь заняться выпечкой объектов в слабосвязанных 
ОО-архитектурах. Создание объектов отнюдь не сводится к простому вызову оператора new. Оказывается, создание экземпляров не всегда 
должно осуществляться открыто; оно часто создает проблемы сильного 
связывания. А ведь вы этого не хотите, верно? Паттерн Фабрика спасет 
вас от неприятных зависимостей.
Домашняя ОО-выпечка
142 глава 4
Да, при использовании new вы создаете экземпляр конкретного класса, 
поэтому эта операция относится к уровню реализации, а не интерфейса. 
А вы уже знаете, что привязка кода к конкретному классу делает его менее гибким и устойчивым к изменениям.
Duck duck; 
if (picnic) {
 duck = new MallardDuck();
} else if (hunting) {
 duck = new DecoyDuck();
} else if (inBathTub) {
 duck = new RubberDuck();
}
В программе создаются экземпляры разных конкретных классов, причем класс выбирается во время 
выполнения в зависимости от неких условий.
Когда настанет время изменения или расширения, вам придется снова открыть код и разобраться 
в том, что нужно добавить (или удалить). Часто подобный код размещается в разных частях приложения, что основательно затрудняет его сопровождение и обновление.
Duck duck = new MallardDuck();
Следует использовать аб
страктные типы, чтобы 
-
код был более гибким.
Но создается экземпляр 
конкретного класса!
Если в вашей архитектуре используется набор взаимосвязанных конкретных классов, часто в конечном итоге пишется код следующего вида:
Иерархия состоит из многих классов, и класс создаваемого экземпляра определяется только во время 
выполнения.
Видим new — подразумеваем конкретный.
размышления о new
Позади уже три главы, а вы так и не 
ответили на мой вопрос о new. Мы не 
должны программировать на уровне реализации, но ведь при каждом вызове new
мы именно это и делаем, верно?
паттерн фабрика
дальше   143
С технической точки зрения в операторе new нет ничего плохого. В конце концов, он стал основополагающей частью большинства современных объектно-ориентированных языков. Проблемы создает наш давний знакомый — ИЗМЕНЕНИЕ и его влияние 
на использование new. 
Программируя на уровне интерфейса, вы знаете, что можете 
оградить себя от многих изменений в системе. Почему? Благодаря полиморфизму код, написанный для интерфейса, будет работать с любыми новыми классами, реализующими этот интерфейс. Но если в коде используются многочисленные конкретные 
классы, его придется изменять с добавлением новых конкретных классов. Иначе говоря, код перестает быть «закрытым для 
изменения» — для расширения новыми конкретными типами 
его придется открывать.
Так что же делать? В подобных ситуациях полезно вернуться 
к принципам проектирования и поискать в них подсказки. Напоминаем: первый принцип, непосредственно относящийся 
к изменениям, предлагает определить аспекты, которые будут изменяться, и отделить их от тех, которые останутся неизменными.
А если взять все части приложения, в которых создаются экземпляры конкретных классов, 
и отделить их от других частей приложения? Как бы вы это сделали?
Помните, что архитектуры должны быть «открыты 
для расширения, но закрыты 
для изменения». За подробностями обращайтесь
к главе 3.
Чем плох оператор new?
Мозговой
штурм
Но ведь объект нужно как-то создать, 
а в Java существует только 
один способ, верно? Так о чем тут 
говорить?
144 глава 4
Определение изменяемых аспектов
Допустим, вы открыли пиццерию. Будучи современным предпринимателем из Объектвиля, вы пишете код следующего вида:
Pizza orderPizza() {
Pizza pizza = new Pizza();
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
По соображениям гибкости 
хотелось бы использовать 
абстрактный класс или ин
терфейс. К сожалению, их 
-
экземпляры нельзя создавать 
напрямую.
Поэтому вы добавляете код, который определяет нужный тип пиццы, а затем переходит к ее изготовлению:
Тип пиццы передается 
orderPizza при вызове.
В зависимости от типа мы 
создаем экземпляр нужного 
конкретного класса и присваиваем его переменной pizza. 
Обратите внимание: каждый 
тип пиццы должен реализовать интерфейс Pizza.
Pizza orderPizza(String type) {
Pizza pizza;
 if (type.equals("cheese")) {
 pizza = new CheesePizza();
 } else if (type.equals("greek") {
 pizza = new GreekPizza();
} else if (type.equals("pepperoni") {
 pizza = new PepperoniPizza();
 } 
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
Но существует много разновидностей пиццы...
определение изменяемых аспектов
Получив объект Pizza, мы готовим 
пиццу (замешиваем тесто, выкладываем соус, кладем добавки), ставим 
в печь, нарезаем и упаковываем!
Каждый подтип Pizza (CheesePizza, 
GreekPizza и т. д.) знает, как приготовить себя.
паттерн фабрика
дальше   145
Pizza orderPizza(String type) {
Pizza pizza;
 if (type.equals("cheese")) {
 pizza = new CheesePizza();
 } else if (type.equals("greek") {
 pizza = new GreekPizza();
} else if (type.equals("pepperoni") {
 pizza = new PepperoniPizza();
} else if (type.equals("clam") {
 pizza = new ClamPizza();
} else if (type.equals("veggie") {
 pizza = new VeggiePizza();
 } 
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
Вы прослышали, что все конкуренты включили в свои меню модные 
виды пиццы: с мидиями и вегетарианскую. Разумеется, чтобы не отстать, вы должны включить их в свое меню. А греческая пицца в последнее время продается плохо, поэтому вы решаете отказаться от 
этой позиции:
С течением времени 
вам придется изменять этот код 
снова и снова.
В целом процедура приготовления, выпечки и упаковки пиццы остается неизменной в течение многих 
лет. Таким образом, этот 
код меняться не должен — 
меняются только виды 
пиццы, с которыми он 
работает.
Этот код НЕ закрыт 
для изменения. При изменении ассортимента придется вернуться к коду и вносить
в него изменения.
Выбор конкретного класса для создания экземпляра усложняет метод orderPizza() и не позволяет закрыть его для изменений. А если 
одни аспекты системы изменяются, а другие остаются неизменными, 
пора заняться инкапсуляцией.
Добавление новых типов пиццы
146 глава 4
 if (type.equals("cheese")) {
 pizza = new CheesePizza();
} else if (type.equals("pepperoni") {
 pizza = new PepperoniPizza();
} else if (type.equals("clam") {
 pizza = new ClamPizza();
} else if (type.equals("veggie") {
 pizza = new VeggiePizza();
 } 
Итак, код создания объекта следует исключить из метода orderPizze(). Но как? Мы переместим его в другой объект, единственной задачей которого будет создание объектов пиццы.
Pizza orderPizza(String type) {
Pizza pizza;
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
return pizza;
}
Извлекаем код создания объекта из метода orderPizza.
Код выделяется в объект, который 
занимается только созданием пиццы 
и ничем более. Если другому объекту 
понадобится создать пиццу, он обратится к нему с запросом.
У нового объекта имеется подходящее имя: мы назовем его 
Фабрикой.
Фабрика инкапсулирует подробности создания объектов. Метод 
orderPizza() становится обычным клиентом фабрики SimplePizzaFactory. 
Каждый раз, когда ему понадобится новая пицца, он просит фабрику 
ее создать. Прошли те времена, когда метод orderPizza() должен был 
знать, чем греческая пицца отличается от вегетарианской. Теперь метод 
orderPizza() знает лишь то, что полученный им объект реализует интерфейс Pizza для вызова методов prepare(), bake(), cut() и box().
Осталось разобраться с некоторыми подробностями — например, чем заменяется код создания объекта в методе orderPizza()? Давайте реализуем 
простую фабрику пиццы и узнаем...
Что будет на этом 
месте?
SimplePizzaFactory
Инкапсуляция создания объектов
инкапсуляция создания объектов
паттерн фабрика
дальше   147
Построение простой фабрики для пиццы
Начнем с самой фабрики. Наша задача — определить класс, инкапсулирующий создание 
объектов для всех видов пиццы. Вот как он выглядит...
Код, выделенный из метода orderPizza().
В фабрике определяется 
метод createPizza(), который 
будет использоваться всеми 
клиентами для создания новых 
объектов.
Класс SimplePizzaFactory занимается исключительно 
созданием пиццы для своих клиентов.
Код параметризуется по типу 
пиццы, как и наш исходный метод orderPizza().
В: И что нам это дает? Проблема просто перекладывается на другой объект.
О: Класс SimplePizzaFactory может использоваться многими клиентами. Пока 
мы видим только метод orderPizza(), но 
фабрика также может использоваться 
классом PizzaShopMenu для получения пиццы по описанию и цене. Класс 
HomeDelivery может использовать объекты еще как-нибудь иначе, при этом он 
тоже остается клиентом фабрики.
Таким образом, создание объекта инкапсулируется в одном классе, и будущие 
изменения реализации придется вносить 
только в одном месте.
И не забывайте: из клиентского кода также 
исключаются операции создания экземпляров конкретных типов!
В: Мне встречалось похожее решение, в котором фабрика объявлялась 
статическим методом. Чем они различаются?
О: Зачем фабрики оформляются в виде 
статических методов? Чтобы метод create 
можно было вызывать и без создания 
экземпляра объекта. С другой стороны, 
теряется возможность субклассирования 
и изменения поведения метода create.
public class SimplePizzaFactory {
 public Pizza createPizza(String type) {
 Pizza pizza = null;
 if (type.equals("cheese")) {
 pizza = new CheesePizza();
 } else if (type.equals("pepperoni")) {
 pizza = new PepperoniPizza();
 } else if (type.equals("clam")) {
 pizza = new ClamPizza();
 } else if (type.equals("veggie")) {
 pizza = new VeggiePizza();
 }
 return pizza;
 }
}
часто Задаваемые вопросы
148 глава 4
public class PizzaStore {
 SimplePizzaFactory factory;
 public PizzaStore(SimplePizzaFactory factory) { 
 this.factory = factory;
 }
 public Pizza orderPizza(String type) {
 Pizza pizza;
 pizza = factory.createPizza(type);
 pizza.prepare();
 pizza.bake();
 pizza.cut();
 pizza.box();
 return pizza;
 }
 // other methods here
}
Переработка класса PizzaStore 
PizzaStore сохраняет ссылку
на фабрику в конструкторе.
Метод orderPizza() обращается 
к фабрике с запросом на создание объекта, передавая тип 
заказа.
Обратите внимание: оператор new заменяется методом 
createPizza объекта factory. 
Конкретные экземпляры более 
не создаются!
Пора заняться клиентским кодом. Мы хотим, чтобы все операции создания объектов выполнялись 
фабрикой. Для этого необходимо внести следующие изменения:
Классу PizzaStore передается ссылка
на SimplePizzaFactory.
Композиция объектов позволяет (среди прочего) динамически изменять поведение во время выполнения, так как мы можем свободно подключать и отключать реализации. Как использовать эту возможность в PizzaStore?
Например, можно представить себе фабрики пиццы по стандартам, принятым в разных регионах: 
Нью-Йорк, Чикаго, Калифорния (да, и не забудьте про Нью-Хейвен!).
простая фабрика
Мозговой
штурм
паттерн фабрика
дальше   149
Определение Простой Фабрики
Строго говоря, Простая Фабрика не является паттерном проектирования, 
скорее это идиома программирования. Но она используется так часто, что 
мы решили упомянуть ее здесь. Некоторые разработчики путают эту идиоЗаслуженный 
помощник
паттернов
Заслуженный 
помощник 
паттернов
Впрочем, Простая Фабрика была всего лишь разминкой. Сейчас мы изучим две другие разновидности 
Фабрики, и обе они являются полноценными паттернами. Больше паттернов, больше пиццы!
Фабрика должна быть единственной 
частью приложения, работающей 
с конкретными классами пиццы...
Клиент Фабрики. 
PizzaStore обращается 
к SimplePizzaFactory для 
получения экземпляров.
SimplePizzaFactory
createPizza()
PizzaStore Pizza
orderPizza()
VeggiePizza ClamPizza
CheesePizza PepperoniPizza
prepare()
bake()
cut()
box()
Конкретные продукты. Каждый продукт должен реализовать интерфейс* Pizza и быть 
конкретным. Если эти условия 
выполняются, фабрика создает 
экземпляр и возвращает его 
клиенту.
Продукт, производимый фабрикой: пицца!
Абстрактный класс 
с полезными реализациями, которые 
могут переопределяться в субклассах. Метод create часто 
декларируется статическим.
*В паттернах проектирования фраза «реализация интерфейса» НЕ ВСЕГДА обозначает «класс, реализующий интерфейс Java с ключевым словом implements в объявлении». В более общем смысле реализация конкретным классом метода супертипа 
(класса ИЛИ интерфейса) считается «реализацией интерфейса» этого супертипа.
му с паттерном Фабрика, но когда это произойдет в следующий раз, вы сможете тонко намекнуть, что 
вы в курсе дела; только не важничайте, когда будете просвещать собеседника.
Хотя Простая Фабрика не является ПОЛНОЦЕННЫМ паттерном, это не значит, что ее не стоит изучить более подробно. Рассмотрим диаграмму классов нашего нового магазина пиццы:
150 глава 4
Расширение бизнеса
Дела вашей пиццерии в Объектвиле идут так хорошо, что вы 
сокрушили всех конкурентов и теперь планируете открыть 
целую сеть пиццерий PizzaStore по всей стране. Вы как правообладатель желаете обеспечить высокое качество пиццы в заведениях, работающих под вашей маркой, и поэтому требуете, 
чтобы они использовали ваш проверенный код.
Но что делать с региональными различиями? Заведения могут 
предлагать разные стили пиццы в зависимости от своего местонахождения (Нью-Йорк, Чикаго, Калифорния и т. д.) и предпочтений местных ценителей итальянской кухни.
PizzaStore
NYPizzaFactory
ChicagoPizzaFacto
ry
Все пиццерии вашей сети должны использовать код PizzaStore, 
чтобы все пиццы готовились
по единым правилам.
Этой пиццерии нужна 
фабрика для изготовления пиццы в ньюйоркском стиле: тонкая 
основа, изысканный соус 
и небольшое количество 
сыра.
А этой пиццерии 
нужна фабрика для 
изготовления пиццы 
в чикагском стиле: толстая основа, 
густой соус и много 
сыра.
Мы рассмотрели один способ...
SimplePizzaFactory заменяется тремя разными фабриками: NYPizzaFactory, ChicagoPizzaFactory и CaliforniaPizzaFactory. В этом случае PizzaStore связывается с подходящей фабрикой посредством композиции.
Давайте посмотрим, как будет выглядеть реализация...
расширение бизнеса
Да, в разных частях США 
готовится разная пицца – 
от чикагской пиццы с высоким 
краем до пиццы на тонком 
тесте из Нью-Йорка или хрустящей калифорнийской пиццы 
(говорят, ее делают даже 
с фруктами и орехами).
паттерн фабрика
дальше   151
NYPizzaFactory nyFactory = new NYPizzaFactory();
PizzaStore nyStore = new PizzaStore(nyFactory);
nyStore.order("Veggie");
ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();
PizzaStore chicagoStore = new PizzaStore(chicagoFactory);
chicagoStore.order("Veggie");
Сначала создаем фабрику для 
пиццы в нью-йоркском стиле.
Затем создаем объект 
PizzaStore и передаем ему 
ссылку на фабрику.
...и при создании экземпляров получаем пиццу в нью-йоркском стиле.
Аналогично для пиццерии из Чикаго: создаем фабрику для объектов 
и связываем ее с классом пиццерии. 
Фабрика создает пиццу в чикагском 
стиле.
Как избежать проблем с качеством?
Исследование рынка показало, что пиццерии вашей сети используют ваши фабрики для создания 
пиццы, но в остальных фазах процесса применяют 
свои доморощенные правила: выбирают свой режим выпечки, забывают нарезать пиццу, используют упаковку сторонних фирм и т. д. 
После некоторых размышлений становится ясно: 
нам нужна инфраструктура, которая связывает пиццерию с процессом создания пиццы, но при этом 
сохраняет достаточную гибкость. 
До создания SimplePizzaFactory наш код изготовления пиццы был привязан к PizzaStore, но гибкости 
не было и в помине. Что же делать?
В хорошей торговой сети такого 
быть НЕ ДОЛЖНО. Кто знает, 
что он кладет в свою пиццу?
Я уже много лет готовлю 
пиццу. Пожалуй, процесс 
PizzaStore стоит немного 
«улучшить»...
152 глава 4
public abstract class PizzaStore {
public Pizza orderPizza(String type) {
 Pizza pizza;
 pizza = createPizza(type);
 pizza.prepare();
 pizza.bake();
 pizza.cut();
 pizza.box();
 return pizza;
}
abstract Pizza createPizza(String type);
}
Итак, мы хотим локализовать все операции по изготовлению пиццы в классе 
PizzaStore, но при этом сохранить для пиццерий достаточную гибкость для выбора своего регионального стиля. И это можно сделать!
Для этого мы вернем метод createPizza() в класс PizzaStore, но в виде абстрактного метода, а затем создадим субкласс для каждого регионального стиля.
Начнем с изменений в PizzaStore: 
Инфраструктура для пиццерии
Метод createPizza снова принадлежит PizzaStore, а не классу 
фабрики.
Здесь ничего не изменилось...
Объект фабрики перемещается в этот метод.
«Фабричный метод» стал абстрактным методом PizzaStore.
Класс PizzaStore стал абстрактным
(почему — см. ниже).
Мы создадим субкласс для каждой региональной разновидности пиццерии 
(NYPizzaStore, ChicagoPizzaStore, CaliforniaPizzaStore), и каждый субкласс будет 
сам принимать решения относительно создания объекта. Давайте посмотрим, 
как это происходит.
пусть решают субклассы
паттерн фабрика
дальше   153
public Pizza createPizza(type) {
 if (type.equals("cheese")) {
 pizza = new NYStyleCheesePizza();
 } else if (type.equals("pepperoni") {
 pizza = new NYStylePepperoniPizza();
 } else if (type.equals("clam") {
 pizza = new NYStyleClamPizza();
 } else if (type.equals("veggie") {
 pizza = new NYStyleVeggiePizza();
 }
}
createPizza()
ChicagoStylePizzaStore
createPizza()
NYStylePizzaStore
public Pizza createPizza(type) {
 if (type.equals("cheese")) {
 pizza = new ChicagoStyleCheesePizza();
 } else if (type.equals("pepperoni") {
 pizza = new ChicagoStylePepperoniPizza();
 } else if (type.equals("clam") {
 pizza = new ChicagoStyleClamPizza();
 } else if (type.equals("veggie") {
 pizza = new ChicagoStyleVeggiePizza();
 }
}
Аналогичным образом 
субкласс для Чикаго содержит реализацию 
createPizza() с нужными 
ингредиентами.
Если пиццерия хочет 
готовить пиццу в 
нью-йоркском стиле, 
она использует субкласс с соответствующей версией метода 
createPizza().
Каждый субкласс переопределяет метод createPizza(), при этом 
все субклассы используют метод 
orderPizza() из класса PizzaStore. 
При необходимости метод 
orderPizza() можно было бы объявить финальным (final).
createPizza()
orderPizza()
PizzaStore
Принятие решений в субклассах
Итак, метод orderPizza() класса PizzaStore уже содержит проверенную систему оформления заказа, 
и вы хотите, чтобы во всех пиццериях эта процедура оставалась одинаковой.
Региональные версии PizzaStore различаются стилем своей пиццы: у нью-йоркской пиццы тонкая основа, у чикагской — толстая, и т. д. Мы инкапсулируем все эти различия в методе createPizza() и сделаем его ответственным за создание правильного вида пиццы. Для этого каждому субклассу PizzaStore 
будет разрешено самостоятельно определить свой метод createPizza(). Итак, у нас получается группа 
конкретных субклассов PizzaStore со своими разновидностями пиццы, причем все эти классы входят 
в инфраструктуру PizzaStore и продолжают использовать проверенный метод orderPizza().
НЕ ЗАБУДЬТЕ: метод 
createPizza() объявлен абстрактным в PizzaStore, поэтому все 
подтипы пиццерий ОБЯЗАНЫ 
реализовать этот метод.
154 глава 4
Взгляните на происходящее с точки зрения метода orderPizza() класса 
PizzaStore: он определяется в абстрактном классе PizzaStore, но конкретные 
типы создаются только в субклассах.
createPizza()
orderPizza()
PizzaStore
createPizza()
ChicagoStylePizzaStore
createPizza()
orderPizza()
pizza = createPizza();
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
PizzaStore
createPizza()
NYStylePizzaStore
Метод orderPizza() определяется
в абстрактном классе PizzaStore,
но не в субклассах.
Метод orderPizza() выполняет целый ряд операций с объектом Pizza (prepare, 
bake, cut, box), но, так как класс Pizza является абстрактным, orderPizza() не 
знает, с какими конкретными классами он работает. Иначе говоря, здесь используется слабая связь!
Когда orderPizza() вызывает createPizza(), управление передается одному из субклассов. Какая именно 
из конкретных разновидностей пиццы будет создана? Это зависит от типа пиццерии: NYStylePizzaStore 
или ChicagoStylePizzaStore.
Итак, есть ли здесь решение, принимаемое субклассами во время выполнения? Нет, но с точки зрения orderPizza() при выборе NYStylePizzaStore этот субкласс определяет разновидность создаваемой 
пиццы. Таким образом, «решение» принимают не субклассы, а вы, когда выбираете нужный тип пиццерии. Но субклассы определяют тип пиццы, которая будет создана по запросу.
Чтобы получить объект, orderPizza() вызывает createPizza(). Но 
к какому конкретному типу будет относиться объект? Метод 
orderPizza() этого решить не может; тогда кто решает?
как субклассы принимают решения?
Не понимаю. Как субклассы 
PizzaStore могут что-то решать? 
Я не вижу в NYStylePizzaStore 
никакого кода принятия решений...
паттерн фабрика
дальше   155
Субклассы PizzaStore
public class NYPizzaStore extends PizzaStore {
 Pizza createPizza(String item) {
 if (item.equals("cheese")) {
 return new NYStyleCheesePizza();
 } else if (item.equals("veggie")) {
 return new NYStyleVeggiePizza();
 } else if (item.equals("clam")) {
 return new NYStyleClamPizza();
 } else if (item.equals("pepperoni")) {
 return new NYStylePepperoniPizza();
 } else return null;
 }
}
Класс NYPizzaStore расширяет PizzaStore, поэтому он наследует метод 
orderPizza()*.
Необходимо реализовать 
метод createPizza(), так 
как в PizzaStore он объявлен 
абстрактным.
Региональные пиццерии получают всю функциональность PizzaStore 
бесплатно. Им остается субклассировать PizzaStore и предоставить метод createPizza(), реализующий их местный стиль приготовления пиццы. 
В нашей модели поддерживаются три основных региональных стиля.
Нью-йоркский стиль приготовления пиццы:
Когда мы закончим работу над субклассами PizzaStore, можно будет с чистой совестью заказать пиццу 
или две. Но сначала переверните страницу и попробуйте самостоятельно построить региональные 
классы пиццерий для Чикаго и Калифорнии.
Здесь создаются конкретные классы. Для 
каждого типа пиццы мы 
создаем реализацию
в нью-йоркском стиле.
* Метод orderPizza() суперкласса понятия не имеет, 
какой из типов пиццы мы создаем; он знает лишь то, 
что пиццу можно приготовить, выпечь, нарезать
и упаковать!
createPizza() возвращает объект Pizza,
а субкласс несет полную ответственность за создаваемый конкретный экземпляр Pizza.
156 глава 4
Класс NYPizzaStore уже готов; еще два класса, и бизнес можно 
будет запускать! Запишите в этой врезке реализации PizzaStore 
для Чикаго и Калифорнии:
фабричный метод
Возьми в руку карандаш
паттерн фабрика
дальше   157
Всего пара преобразований в PizzaStore — и мы перешли от объекта, создающего экземпляры конкретных классов, к набору классов, 
решающих ту же задачу. Давайте присмотримся повнимательнее:
Субклассы PizzaStore создают экземпляры объектов за 
нас при вызове createPizza().
createPizza()
NYStylePizzaStore
createPizza()
ChicagoStylePizzaStore
Объявление Фабричного Метода
public abstract class PizzaStore {
 public Pizza orderPizza(String type) {
 Pizza pizza;
 pizza = createPizza(type);
 pizza.prepare();
 pizza.bake();
 pizza.cut();
 pizza.box();
 return pizza;
 }
 protected abstract Pizza createPizza(String type);
 // Другие методы
}
Вся ответственность за 
создание экземпляров Pizza 
перемещена в метод, действующий как фабрика.
Код под увеличительным стеклом
Фабричный метод отвечает за создание объектов и инкапсулирует эту операцию в субклассе. Таким образом клиентский код 
в суперклассе отделяется от кода создания объекта в субклассе.
abstract Product factoryMethod(String type)
Фабричный метод объ
является абстрактным, 
-
чтобы субклассы предо
ставили реализацию 
-
создания объектов.
Фабричный метод 
может быть параметризован для 
выбора между несколькими разновидностями продукта.
Фабричный метод изолирует 
клиента (код суперкласса — 
такой, как orderPizza()) от информации о конкретном типе 
создаваемого продукта.
Фабричный метод возвращает некий тип Product, 
обычно используемый методами, определенными в суперклассе.
158 глава 4
Люблю нью-йоркскую 
пиццу.... Знаешь, тонкая 
основа, немного сыра 
и правильный соус.
А я хочу чикагскую пиццу 
с толстой основой и горой 
сыра...
Итану придется 
заказать свою пиццу в нью-йоркской 
пиццерии.
Заказ Джоэла будет 
оформлен в чикагской пиццерии. Метод 
оформления заказа 
тот же, а пицца — 
другая!
Итан
Джоэл
Заказ пиццы с использованием фабричного метода
1
2
Для начала Джоэлу и Итану понадобятся экземпляры субклассов PizzaStore. Джоэл создает экземпляр ChicagoPizzaStore, а Итан — экземпляр NYPizzaStore.
Имея экземпляр PizzaStore, Итан и Джоэл вызывают метод orderPizza() и передают ему 
тип нужной пиццы (вегетарианская, с сыром и т. д.).
4 Метод orderPizza() не знает, какая разновидность пиццы была создана, но знает, что это 
именно пицца. Соответственно, он готовит, выпекает, нарезает и упаковывает пиццу 
для Итана и Джоэла.
3 Для создания объекта вызывается метод createPizza(), который определяется в двух 
субклассах: NYPizzaStore и ChicagoPizzaStore. В нашем определении NYPizzaStore создает экземпляр нью-йоркской пиццы, а ChicagoPizzaStore — экземпляр чикагской пиццы. 
В любом случае методу orderPizza() возвращается экземпляр Pizza.
Как происходит оформление заказа?
заказываем пиццу
паттерн фабрика
дальше   159
Что происходит в процессе заказа...
1
2
PizzaStore nyPizzaStore = new NYPizzaStore();
Проследим за заказом Итана. Сначала создается объект NYPizzaStore:
nyPizzaStore.orderPizza("cheese");
Пиццерия построена, теперь можно принять заказ:
3 Метод orderPizza() вызывает метод createPizza():
4 В итоге мы получаем сырую пиццу, и метод orderPizza() 
завершает ее приготовление:
Pizza pizza = createPizza("cheese");
nyPizzaStore
Создание экземпляра 
NYPizzaStore.
Метод orderPizza() вызывается для экземпляра 
nyPizzaStore (выполняется 
метод, определенный
в PizzaStore).
Pizza
createPizza("cheese")
Напоминаем: фабричный метод 
createPizza() реализуется в субклассе. В данном случае он возвращает пиццу с сыром в ньюйоркском стиле.
pizza.prepare();
pizza.bake();
pizza.cut();
pizza.box();
Все эти методы определяются 
в конкретном объекте, который 
возвращается фабричным методом 
createPizza(), определяемым Метод orderPizza() получает объ
в NYPizzaStore.
-
ект Pizza, но не знает его конкретный субкласс.
За сценой
160 глава 4
Не хватает только одного: ПИЦЦЫ!
public abstract class Pizza {
 String name;
 String dough;
 String sauce;
 List<String> toppings = new ArrayList<String>();
 void prepare() {
 System.out.println("Preparing " + name);
 System.out.println("Tossing dough...");
 System.out.println("Adding sauce...");
 System.out.println("Adding toppings: ");
 for (String topping : toppings) {
 System.out.println(" " + topping);
 }
 }
 
 void bake() {
 System.out.println("Bake for 25 minutes at 350");
 }
 void cut() {
 System.out.println("Cutting the pizza into diagonal slices");
 }
 
 void box() {
 System.out.println("Place pizza in official PizzaStore box");
 }
 public String getName() {
 return name;
 }
}
Без пиццы наше заведение вряд ли будет популярным. Пора заняться ее реализацией:
Начнем с абстрактного класса 
Pizza, который станет суперклассом для конкретных классов пиццы.
Каждый объект Pizza содержит название, 
тип основы, тип соуса и набор добавок.
Абстрактный класс 
предоставляет реализации по умолчанию для 
основных методов.
Приготовление пиццы состоит из нескольких шагов, 
выполняемых в определенной 
последовательности.
классы пиццы
ПОМНИТЕ: мы не включаем в листинге команды 
import и package. Полный исходный код можно получить на сайте WickedlySmart по адресу
https://wickedlysmart.com/head-first-design-patterns
Если вы забудете этот URL-адрес, вы легко найдете 
его во введении.
.
паттерн фабрика
дальше   161
public class NYStyleCheesePizza extends Pizza {
 public NYStyleCheesePizza() { 
 name = "NY Style Sauce and Cheese Pizza";
 dough = "Thin Crust Dough";
 sauce = "Marinara Sauce";
 toppings.add("Grated Reggiano Cheese");
 }
}
public class ChicagoStyleCheesePizza extends Pizza {
 public ChicagoStyleCheesePizza() { 
 name = "Chicago Style Deep Dish Cheese Pizza";
 dough = "Extra Thick Crust Dough";
 sauce = "Plum Tomato Sauce";
 toppings.add("Shredded Mozzarella Cheese");
 }
 void cut() {
 System.out.println("Cutting the pizza into square slices");
 }
}
Остается определить конкретные субклассы... Как насчет определения 
нью-йоркской и чикагской пиццы с сыром?
Нью-йоркская пицца готовится с соусом «маринара» на тонкой основе.
Одна добавка: сыр 
«реджано»!
В чикагскую пиццу 
кладут много сыра 
«моцарелла»!
Чикагская пицца также переопределяет метод cut(): она нарезается
не клиньями, а квадратами.
Чикагская пицца использует томатный 
соус и готовится на 
толстой основе.
162 глава 4
public class PizzaTestDrive {
 public static void main(String[] args) {
 PizzaStore nyStore = new NYPizzaStore();
 PizzaStore chicagoStore = new ChicagoPizzaStore();
 Pizza pizza = nyStore.orderPizza("cheese");
 System.out.println("Ethan ordered a " + pizza.getName() + "\n");
 pizza = chicagoStore.orderPizza("cheese");
 System.out.println("Joel ordered a " + pizza.getName() + "\n");
 }
}
Сколько можно ждать, несите пиццу!
%java PizzaTestDrive
Preparing NY Style Sauce and Cheese Pizza
Tossing dough...
Adding sauce...
Adding toppings: 
 Grated Regiano cheese
Bake for 25 minutes at 350
Cutting the pizza into diagonal slices
Place pizza in official PizzaStore box
Ethan ordered a NY Style Sauce and Cheese Pizza
Preparing Chicago Style Deep Dish Cheese Pizza
Tossing dough...
Adding sauce...
Adding toppings: 
 Shredded Mozzarella Cheese
Bake for 25 minutes at 350
Cutting the pizza into square slices
Place pizza in official PizzaStore box
Joel ordered a Chicago Style Deep Dish Cheese Pizza
File Edit Window Help YouWantMootzOnThatPizza?
Сначала создаем два 
объекта пиццерий.
Затем используем один из них для 
выполнения заказа 
Итана.
А другой — для заказа Джоэла.
Обе пиццы готовятся со 
всеми добавками, выпекаются, нарезаются и упаковываются. Суперклассу 
не нужно знать подробности — субкласс решает все проблемы, просто создавая правильный 
экземпляр.
готовим пиццу
паттерн фабрика
дальше   163
createPizza()
ChicagoPizzaStore
createPizza()
NYPizzaStore
Pizza
NYStyleCheesePizza
NYStyleVeggiePizza
NYStyleClamPizza
NYStylePepperoniPizza
ChicagoStyleVeggiePizza
ChicagoStyleClamPizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
createPizza()
orderPizza()
PizzaStore
Пора познакомиться с паттерном Фабричный Метод
Все фабричные паттерны инкапсулируют операции создания объектов. Паттерн Фабричный Метод 
позволяет субклассам решить, какой объект следует создать. На следующих диаграммах классов представлены основные участники этого паттерна:
Часто создатель содержит код, 
зависящий от абстрактного 
продукта, производимого субклассом. Создатель никогда не 
знает, какой конкретный продукт будет произведен.
Так как каждая пиццерия имеет собственный субкласс 
PizzaStore, она может 
создать собственный стиль пиццы, реализуя метод 
createPizza().
В нашем примере 
createPizza()
метод, производящий про
— фабричный 
-
дукт.
Абстрактный класссоздатель; определяет 
абстрактный фабрич
ный метод, реализуемый 
-
субклассами для создания 
продуктов.
Конкретные продукты — разные виды 
пиццы, производимые
в наших пиццериях.
Фабрики производят продукты; у класса PizzaStore 
продуктом является Pizza.
Классы-создатели
Классы-продукты
Классы, создающие продукты, называются конкретными создателями.
164 глава 4
Параллельные иерархии создателей и продуктов
Для каждого конкретного создателя обычно существует целый набор создаваемых им 
продуктов. Создатели пиццы из Чикаго создают разные виды пиццы в чикагском стиле, создатели пиццы из Нью-Йорка — разные виды пиццы в нью-йоркском стиле, и т. д. 
Фактически мы можем рассматривать группы классов создателей и соответствующих 
им продуктов как параллельные иерархии. 
Рассмотрим две параллельные иерархии классов:
Pizza
NYPizzaStore инкапсулирует сведения о том, 
как готовить ньюйоркскую пиццу. ChicagoPizzaStore инкапсулирует все сведения о том, как готовить чикагскую пиццу.
Обратите внимание на параллелизм: обе иерархии содержат абстрактные классы, 
расширяемые конкретными 
классами со специализированными реализациями для НьюЙорка и Чикаго.
Фабричный Метод играет ключевую
роль в инкапсуляции этих сведений.
createPizza()
ChicagoPizzaStore
createPizza()
NYPizzaStore
createPizza()
orderPizza()
PizzaStore
NYStyleClamPizza
ChicagoStyleVeggiePizza
ChicagoStyleClamPizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
NYStylePepperoniPizza
NYStyleCheesePizza
NYStyleVeggiePizza
Классы-продукты Классы-создатели
создатели и продукты
паттерн фабрика
дальше   165
Головоломка
Нам нужна еще одна разновидность пиццы для этих безумных калифорнийцев («безумных» в хорошем смысле слова, конечно). Нарисуйте еще один параллельный набор 
классов, необходимых для поддержки нового региона — Калифорнии — в PizzaStore.
createPizza()
orderPizza()
PizzaStore
Теперь запишите пять самых странных ингредиентов для пиццы... И можете открывать бизнес по выпечке пиццы в Калифорнии! 
NYStyleCheesePizza
NYStyleVeggiePizza
NYStyleClamPizza
NYStylePepperoniPizza
ChicagoStyleVeggiePizza
ChicagoStyleClamPizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
createPizza()
ChicagoPizzaStore
createPizza()
NYPizzaStore
Рисуйте здесь...
166 глава 4
Определение паттерна Фабричный Метод
Паттерн Фабричный Метод определяет интерфейс создания 
объекта, но позволяет субклассам выбрать класс создаваемого экземпляра. Таким образом, Фабричный Метод делегирует 
операцию создания экземпляра субклассам.
Пора привести официальное определение паттерна Фабричный Метод:
Паттерн Фабричный Метод, как все остальные разновидности фабрик, предоставляет способ инкапсуляции создания экземпляров конкретных типов. Так, 
из приведенной ниже диаграммы классов видно, что абстрактный класс Creator 
предоставляет интерфейс к методу создания объектов, также называемому 
«фабричным методом». Остальные методы, реализуемые в абстрактном классе 
Creator, работают с продуктами, созданными фабричным методом. Только субклассы фактически реализуют фабричный метод и создают продукты.
Разработчики часто говорят: «Паттерн Фабричный Метод позволяет субклассам решить, экземпляры какого класса следует создавать». Так как класс Creator 
создается без информации о том, какие именно продукты он будет создавать, 
мы говорим «решить» не потому, что паттерн позволяет решать самим субклассам, а потому, что решение фактически сводится к тому, какой субкласс используется для создания продукта.
Product
ConcreteProduct
factoryMethod()
anOperation()
Creator
factoryMethod()
ConcreteCreator
Класс Creator содержит реализации всех методов, выполняющих операции с продуктами, кроме фабричного метода.
Класс ConcreteCreator 
реализует метод 
factoryMethod(), непосредственно производящий продукт.
Все продукты должны 
реализовать общий 
интерфейс, чтобы 
классы, использующие продукты, могли 
оперировать на уровне 
интерфейса, а не конкретных классов.
Класс ConcreteCreator отвечает за создание 
конкретных продуктов. Это единственный 
класс, который располагает информацией 
о создании этих продуктов.
Абстрактный метод 
factoryMethod() должен 
быть реализован всеми 
субклассами Creator.
Не верите — 
спросите сами... 
Но сейчас вы уже 
разбираетесь
в этой теме лучше, чем они!
определение фабричного метода
паттерн фабрика
дальше   167
В: Зачем использовать Фабричный Метод при 
одном классе ConcreteCreator?
О: Паттерн пригодится и в том случае, если в вашей иерархии всего один конкретный создатель, — он 
отделяет реализацию продукта от его использования. 
Если позднее добавятся другие продукты или изменится реализация продукта, это не отразится на работе класса-создателя. 
В: Правильно ли сказать, что в реализации пиццерий для Нью-Йорка и Чикаго из нашего примера 
применяется паттерн Простая Фабрика?
О: Они похожи, но используются по-разному. Хотя 
реализация каждой конкретной пиццерии имеет много 
общего с SimplePizzaFactory, помните, что конкретные 
пиццерии расширяют класс, в котором createPizza() 
определяется как абстрактный метод. Каждая пиццерия сама определяет поведение метода createPizza(). 
В паттерне Простая Фабрика фабрика представляет 
собой объект, объединяемый с PizzaStore посредством композиции. 
В: Фабричный Метод и класс-создатель всегда 
должны быть абстрактными?
О: Нет, Фабричный Метод по умолчанию может 
создавать некий конкретный продукт. Это позволит 
вам создавать продукты даже при отсутствии субклассов у класса-создателя.
В: Каждая пиццерия может выпускать до четырех видов пиццы в зависимости от полученного 
параметра. Все конкретные создатели обязательно 
производят несколько продуктов?
О: Мы реализовали параметризованный фабричный метод, который может производить разные 
объекты в зависимости от значения полученного параметра. Фабрика также может производить только 
один вид объектов; обе версии паттерна вполне допустимы.
В: Ваши параметризованные типы небезопасны. При вызове передается простая строка! 
А если вместо «ClamPizza» будет передана строка 
«CalmPizza»?
О: Безусловно, вы правы — произойдет ошибка 
времени выполнения. Существуют различные приемы, обеспечивающие возможность обнаружения 
ошибок на стадии компиляции, более «безопасные 
по отношению к типам», — иначе говоря, гарантирующие, что ошибки в параметрах могут перехватываться 
во время компиляции. Например, создание объектов, 
представляющих виды параметров, использование 
статических констант или перечислений.
В: Я плохо понимаю различия между Простой 
Фабрикой и Фабричным Методом. Они очень похожи, разве что в Фабричном Методе класс, возвращающий объекты, реализован в виде субкласса. 
Можете объяснить?
О: Субклассы действительно похожи на Простую 
Фабрику, но Простая Фабрика обладает узкой специализацией, а Фабричный Метод ведет к созданию 
инфраструктуры, в которой реализация выбирается 
субклассами. Например, метод orderPizza() в Фабричном Методе обеспечивает общую инфраструктуру 
для создания объектов. Субклассируя PizzaStore, вы 
выбираете состав пиццы, возвращаемой методом 
orderPizza(). Простая Фабрика инкапсулирует создание объектов, но она лишена гибкости Фабричного 
Метода в изменении создаваемых продуктов.
часто Задаваемые вопросы
168 глава 4
Гуру и ученик...
Гуру: Скажи, как идет твое обучение?
Ученик: Учитель, я продолжаю изучать тему «инкапсуляция переменных аспектов».
Гуру: Продолжай...
Ученик: Я узнал, что код создания объектов тоже можно 
инкапсулировать. Код, создающий экземпляры конкретных 
классов, подвержен частым изменениям. Я узнал о «фабриках», которые помогают инкапсулировать создание экземпляров.
Гуру: И какую пользу приносят эти «фабрики»?
Ученик: Большую, о Учитель. Размещение кода создания 
в одном объекте или методе позволяет избежать дублирования кода и упрощает сопровождение. Кроме того, клиент 
зависит только от интерфейсов, а не от конкретных классов, необходимых для создания объектов. Программирование 
на уровне интерфейса делает код более гибким и упрощает 
его возможное расширение.
Гуру: Воистину твои познания растут. Может, у тебя есть 
какие-нибудь вопросы?
Ученик: Учитель, я знаю, что инкапсуляция создания объектов улучшает степень абстракции и отделяет клиентский код от фактических реализаций. Но мой фабричный код 
все равно должен использовать конкретные классы. Нет ли 
в этом самообмана?
Гуру: Создание объектов — суровая действительность; без 
создания объектов не напишешь ни одной Java-программы. 
Но вооружившись этим знанием, мы изолируем код создания 
объектов — подобно тому, как мы изолируем овец в загоне, 
где о них можно заботиться и ухаживать. Если же разрешить овцам свободно бегать за оградой, мы никогда не сможем настричь с них шерсти.
Ученик: Учитель, я вижу в этом свет Истины.
Гуру: Я не сомневался. А теперь иди и медитируй на зависимостях между объектами.
гуру и ученик
паттерн фабрика
дальше   169
public class DependentPizzaStore {
 public Pizza createPizza(String style, String type) {
 Pizza pizza = null;
 if (style.equals("NY")) {
 if (type.equals("cheese")) {
 pizza = new NYStyleCheesePizza();
 } else if (type.equals("veggie")) {
 pizza = new NYStyleVeggiePizza();
 } else if (type.equals("clam")) {
 pizza = new NYStyleClamPizza();
 } else if (type.equals("pepperoni")) {
 pizza = new NYStylePepperoniPizza();
 }
 } else if (style.equals("Chicago")) {
 if (type.equals("cheese")) {
 pizza = new ChicagoStyleCheesePizza();
 } else if (type.equals("veggie")) {
 pizza = new ChicagoStyleVeggiePizza();
 } else if (type.equals("clam")) {
 pizza = new ChicagoStyleClamPizza();
 } else if (type.equals("pepperoni")) {
 pizza = new ChicagoStylePepperoniPizza();
 }
 } else {
 System.out.println("Error: invalid type of pizza");
 return null;
 }
 pizza.prepare();
 pizza.bake();
 pizza.cut();
 pizza.box();
 return pizza;
 }
}
Допустим, вы никогда не слыхали о фабриках в ОО-программировании. Ниже приведена «сильно зависимая» версия PizzaStore, которая не использует фабрику. Ваша задача — подсчитать количество конкретных классов пиццы, от которых зависит этот класс. 
Сколько будет таких классов, если вы добавите в эту реализацию PizzaStore разные виды 
пиццы в калифорнийском стиле?
Впишите 
свои ответы: число
с калифорнийской пиццей
Все пиццы 
в нью-йоркском 
стиле.
Все пиццы 
в чикагском 
стиле.
Возьми в руку карандаш
170 глава 4
Зависимости между объектами
При непосредственном создании экземпляра объекта возникает зависимость от его конкретного класса. Взгляните на реализацию PizzaStore 
с предыдущей страницы — все объекты пиццы создаются самим классом 
PizzaStore. 
Если нарисовать диаграмму, изображающую эту версию PizzaStore и все 
объекты, от которых она зависит, результат будет выглядеть примерно 
так:
PizzaStore
Если реализация одного из этих 
классов изменится, возможно, 
нам придется вносить изменения 
в PizzaStore. 
NYStyleVeggiePizza
NYStyleClamPizza
NYStylePepperoniPizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
ChicagoStyleVeggiePizza
ChicagoStyleClamPizza
NYStyleCheesePizza
Так как любые изменения в конкретных реализациях влияют 
на PizzaStore, мы говорим, что 
PizzaStore «зависит» от реализаций. 
Каждая новая разновидность пиццы создает 
новую зависимость для 
PizzaStore.
Эта версия PizzaStore 
зависит от всех субклассов, потому что 
она непосредственно 
создает их экземпляры.
зависимости между объектами
паттерн фабрика
дальше   171
Принцип проектирования
Код должен зависеть от абстракций, 
а не от конкретных классов.
На первый взгляд этот принцип сильно напоминает 
принцип «Программируйте на уровне интерфейсов, 
а не на уровне реализаций», верно? Да, они похожи; 
однако принцип инверсии зависимостей предъявляет еще более жесткие требования к абстракции. Он 
требует, чтобы высокоуровневые компоненты не зависели от низкоуровневых компонентов; вместо этого и те и другие должны зависеть от абстракций.
Но что это значит?
Давайте еще раз взглянем на диаграмму с предыдущей страницы. PizzaStore — наш «высокоуровневый» 
компонент, а реализации пицц — «низкоуровневые» 
компоненты. Очевидно, PizzaStore зависит от конкретных классов, представляющих виды пиццы.
Принцип указывает, что в своем коде мы должны зависеть от абстракций, а не от конкретных классов.
Это относится как к высокоуровневым, так и к низкоуровневым модулям.
Но как это сделать? Давайте подумаем, как применить этот принцип к сильно зависимой реализации 
PizzaStore...
Вполне очевидно, что сокращение зависимостей от 
конкретных классов — явление положительное. Более того, этот факт закреплен в одном из принципов 
ОО-проектирования с красивым впечатляющим названием принцип инверсии зависимостей.
Он формулируется так:
Принцип инверсии зависимостей
Еще одна фраза, которая 
наверняка произведет впечатление на начальство! 
«Высокоуровневым» компонентом называется класс, 
поведение которого определяется в контексте других, 
«низкоуровневых», компонентов. 
Например, PizzaStore является высокоуровневым 
компонентом, потому что 
он работает с разными 
объектами пиццы — готовит их, выпекает, нарезает 
и упаковывает. Объекты 
пиццы при этом являются 
низкоуровневыми компонентами.
172 глава 4
Применение принципа
Главный недостаток Сильно Зависимой версии PizzaStore заключается в том, что она зависит от всех классов пиццы из-за явного создания 
экземпляров конкретных типов в методе orderPizza(). 
Хотя мы и создали абстракцию Pizza, в коде кодируются конкретные 
типы пиццы, поэтому абстракция особой пользы не приносит. 
Как вынести создание экземпляров из метода orderPizza()? Для этого 
и нужен Фабричный Метод. 
После применения Фабричного Метода диаграмма выглядит так:
PizzaStore
Pizza
NYStyleVeggiePizza
NYStyleClamPizza
NYStylePepperoniPizza
NYStyleCheesePizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
ChicagoStyleVeggiePizza ChicagoStyleClamPizza
Конкретные классы пиццы 
тоже зависят от абстракции 
Pizza, потому что они реализуют интерфейс Pizza (в обобщенном смысле).
PizzaStore теперь зависит 
только от Pizza (абстрактный класс).
Нетрудно заметить, что после применения Фабричного Метода высокоуровневый компонент PizzaStore и низкоуровневые компоненты зависят 
от Pizza, то есть от абстракции. Фабричный Метод — не единственный, но 
один из самых мощных приемов, обеспечивающих соблюдение принципа 
инверсии зависимостей.
Pizza — абстрактный 
класс... Абстракция.
принцип инверсии зависимостей
паттерн фабрика
дальше   173
«Инверсия» в названии принципа объясняется тем, 
что этот принцип инвертирует традиционный подход 
к ОО-проектированию. Взгляните на диаграмму на предыдущей странице и обратите внимание на зависимость 
низкоуровневых компонентов от абстракции более высокого уровня. Высокоуровневый компонент тоже привязывается к той же абстракции. Таким образом, нисходящая диаграмма зависимостей, нарисованная нами пару 
страниц назад, инвертировалась — и высокоуровневые, 
и низкоуровневые модули теперь зависят от абстракции.
А теперь проанализируем типичный подход к процессу 
проектирования и посмотрим, как этот принцип влияет 
на мышление проектировщика...
Что именно инвертируется в принципе 
инверсии зависимостей?
С зависимостями 
понятно, но почему 
он называется принципом 
инверсии зависимостей?
174 глава 4
Верно, вы начинаете с верха иерархии и опускаетесь к конкретным классам. Но как мы 
уже знаем, пиццерия не должна располагать 
информацией о конкретных типах пиццы, 
потому что это создает зависимость от конкретных классов!
А теперь «инвертируем» направление мысли... Вместо того чтобы начинать сверху, 
начнем с разных конкретных видов пиццы и 
подумаем, что из них можно абстрагировать.
Верно! Мы приходим к абстракции Pizza. 
А теперь можно вернуться к проектированию PizzaStore.
Но для этого нам придется воспользоваться 
фабрикой, чтобы исключить конкретные 
классы из PizzaStore. После этого разные 
конкретные типы пиццы будут зависеть только от абстракции, как и класс пиццерии. Мы 
взяли архитектуру, в которой работа пиццерии зависит от конкретных классов, и инвертировали эти зависимости (вместе с направлением мышления).
Вы занимаетесь реализацией PizzaStore. Какая мысль первой приходит вам в голову?
Инверсия мышления...
инверсия подхода
Класс PizzaStore готовит, выпекает и упаковывает 
пиццу. Таким образом, мой класс 
должен уметь делать разные пиццы: 
CheesePizza, VeggiePizza, ClamPizza 
и т. д. ...
CheesePizza, 
VeggiePizza, ClamPizza — все 
это разновидности пиццы, поэтому они должны иметь общий 
интерфейс Pizza.
Теперь у меня есть абстракция Pizza, поэтому я могу 
проектировать пиццерию, не беспокоясь о конкретных классах 
пиццы.
паттерн фабрика
дальше   175
Несколько советов по применению принципа...
Вы абсолютно правы! Как и многие наши принципы, это всего лишь ориентир, 
к которому следует стремиться, а не железное правило, которое должно соблюдаться постоянно. Понятно, что эти рекомендации нарушаются в каждой Javaпрограмме!
Но если вы запомните эти рекомендации и будете постоянно помнить о них 
в ходе проектирования, вы будете знать, когда вы их нарушаете, имея на то веские причины. Например, если класс с большой вероятностью останется неизменным, в создании экземпляра конкретного класса не будет ничего страшного. 
В конце концов, мы постоянно создаем объекты String, не испытывая особых 
опасений. Является ли это нарушением принципа? Да. Допустимо ли это? Да. 
Почему? Потому, что вероятность изменения String ничтожно мала.
С другой стороны, если написанный вами класс с большой вероятностью будет 
изменяться, в вашем распоряжении хорошие способы инкапсуляции таких изменений, например Фабричный Метод.
Следующие рекомендации помогут вам избежать нарушения 
принципа инверсии зависимостей в своих архитектурах:
  Ссылки на конкретные классы не должны храниться 
в переменных.
  В архитектуре не должно быть классов, производных от конкретных классов.
  Ни один метод не должен переопределять реализованный метод любого из его базовых классов.
При использовании new сохраняется ссылка на конкретный класс. 
Используйте фабрику!
Наследование от конкретного класса 
создает зависимость от него. Определяйте классы производными от 
абстракций — интерфейсов или абстрактных классов.
Если вы переопределяете реализованный метод, значит, базовый класс был 
плохой абстракцией. Методы, реализованные в базовом классе, должны использоваться всеми субклассами.
Но разве эти 
рекомендации выполнимы? 
Если я буду следовать им, то 
не смогу написать ни одной 
программы!
176 глава 4
Основа
Соус
Сыр
Овощи
Архитектура PizzaStore постепенно формируется: Пеперони
мы создаем гибкую инфраструктуру, которая хорошо соответствует принципам проектирования. 
Ключом к успеху вашей пиццерии всегда были 
свежие, качественные ингредиенты. Однако вы 
обнаружили, что новые пиццерии следуют всем 
процедурам, но некоторые из них используют второсортные ингредиенты для снижения затрат и повышения прибыли. С этим надо что-то делать, потому 
что в долгосрочной перспективе такая «экономия» 
только повредит бренду!
Как обеспечить использование только качественных ингредиентов? Мы создадим фабрику, которая 
производит их и поставляет вашим пиццериям!
У этой идеи только один недостаток: пиццерии находятся в разных географических регионах, и то, 
что называется «томатным соусом» в Нью-Йорке, в Чикаго называется совершенно иначе. Таким образом, в Нью-Йорк будет поставляться один набор ингредиентов, а в Чикаго — совершенно другой. 
Давайте присмотримся:
Единые стандарты качества 
ингредиентов
Пицца с сыром
 Соус «маринара», реджиано, чеснок
Вегетарианская пицца
 Соус «маринара», реджиано, грибы,
 лук, красный перец
Пицца с мидиями
 Соус «маринара», реджиано, свежие мидии
Пицца Пеперони
 Соус «маринара», реджиано, грибы,
 лук, красный перец, пеперони
Нью-Йорк
Меню
Пицца с сыром
 Томатный соус, моцарелла, пармезан,
 орегано
Вегетарианская пицца
 Томатный соус, моцарелла, пармезан,
 баклажан, шпинат, оливки
Пицца с мидиями
 Томатный соус, моцарелла, пармезан, мидии
Пицца Пеперони
 Томатный соус, моцарелла, пармезан,
 баклажан, шпинат, оливки, пеперони
Чикаго
Меню Одни и те же наборы 
продуктов (основа, соус, сыр, овощи, 
мясо), но с разными 
реализациями в зависимости от региона.
Вернемся в пиццерию...
семейства ингредиентов
То есть выпечка, нарезка, 
упаковка и т. д.
паттерн фабрика
дальше   177
Семейства ингредиентов
В Нью-Йорке используется один набор ингредиентов, а в Чикаго — другой. Учитывая 
популярность вашей пиццы, вскоре придется составлять новый набор региональных 
ингредиентов для Калифорнии. Что потом — 
Остин?
Чтобы эта схема нормально функционировала, необходимо понять, как вы будете работать с семействами ингредиентов.
ReggianoCheese
ThinCrustDough
Calamari
FreshClams
MarinaraSauce
BruschettaSauce
GoatCheese
VeryThinCrust
Калифорния
FrozenClams
PlumTomatoSauce
MozzarellaCheese
ThickCrustDough
Нью-Йорк
Чикаго
Пиццы делаются из одних компонентов,
но в разных регионах используются
разные реализации этих компонентов.
Каждый регион реализует полное семейство ингредиентов.
Каждое семейство состоит из типа 
основы, типа соуса, типа сыра
и типа морепродуктов (а также 
других, которые мы не показываем, 
например овощей и специй).
178 глава 4
Построение фабрик ингредиентов
Мы собираемся построить фабрику для создания ингредиентов; фабрика будет нести ответственность за создание каждого ингредиента. Другими словами, фабрика будет создавать основу, соус, сыр и т. д. Вскоре вы увидите, как мы будем решать проблему региональных различий.
Начнем с определения интерфейса фабрики, которая будет создавать все наши ингредиенты:
public interface PizzaIngredientFactory {
 public Dough createDough();
 public Sauce createSauce();
 public Cheese createCheese();
 public Veggies[] createVeggies();
 public Pepperoni createPepperoni();
 public Clams createClam();
}
Для каждого ингредиента в интерфейсе определяется метод 
create. 
С этим интерфейсом мы собираемся сделать следующее:
Множество новых классов, по 
одному на каждый ингредиент.
1
2
3
Построить фабрику для каждого региона. Для этого мы создадим субкласс 
PizzaIngredientFactory, реализующий все методы create.
Реализовать набор классов ингредиентов, которые будут использоваться 
с фабрикой, — ReggianoCheese, RedPeppers, ThickCrustDough и т. д. Там, где 
это возможно, эти классы могут использоваться совместно несколькими регионами.
Затем все новые классы необходимо связать воедино. Для этого мы определим новые фабрики ингредиентов в коде PizzaStore.
фабрики ингредиентов
паттерн фабрика
дальше   179
Построение фабрики ингредиентов для Нью-Йорка
Перед вами реализация фабрики ингредиентов для НьюЙорка. Эта фабрика специализируется на соусе «маринара», сыре «реджиано» и свежих мидиях...
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
 public Dough createDough() {
 return new ThinCrustDough();
 }
 public Sauce createSauce() {
 return new MarinaraSauce();
 }
 public Cheese createCheese() {
 return new ReggianoCheese();
 }
 public Veggies[] createVeggies() {
 Veggies veggies[] = { new Garlic(), new Onion(), new Mushroom(), new RedPepper() };
 return veggies;
 }
 public Pepperoni createPepperoni() {
 return new SlicedPepperoni();
 }
 public Clams createClam() {
 return new FreshClams();
 }
}
Нью-Йоркская фабрика ингредиентов реализует общий 
интерфейс всех фабрик ингредиентов.
Для каждого ингредиента
в семействе создается
его версия для Нью-Йорка.
Содержимое массива жестко фиксировано. Возможны
и менее тривиальные решения, но они не имеют отношения к изучению паттерна, поэтому был выбран 
простой вариант.
Нарезанные пеперони 
используются и в НьюЙорке, и в Чикаго. Нью-Йорк находится на 
побережье; в нем используются свежие мидии. 
Чикаго придется довольствоваться морожеными.
180 глава 4
Напишите Фабрику ингредиентов ChicagoPizzaIngredientFactory. Используйте в своей реализации классы, 
приведенные ниже.
SlicedPepperoni
EggPlant
Spinach
BlackOlives
FrozenClams
PlumTomatoSauce
MozzarellaCheese
ThickCrustDough
построение фабрики
Возьми в руку карандаш
паттерн фабрика
дальше   181
Перерабатываем классы пиццы...
Все наши фабрики запущены и готовы к выпуску качественных ингредиентов; осталось переработать классы пиццы, чтобы они использовали только 
ингредиенты, произведенные фабриками. Начнем с абстрактного класса 
Pizza:
public abstract class Pizza {
 String name;
 Dough dough;
 Sauce sauce;
 Veggies veggies[];
 Cheese cheese;
 Pepperoni pepperoni;
 Clams clam;
 abstract void prepare();
 void bake() {
 System.out.println("Bake for 25 minutes at 350");
 }
 void cut() {
 System.out.println("Cutting the pizza into diagonal slices");
 }
 void box() {
 System.out.println("Place pizza in official PizzaStore box");
 }
 void setName(String name) {
 this.name = name;
 }
 String getName() {
 return name;
 }
 public String toString() {
 // Код вывода описания пиццы
 }
}
Каждый объект пиццы содержит набор ингредиентов, используемых при 
ее приготовлении.
Другие методы остаются неизменными (кроме prepare).
Метод prepare стал абстрактным. 
В нем мы будем собирать ингредиенты, необходимые для приготовления 
пиццы. Которые, разумеется, будут 
производиться фабрикой ингредиентов.
182 глава 4
Переработка классов пиццы продолжается...
public class CheesePizza extends Pizza {
 PizzaIngredientFactory ingredientFactory;
 public CheesePizza(PizzaIngredientFactory ingredientFactory) {
 this.ingredientFactory = ingredientFactory;
 }
 void prepare() {
 System.out.println("Preparing " + name);
 dough = ingredientFactory.createDough();
 sauce = ingredientFactory.createSauce();
 cheese = ingredientFactory.createCheese();
 }
}
Теперь, когда у нас имеется абстрактный класс Pizza, можно переходить к созданию классов нью-йоркской и чикагской пиццы — 
только на этот раз они будут получать свои ингредиенты прямо 
с фабрики. Времена, когда пиццерии могли экономить на качестве, прошли!
При написании кода Фабричного Метода у нас были классы 
NYCheesePizza и ChicagoCheesePizza. Присмотревшись к этим 
классам, мы видим, что они различаются только использованием 
региональных ингредиентов, а сама пицца остается неизменной 
(основа + соус + сыр). То же относится и к другим пиццам: вегетарианской, с мидиями и т. д. Все они готовятся по единой схеме, но 
с разными ингредиентами.
Итак, на самом деле нам не нужны два класса для каждой пиццы; 
фабрика ингредиентов справится с региональными различиями 
за нас. Например, класс пиццы с сыром выглядит так: В ходе приготовления пиццы 
нам понадобится фабрика, 
поставляющая ингредиенты. 
Соответственно, конструктору каждого класса 
пиццы передается объект 
фабрики, ссылка на который 
сохраняется в переменной 
экземпляра.
Самое главное!
Метод prepare() готовит пиццу 
с сыром. Когда ему требуется очередной ингредиент, он запрашивает 
его у фабрики.
отделение ингредиентов
паттерн фабрика
дальше   183
Код Pizza использует фабрику для производства ингредиентов, используемых в пицце. Производимые ингредиенты определяются фабрикой. Для класса Pizza различия 
несущественны; он умеет готовить пиццу из обобщенных ингредиентов. Он изолирован от различий в региональных ингредиентах, и мы можем легко использовать 
его с фабриками для любых других регионов.
sauce = ingredientFactory.createSauce();
В переменной 
экземпляра сохраняется ссылка на 
конкретный соус 
данной пиццы.
Метод createSauce() возвращает 
соус, используемый в данном регионе. 
Скажем, для Нью-Йорка это будет 
соус «маринара».
Класс Pizza может использовать любую фабрику ингредиентов.
Также рассмотрим класс ClamPizza:
public class ClamPizza extends Pizza {
 PizzaIngredientFactory ingredientFactory;
 public ClamPizza(PizzaIngredientFactory ingredientFactory) {
 this.ingredientFactory = ingredientFactory;
 }
 void prepare() {
 System.out.println("Preparing " + name);
 dough = ingredientFactory.createDough();
 sauce = ingredientFactory.createSauce();
 cheese = ingredientFactory.createCheese();
 clam = ingredientFactory.createClam();
 }
}
ClamPizza тоже сохраняет фабрику ингредиентов.
Чтобы создать пиццу 
с мидиями, метод prepare 
получает ингредиенты от 
локальной фабрики.
Если это нью-йоркская фабрика, мидии будут свежие, 
а если чикагская — мороженые.
Код под увеличительным стеклом
184 глава 4
Возвращаемся к пиццериям
Работа почти закончена; остается вернуться к классам пиццерий 
и позаботиться о том, чтобы они использовали правильные объекты Pizza. Также необходимо передать им ссылку на региональную 
фабрику ингредиентов:
Сравните новую версию метода createPizza() 
с версией из реализации Фабричного Метода, 
приведенной ранее в этой главе.
public class NYPizzaStore extends PizzaStore {
 protected Pizza createPizza(String item) {
 Pizza pizza = null;
 PizzaIngredientFactory ingredientFactory = 
 new NYPizzaIngredientFactory();
 if (item.equals("cheese")) {
 
 pizza = new CheesePizza(ingredientFactory);
 pizza.setName("New York Style Cheese Pizza");
 
 } else if (item.equals("veggie")) {
 pizza = new VeggiePizza(ingredientFactory);
 pizza.setName("New York Style Veggie Pizza");
 } else if (item.equals("clam")) {
 pizza = new ClamPizza(ingredientFactory);
 pizza.setName("New York Style Clam Pizza");
 } else if (item.equals("pepperoni")) {
 pizza = new PepperoniPizza(ingredientFactory);
 pizza.setName("New York Style Pepperoni Pizza");
 } 
 return pizza;
 }
}
Фабрика производит ингредиенты для всех пицц в ньюйоркском стиле.
Теперь при создании каждой 
пиццы задается фабрика, которая должна использоваться 
для производства ее ингредиентов.
Вернитесь к предыдущей странице и обязательно разберитесь 
в том, как взаимодействуют 
классы пиццы и фабрики!
Для каждого вида пиццы мы 
создаем новый экземпляр Pizza 
и передаем ему фабрику, необходимую для производства 
ингредиентов.
использование правильной фабрики ингредиентов
Мозговой
штурм
паттерн фабрика
дальше   185
Чего мы добились?
Мы внесли в программный код серию последовательных изменений; 
чего именно мы добились? 
Мы реализовали механизм создания семейств ингредиентов для 
пиццы; для этого был введен новый тип фабрики, называемый Абстрактной Фабрикой.
Абстрактная Фабрика определяет интерфейс создания семейства 
продуктов. Использование этого 
интерфейса отделяет код от фабрики, создающей продукты. Таким 
образом создаются разнообразные 
фабрики, производящие продукты 
для разных контекстов: разных регионов, операционных систем или 
вариантов оформления.
Отделение кода от фактически используемых продуктов позволяет 
динамически переключать фабрики для изменения поведения (например, замены томатного соуса 
соусом «маринара»).
Абстрактная Фабрика определяет интерфейс для семейства продуктов. Что такое «семейство»? В нашем примере это 
ингредиенты для приготовления пиццы: 
основа, соус, сыр и т. д.
На основе Абстрактной Фабрики 
создается одна или несколько конкретных фабрик, производящих одинаковые продукты, но с  разными реализациями.
Абстрактная Фабрика ингредиентов
Нью-Йорк Чикаго
Определяет 
интерфейс.
Затем мы пишем свой код так, чтобы 
для создания продуктов в нем использовались фабрики. Передавая разные 
фабрики, мы получаем разные реализации продуктов, но клиентский код 
при этом остается неизменным.
PizzaStore
Предоставляет 
реализации для 
продуктов.
Пицца из ингредиентов, произведенных 
конкретной фабрикой.
186 глава 4
Итан и Джоэл требуют продолжения...
Итан и Джоэл в восторге от пиццы из Объектвиля! Но им и невдомек, 
что при выполнении их заказов используются новые фабрики ингредиентов. Вот что происходит, когда они делают заказ...
Первая стадия обработки заказа не изменилась. Давайте 
еще раз проследим за выполнением заказа Итана:
2
3
nyPizzaStore
createPizza("cheese")
PizzaStore nyPizzaStore = new NYPizzaStore();
Сначала создается объект NYPizzaStore:
nyPizzaStore.orderPizza("cheese");
Пиццерия построена, можно принимать заказ:
Метод orderPizza() сначала вызывает метод 
createPizza():
Pizza pizza = createPizza("cheese");
Создание экземпляра 
NYPizzaStore.
Метод orderPizza() вызывается экземпляром 
nyPizzaStore.
снова заказываем пиццу
За сценой
1
(См. следующую страницу.)
Я снова возьму
нью-йоркскую.
А я — чикагскую.
паттерн фабрика
дальше   187
Дальше процедура изменяется, потому что мы используем 
фабрику ингредиентов.
Pizza pizza = new CheesePizza(nyIngredientFactory);
Вызывается метод createPizza(). Именно здесь вступает 
в дело наша фабрика ингредиентов:
Теперь пиццу необходимо приготовить. При вызове 
метода prepare() фабрика получает запрос на производство ингредиентов:
Пицца подготовлена. Метод orderPizza() выпекает, нарезает 
и упаковывает ее.
Создает экземпляр 
Pizza, содержащий 
фабрику ингредиентов для Нью-Йорка.
Pizza
prepare()
nyIngredientFactory
содержит
Для пиццы Итана используется нью-йоркская фабрика 
ингредиентов.
 void prepare() {
 dough = factory.createDough();
 sauce = factory.createSauce();
 cheese = factory.createCheese();
 }
Тонкая основа
Маринара
Реджиано
Фабрика ингредиентов выбирается 
и создается в PizzaStore, а затем 
передается конструктору каждой 
пиццы.
4
5
6
За сценой
188 глава 4
Определение паттерна Абстрактная Фабрика
Паттерн Абстрактная Фабрика предоставляет интерфейс 
создания семейств взаимосвязанных или взаимозависимых 
объектов без указания их конкретных классов.
В нашу коллекцию паттернов добавляется очередной фабричный паттерн, предназначенный для создания семейств продуктов. Давайте обратимся к официальному определению этого паттерна:
Как было показано ранее, благодаря паттерну Абстрактная Фабрика клиент может использовать абстрактный интерфейс для создания логически связанных продуктов, не располагая информацией 
о конкретных создаваемых продуктах. Таким образом, клиент отделяется от подробностей конкретного продукта. Следующая диаграмма классов показывает, как работает эта схема:
CreateProductA()
CreateProductB()
<<interface>>
AbstractFactory
Клиент
ProductB1
<<interface>>
AbstractProductB
ProductA1
ProductB2
<<interface>>
AbstractProductA
ProductA2
CreateProductA()
CreateProductB()
ConcreteFactory2
CreateProductA()
CreateProductB()
ConcreteFactory1
Код клиента пишется для Абстрактной Фабрики, 
а затем во время выполнения связывается с реальной фабрикой.
Конкретные фабрики реализуют 
разные семейства продуктов. Чтобы создать продукт, клиент использует одну из фабрик, то есть 
ему никогда не приходится явно 
создавать экземпляры продуктов.
AbstractFactory определяет интерфейс, который реализуется всеми 
конкретными фабриками. Интерфейс состоит из методов создания 
продуктов.
Семейство продуктов. 
Каждая конкретная
фабрика может
производить полный
набор продуктов.
определение абстрактной фабрики
паттерн фабрика
дальше   189
<<interface>>
Clams
<<interface>>
Cheese
<<interface>>
Sauce
<<interface>>
Dough
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
ChicagoPizzaIngredientFactory
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
NYPizzaIngredientFactory
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
<<interface>>
PizzaIngredientFactory
createPizza()
NYPizzaStore
Каждая фабрика предоставляет 
свою реализацию для семейства 
продуктов.
Абстрактный интерфейс 
PizzaIngredientFactory определяет 
способ создания семейства логически связанных продуктов — всего, 
что необходимо для изготовления 
пиццы.
Клиенты Абстрактной 
фабрики — два экземпляра PizzaStore, NyPizzaStore 
и ChicagoStylePizzaStore. 
Задача конкретных 
фабрик — создавать 
ингредиенты для пиццы. Каждая фабрика 
умеет создавать правильные объекты для 
своего региона.
Диаграмма классов получилась довольно сложной. Давайте рассмотрим ее 
в контексте иерархии PizzaStore:
ThickCrustDough ThinCrustDough
PlumTomatoSauce MarinaraSauce
Mozzarella Cheese ReggianoCheese
FrozenClams FreshClams
190 глава 4
HeadFirst: Ого, интервью с двумя паттернами сразу! Такое у нас впервые.
Фабричный Метод: Да, хотя я не уверен, что мне нравится, когда меня смешивают 
с Абстрактной Фабрикой. Да, мы оба являемся фабричными паттернами, но это не значит, что мы не заслужили отдельных интервью.
HeadFirst: Не переживайте, мы хотели побеседовать с вами одновременно, чтобы наши 
читатели раз и навсегда поняли, кто есть кто. Между вами существует некоторое сходство, 
и люди вас иногда путают.
Абстрактная Фабрика: Да, это правда. Мы оба предназначены для отделения приложений от конкретики реализаций, но делаем это по-разному. Так что я могу понять, почему нас путают.
Фабричный Метод: И все равно меня это раздражает. В конце концов, для создания 
я использую классы, а Абстрактная Фабрика — объекты. Ничего общего!
Интервью недели:
Фабричный Метод и Абстрактная Фабрика друг о друге
Хорошее наблюдение! Да, методы Абстрактной Фабрики часто реализуются как фабричные методы. И это вполне логично, не правда ли? 
Задача Абстрактной Фабрики — определить интерфейс для создания набора продуктов. Каждый метод этого интерфейса отвечает за создание 
конкретного продукта, и мы реализуем субкласс Абстрактной Фабрики, 
который предоставляет эти реализации. Таким образом, фабричные методы являются естественным способом реализации методов продуктов 
в абстрактных фабриках.
В Абстрактной Фабрике прячется Фабричный Метод?
интервью с фабричными паттернами
Паттерны
	 для всех
Я заметил, что каждый метод
Абстрактной Фабрики напоминает Фабричный Метод (createDough(), 
createSauce() и т. д.). Каждый метод 
объявляется абстрактным и переопределяется субклассами. Разве это не Фабричный Метод?
паттерн фабрика
дальше   191
HeadFirst: А можно чуть подробнее?
Фабричный Метод: Конечно. И я, и Абстрактная Фабрика создаем объекты — это наша работа. 
Но я использую наследование...
Абстрактная Фабрика: ...а я — композицию.
Фабричный Метод: Точно. Значит, для создания объектов фабричным методом необходимо 
расширить класс и переопределить фабричный 
метод.
HeadFirst: И что делает этот фабричный метод? 
Фабричный Метод: Создает объекты конечно! 
То есть вся суть паттерна Фабричный Метод заключается в использовании субкласса, который 
создает объекты за вас. Клиенту достаточно знать 
абстрактный тип, который они используют, а субкласс имеет дело с конкретными типами. Другими словами, я отделяю клиентов от конкретных 
типов.
Абстрактная Фабрика: И я тоже, но по-другому.
HeadFirst: Слушаем Абстрактную Фабрику... Вы 
что-то говорили о композиции?
Абстрактная Фабрика: Я предоставляю абстрактный тип для создания семейств продуктов. 
Субклассы этого типа определяют способ создания продуктов. Чтобы использовать фабрику, вы 
создаете экземпляр и передаете его коду, написанному для абстрактного типа. Таким образом, 
как и с Фабричным Методом, мои клиенты отделяются от конкретных продуктов.
HeadFirst: Выходит, другое преимущество заключается в группировке связанных продуктов.
Абстрактная Фабрика: Вот именно.
HeadFirst: А что происходит при расширении 
набора этих продуктов — скажем, при добавлении? Разве оно не требует изменения интерфейса?
Абстрактная Фабрика: Верно, мой интерфейс изменяется при добавлении новых продуктов, но...
Фабричный Метод: (презрительно фыркает)
Абстрактная Фабрика: Как это понимать?
Фабричный Метод: Да ладно, это серьезная 
проблема! При изменении интерфейса приходится изменять интерфейс каждого субкласса!
Абстрактная Фабрика: Да, но меня используют для создания целых семейств продуктов, поэтому мне нужен большой интерфейс. Ты создаешь только один продукт, поэтому тебе хватает 
одного метода.
HeadFirst: Говорят, вы часто используете фабричные методы для реализации конкретных фабрик?
Абстрактная Фабрика: Да, не отрицаю, мои 
конкретные фабрики часто реализуют фабричный метод для создания своих продуктов. В моем 
случае они используются только для создания 
продуктов...
Фабричный Метод: ...а я обычно реализую 
в абстрактном создателе код, который использует конкретные типы, созданные субклассами.
HeadFirst: Похоже, вы оба отлично справляетесь со своим делом. Вы оба инкапсулируете создание объектов, чтобы обеспечить слабую связанность приложений и снизить зависимость от 
реализаций, а это всегда хорошо, независимо от 
выбора паттерна. Пара слов на прощание?
Абстрактная Фабрика: Спасибо. Используйте 
меня при создании семейств продуктов, когда вы 
должны обеспечить логическую согласованность 
создаваемых объектов.
Фабричный Метод: А я буду полезен для отделения клиентского кода от создания экземпляров 
конкретных классов и в тех ситуациях, когда точный состав всех конкретных классов неизвестен 
заранее. Субклассируйте меня и реализуйте мой 
фабричный метод!
192 глава 4
createPizza()
ChicagoPizzaStore
createPizza()
NYPizzaStore
createPizza()
PizzaStore
NYStyleVeggiePizza
NYStyleClamPizza
NYStylePepperoniPizza
NYStyleCheesePizza
Pizza
ChicagoStyleVeggiePizza
ChicagoStyleClamPizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
Сравнение паттернов Фабричный Метод и Абстрактная Фабрика
Нью-Йорк
В реализации PizzaStore используется Фабричный Метод, потому 
что мы собираемся создавать продукты, изменяющиеся в зависимости от региона. Каждый регион 
получает свою конкретную фабрику, которая умеет производить 
пиццы для этого региона.
Каждый субкласс решает, 
какой конкретный класс 
обрабатывать.
Фабричный Метод
Продукт PizzaStore. Код 
клиентов зависит
только от этого абстрактного типа.
Экземпляры субклассов создаются 
Фабричными
Методами.
Нью-Йорк Чикаго
Фабричный Метод
Субкласс NYPizzaStore создает 
пиццы только в нью-йоркском 
стиле.
Субкласс ChicagoPizzaStore 
создает пиццы только в чикагском стиле.
Чикаго
Метод createPizza() параметризуется 
по типу пиццы, чтобы мы могли возвращать 
разные типы продуктов.
Предоставляет абстрактный 
интерфейс для создания
одного продукта.
сравнение паттернов
паттерн фабрика
дальше   193
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
<<interface>>
PizzaIngredientFactory
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
NYPizzaIngredientFactory
createDough()
createSauce()
createCheese()
createVeggies()
createPepperoni()
createClam()
ChicagoPizzaIngredientFactory
PizzaIngredientFactory реализуется как 
Абстрактная Фабрика, потому что 
он должен создавать семейства продуктов (ингредиенты).
FreshClams FrozenClams
<<interface>>
Clams
<<interface>>
Sauce
<<interface>>
Dough
ReggianoCheese Mozzarella Cheese
<<interface>>
Cheese
Каждый конкретный субкласс 
создает семейство продуктов.
ThinCrustDough ThickCrustDough
MarinaraSauce PlumTomatoSauce
Чикаго
Предоставляет абстрактный интерфейс для создания 
семейства продуктов.
Методы создания продуктов в Абстрактной Фабрике часто реализуются 
с использованием паттерна Фабричный Метод...
...или тип мидий.
Нью-Йорк
Каждый ингредиент — продукт, 
производимый Фабричным Методом 
в Абстрактной 
Фабрике.
...например, субкласс определяет 
тип основы...
Субклассы продуктов образуют параллельные наборы семейств.
В данном примере это семейства ингредиентов для Нью-Йорка и Чикаго.
194 глава 4
Стратегия — определяет 
семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет модифицировать алгоритмы незави
Новые инструменты
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты 
для расширения, но закрыты для 
изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Принципы
Паттерны
  Все фабрики инкапсулируют 
создание объектов.
  Простая Фабрика, хотя и не 
является полноценным 
паттерном, обеспечивает 
простой механизм изоляции 
клиентов от конкретных классов.
  Фабричный Метод основан 
на наследовании: создание 
объектов делегируется 
субклассам, реализующим 
Фабричный Метод для создания объектов.
  Абстрактная Фабрика основана на композиции: создание 
объектов реализуется в 
методе, доступ к которому 
осуществляется через интерфейс фабрики.
  Все фабричные паттерны 
обеспечивают слабую связанность за счет сокращения 
зависимости приложения от 
конкретных классов.
  Задача Фабричного Метода — перемещение создания 
экземпляров в субклассы.
  Задача Абстрактной Фабрики — создание семейств 
взаимосвязанных объектов 
без зависимости от их конкретных классов.
По возможности
используйте абстракции в своем коде.
Оба новых паттерна инкапсулируют 
создание объектов, 
обеспечивая слабую 
связанность и гибкость архитектур.
инструментарий проектирования
В этой главе в вашем ОО-инструментарии появились два новых инструмента: Фабричный Метод 
и Абстрактная Фабрика. Оба паттерна инкапсулируют создание объектов и помогают изолировать код 
от операций с конкретными типами.
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Наблюдатель — определяет отношение «один-комногим» между объектами 
таким образом, что при изменении состояния одного объекта 
происходит автоматическое
Декоратор — динамически наделяет объект 
новыми возможностями, и 
является гибкой альтернативой субклассированию в области расширения 
функциональности.
Абстрактная Фабрика
предоставляет интерфейс для создания семейств 
взаимосвязанных объектов 
без указания их конкретных 
классов.
Фабричный Метод определяет интерфейс создания объекта, но позволяет субклассам выбрать 
создаваемый экземпляр.
паттерн фабрика
дальше   195
Класс NYPizzaStore уже готов; еще два класса, и бизнес можно будет запускать! 
Запишите в этой врезке реализации PizzaStore для Чикаго и Калифорнии:
public class ChicagoPizzaStore extends PizzaStore {
 protected Pizza createPizza(String item) {
 if (item.equals("cheese")) {
 return new ChicagoStyleCheesePizza();
 } else if (item.equals("veggie")) {
 return new ChicagoStyleVeggiePizza();
 } else if (item.equals("clam")) {
 return new ChicagoStyleClamPizza();
 } else if (item.equals("pepperoni")) {
 return new ChicagoStylePepperoniPizza();
 } else return null;
 }
}
public class CaliforniaPizzaStore extends PizzaStore {
 protected Pizza createPizza(String item) {
 if (item.equals("cheese")) {
 return new CaliforniaStyleCheesePizza();
 } else if (item.equals("veggie")) {
 return new CaliforniaStyleVeggiePizza();
 } else if (item.equals("clam")) {
 return new CaliforniaStyleClamPizza();
 } else if (item.equals("pepperoni")) {
 return new CaliforniaStylePepperoniPizza();
 } else return null;
 }
}
Для чикагской пиццерии необходимо 
создавать пиццу 
в чикагском стиле...
...а для калифорнийской — пиццу в калифорнийском стиле.
Обе пиццерии почти не отличаются от ньюйоркской... Просто они создают другие виды 
пиццы.
Возьми в руку карандаш
 Решение
196 глава 4
решение упражнений
Решение головоломки
createPizza()
orderPizza()
PizzaStore
createPizza()
NYPizzaStore
createPizza()
ChicagoPizzaStore
NYStyleVeggiePizza
NYStyleClamPizza
NYStylePepperoniPizza
NYStyleCheesePizza
ChicagoStyleVeggiePizza
ChicagoStyleClamPizza
ChicagoStylePepperoniPizza
ChicagoStyleCheesePizza
createPizza()
CaliforniaPizzaStore
CaliforniaStyleVeggiePizza
CaliforniaStyleClamPizza
CaliforniaStylePepperoniPizza
CaliforniaStyleCheesePizza
Класс калифорнийской 
пиццерии и конкретные 
классы пиццы.
Картофельное пюре с жареным чесноком
Соус «барбекю»
Артишоки
M&M’s
Арахис
Наши предложения...
Нам нужна еще одна разновидность пиццы для этих безумных калифорнийцев («безумных» 
в хорошем смысле слова, конечно). Нарисуйте еще один параллельный набор классов, необходимых для поддержки нового региона — Калифорнии — в PizzaStore.
Теперь запишите пять самых странных ингредиентов для пиццы... И можете открывать бизнес по выпечке пиццы в Калифорнии! 
паттерн фабрика
дальше   197
public class DependentPizzaStore {
 public Pizza createPizza(String style, String type) {
 Pizza pizza = null;
 if (style.equals("NY")) {
 if (type.equals("cheese")) {
 pizza = new NYStyleCheesePizza();
 } else if (type.equals("veggie")) {
 pizza = new NYStyleVeggiePizza();
 } else if (type.equals("clam")) {
 pizza = new NYStyleClamPizza();
 } else if (type.equals("pepperoni")) {
 pizza = new NYStylePepperoniPizza();
 }
 } else if (style.equals("Chicago")) {
 if (type.equals("cheese")) {
 pizza = new ChicagoStyleCheesePizza();
 } else if (type.equals("veggie")) {
 pizza = new ChicagoStyleVeggiePizza();
 } else if (type.equals("clam")) {
 pizza = new ChicagoStyleClamPizza();
 } else if (type.equals("pepperoni")) {
 pizza = new ChicagoStylePepperoniPizza();
 }
 } else {
 System.out.println("Error: invalid type of pizza");
 return null;
 }
 pizza.prepare();
 pizza.bake();
 pizza.cut();
 pizza.box();
 return pizza;
 }
}
Впишите свои 
ответы: число
с калифорнийской 
пиццей.
Обработка всех 
видов нью-йоркской 
пиццы.
Обработка всех 
видов чикагской 
пиццы.
8 12
Допустим, вы никогда не слышали о фабриках в ОО-программировании. Ниже 
приведена «сильно зависимая» версия PizzaStore, которая не использует фабрику. Ваша задача — подсчитать количество конкретных классов пиццы, от 
которых зависит этот класс. Сколько будет таких классов, если вы добавите в 
эту реализацию PizzaStore разные виды пиццы в калифорнийском стиле?
Возьми в руку карандаш
 Решение
198 глава 4
решение упражнений
SlicedPepperoni
EggPlant
Spinach
BlackOlives
FrozenClams
PlumTomatoSauce
MozzarellaCheese
ThickCrustDough
public class ChicagoPizzaIngredientFactory 
 implements PizzaIngredientFactory 
{
 public Dough createDough() {
 return new ThickCrustDough();
 }
 public Sauce createSauce() {
 return new PlumTomatoSauce();
 }
 public Cheese createCheese() {
 return new MozzarellaCheese();
 }
 public Veggies[] createVeggies() {
 Veggies veggies[] = { new BlackOlives(), 
 new Spinach(), 
 new Eggplant() };
 return veggies;
 }
 public Pepperoni createPepperoni() {
 return new SlicedPepperoni();
 }
 public Clams createClam() {
 return new FrozenClams();
 }
}
Напишите фабрику ингредиентов ChicagoPizzaIngredientFactory. 
Используйте в своей реализации классы, приведенные ниже:
Возьми в руку карандаш
 Решение
Паттерн Одиночка направлен на создание уникальных объектов, 
существующих только в одном экземпляре. Из всех паттернов Одиночка имеет самую простую диаграмму классов; собственно, вся диаграмма состоит из одного-единственного класса! Но не стоит расслабляться: несмотря на 
простоту с точки зрения структуры классов, его реализация требует довольно 
серьезных объектно-ориентированных размышлений. Приготовьтесь пошевелить мозгами — и за дело!
5 Паттерн Одиночка
Уникальные объекты
Говорю тебе, 
другой такой НЕТ 
В ПРИРОДЕ. Посмотри на 
эти линии, на эти изгибы!
Ты с кем говоришь — со 
мной или с машиной? И когда 
отдашь мое кухонное полотенце?
200 глава 5
Программист: И в чем польза такого паттерна?
Гуру: Существует много объектов, которые нужны нам только в одном экземпляре: пулы программных 
потоков, кэши, диалоговые окна, объекты ведения журнала, объекты драйверов устройств... Более того, 
для многих типов таких объектов попытка создания более одного экземпляра приведет к всевозможным проблемам — некорректному поведению программы, лишним затратам ресурсов или нелогичным 
результатам.
Программист: Хорошо, некоторые классы действительно должны создаваться только в одном экземпляре. 
Но писать об этом целую главу? Разве нельзя, например, воспользоваться глобальной переменной? А в Java 
можно было добиться желаемого с помощью статической переменной.
Гуру: Паттерн Одиночка во многих отношениях представляет собой схему, которая гарантирует, что для заданного класса может быть создан один и только один объект. Если кто-нибудь придумает более удачное решение, мир о нем услышит, а пока паттерн Одиночка, как и все паттерны, представляет собой проверенный 
временем механизм создания единственного объекта. Кроме того, Одиночка, как и глобальная переменная, 
предоставляет глобальную точку доступа к данным, но без ее недостатков.
Программист: Каких недостатков?
Гуру: Простейший пример: если объект присваивается глобальной переменной, он может быть создан в начале работы приложения. Верно? А если этот объект расходует много ресурсов, но никогда не будет использоваться приложением? Как вы увидите, паттерн Одиночка позволяет создавать объекты в тот момент, когда 
в них появится необходимость.
Программист: И все равно не вижу ничего особенно сложного.
Гуру: Для того, кто хорошо разбирается в статических переменных и методах, а также модификаторах доступа, ничего сложного нет. Но как бы то ни было, интересно посмотреть, как работает паттерн Одиночка, 
и при всей простоте его довольно непросто реализовать. Как бы вы предотвратили создание повторных 
экземпляров? Задача отнюдь не тривиальная, не правда ли?
единственный и неповторимый
Что? Целая глава 
о том, как создать всего 
ОДИН ОБЪЕКТ?!
Один и ТОЛЬКО 
ОДИН объект.
паттерн одиночка
дальше   201
Как создать один объект? new MyObject();
А если другой объект захочет создать еще 
один экземпляр MyObject? Сможет ли он снова вызвать new для MyObject?
Да, конечно.
Значит, если у нас есть класс, мы всегда можем создать один или несколько экземпляров этого класса?
Да. Но только если это открытый класс.
А если нет? А если это не открытый класс, то его экземпляры могут создаваться только классами того 
же пакета. Но они все равно могут создать несколько экземпляров.
Хм-м, интересно. 
А вы знаете, что можно сделать так?
Нет, никогда не задумывался. Но такое определение выглядит разумно и ничего не нарушает.
public MyClass {
 private MyClass() {}
}
И что это значит? Вероятно, это класс, экземпляры которого не 
могут создаваться, потому что конструктор 
объявлен приватным.
Хоть КАКОЙ-НИБУДЬ объект может вызывать приватный конструктор?
Хм-м, он может вызываться только из кода 
MyClass. Но какая от этого польза?
Вопросы и ответы
Маленькое упражнение в стиле сократовских диалогов
202 глава 5
Почему? Потому что для вызова нужно иметь экземпляр класса, а я не могу создать экземпляр, 
потому что он не может быть создан другим 
классом. Классическая проблема «курицы 
и яйца».
Понятно.
А что можно сказать об этом фрагменте?
Класс MyClass содержит статический метод, 
который можно вызвать так:
MyClass.getInstance();
public MyClass {
 public static MyClass getInstance() {
 }
}
Почему вместо имени объекта используется MyClass?
Метод getInstance() является статическим, 
то есть методом КЛАССА. При вызове статического метода необходимо указывать имя 
класса.
Очень интересно.
public MyClass {
 private MyClass() {}
 public static MyClass getInstance() {
 return new MyClass();
 }
}
Безусловно.
А теперь я могу создать экземпляр MyClass?
Как должны создаваться экземпляры в клиентском коде?
MyClass.getInstance();
Можете ли вы дописать код, чтобы он всегда создавал не более ОДНОГО экземпляра 
MyClass?
Да, пожалуй...
(Ответ на следующей странице.)
создание одиночки
паттерн одиночка
дальше   203
Код под увеличительным стеклом
Классическая реализация паттерна Одиночка
public class Singleton {
 private static Singleton uniqueInstance;
 // Другие письменные экземпляры
 private Singleton() {}
 public static Singleton getInstance() {
 if (uniqueInstance == null) {
 uniqueInstance = new Singleton();
 }
 return uniqueInstance;
 }
 // Другие методы
}
Статическая переменная для хранения 
единственного экземпляра.
Приватный конструктор; только Singleton 
может создавать 
экземпляры этого 
класса!
Метод 
getInstance() создает и возвращает экземпляр.
Как и всякий другой класс, 
Singleton содержит другие 
переменные и методы эк
земпляров.
-
if (uniqueInstance == null) {
 uniqueInstance = new MyClass();
}
return uniqueInstance;
Если uniqueInstance содержит null, значит, экземпляр 
еще не создан...
...тогда мы создаем экземпляр Singleton приватным конструктором и присваиваем его 
uniqueInstance.
К моменту выполнения этой
команды экземпляр уже создан —
возвращаем его.
Если uniqueInstance уже 
содержит значение, сразу 
переходим к команде 
return.
uniqueInstance содержит 
ЕДИНСТВЕННЫЙ экземпляр; не забудьте, что 
это статическая переменная.
Класс MyClass переименован в Singleton.
Если вы бегло просматриваете книгу, 
не торопитесь использовать этот код. 
Как будет показано 
позднее в этой главе, 
он нуждается в доработке.
 Будьте осторожны!
204 глава 5
HeadFirst: Сегодня вниманию слушателей предлагается интервью с объектом Одиночкой. Может, немного расскажете о себе?
Одиночка: Я единственный и неповторимый!
HeadFirst: Неужели?
Одиночка: Да. Я создан на основе паттерна Одиночка, а это гарантирует, что в любой момент 
времени существует только один экземпляр моего 
класса.
HeadFirst: Разве это не расточительно? Кто-то 
тратит время на создание класса, а потом по этому описанию создается всего один объект?
Одиночка: Вовсе нет! Во многих случаях существование одиночных объектов оправданно. 
Предположим, в объекте хранятся настройки 
реестра. Если кто-то создаст несколько экземпляров такого объекта, это может привести к хаосу. 
Одиночные объекты гарантируют, что все компоненты вашего приложения будут использовать 
один и тот же глобальный ресурс.
HeadFirst: Продолжайте...
Одиночка: О, я отлично подхожу для подобных 
задач. Одиночество имеет свои преимущества. 
Меня часто используют для управления пулами 
ресурсов — скажем, подключений или программных потоков. 
HeadFirst: И все-таки — быть всегда одному? Вам 
не скучно?
Одиночка: Так как мне никто не помогает, скучать некогда. Но разработчикам не помешало бы 
получше изучить меня — во многих программах 
возникают ошибки, когда в системе создаются дополнительные экземпляры объектов, о которых 
их создатель и не подозревает.
HeadFirst: Но как можно быть уверенным в том, 
что вы существуете в одном экземпляре? Разве 
любой желающий не сможет создать новый экземпляр оператором new?
Одиночка: Нет! Я абсолютно уникален.
HeadFirst: Разработчики торжественно клянутся 
не создавать более одного экземпляра?
Одиночка: Нет, конечно. Возможно, это дело 
личное, но... у меня нет открытого конструктора.
HeadFirst: НЕТ ОТКРЫТОГО КОНСТРУКТОРА?! Ох, извините... неужели нет?
Одиночка: Вот именно. Мой конструктор объявлен приватным..
HeadFirst: И как работает эта схема? Как ВООБЩЕ можно создать экземпляр?
Одиночка: Чтобы получить объект, вы не создаете его экземпляр, а запрашиваете его. Мой 
класс содержит статический метод с именем 
getInstance(). Вызовите его, и вы получите экземпляр, готовый к работе. Может оказаться, что 
к этому моменту я уже существую и обслуживаю 
другие объекты.
HeadFirst: Похоже, в этой схеме многое остается 
скрытым от посторонних глаз! Спасибо, что приняли наше приглашение. Надеемся, наша беседа 
скоро продолжится!
Интервью недели:
Признания Одиночки
Паттерны
	 для всех
интервью с одиночкой
паттерн одиночка
дальше   205
Шоколадная фабрика
Всем известно, что на всех современных шоколадных фабриках используются нагреватели с компьютерным управлением. Смесь шоколада и молока в таком нагревателе доводится до кипения и передается на следующий этап изготовления шоколадных батончиков. Ниже приведен код класса, управляющего 
Choc-O-Holic — мощным высокопроизводительным нагревателем для шоколада. 
Просмотрите код; вы заметите, что автор постарался сделать все возможное, 
чтобы избежать некоторых неприятностей — скажем, слива холодной смеси, переполнения или нагревания пустой емкости!
public class ChocolateBoiler {
 private boolean empty;
 private boolean boiled;
 
 public ChocolateBoiler() {
 empty = true;
 boiled = false;
 }
 
 public void fill() {
 if (isEmpty()) {
 empty = false;
 boiled = false;
 // Заполнение нагревателя молочно-шоколадной смесью
 }
 }
 public void drain() {
 if (!isEmpty() && isBoiled()) {
 // Слить нагретое молоко и шоколад
 empty = true;
 }
 }
 public void boil() {
 if (!isEmpty() && !isBoiled()) {
 // Довести содержимое до кипения
 boiled = true;
 }
 }
 
 public boolean isEmpty() {
 return empty;
 }
 public boolean isBoiled() {
 return boiled;
 }
}
Код выполняется только 
при пустом нагревателе!
Перед наполнением мы проверяем, 
что нагреватель пуст, а после
наполнения устанавливаем флаги 
empty и boiled.
Чтобы слить содержимое, мы 
проверяем, что нагреватель не 
пуст, а смесь доведена до кипения. После слива флагу empty 
снова присваивается true.
Чтобы вскипятить смесь, мы 
проверяем, что нагреватель 
полон, но еще не нагрет. После 
нагревания флагу boiled присваивается true.
206 глава 5
Автор кода неплохо позаботился о том, чтобы избежать любых проблем. Но если в системе 
вдруг появятся два экземпляра ChocolateBoiler, возможны самые неприятные последствия.
Что может произойти, если приложение создаст два и более экземпляра ChocolateBoiler?
Сможете ли вы усовершенствовать класс ChocolateBoiler, 
преобразовав его в синглетную форму (то есть с единственным экземпляром)?
public class ChocolateBoiler {
 private boolean empty;
 private boolean boiled;
public void fill() {
 if (isEmpty()) {
 empty = false;
 boiled = false;
 // Заполнение нагревателя молочно-шоколадной смесью
 }
}
 // Остальной код ChocolateBoiler...
}
 private ChocolateBoiler() {
 empty = true;
 boiled = false;
 }
нагреватель для шоколада, синглетная форма
Мозговой
штурм
Возьми в руку карандаш
паттерн одиночка
дальше   207
Singleton
static uniqueInstance
// Другие данные Singleton...
static getInstance()
// Другие методы Singleton...
Паттерн Одиночка гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку 
доступа к этому экземпляру.
Определение паттерна Одиночка
Итак, вы познакомились с классической реализацией паттерна Одиночка. Сейчас можно 
устроиться поудобнее, съесть шоколадку и перейти к рассмотрению некоторых нюансов 
паттерна Одиночка.
Начнем с формального определения паттерна:
Пока ничего особенного. Но давайте присмотримся повнимательнее:
? Что здесь, по сути, происходит? Мы берем существующий класс и разрешаем ему 
создать только один экземпляр. Кроме того, мы запрещаем любым другим классам 
произвольно создавать новые экземпляры этого класса. Чтобы получить экземпляр, 
необходимо обратиться с запросом к самому классу.
? Кроме того, паттерн предоставляет глобальную точку доступа к экземпляру: обратившись с запросом к классу в любой точке программы, вы получите ссылку на 
единственный экземпляр. Как было показано выше, возможно отложенное создание 
экземпляра, что особенно важно для объектов, создание которых сопряжено с большими затратами ресурсов.
Обратимся к диаграмме классов:
Метод getInstance() объявлен статическим, что 
позволяет легко вызвать 
его в любом месте с использованием синтакиса Singleton.getInstance(). 
Этот способ ничуть не 
сложнее обращения к глобальной переменной, но он 
обладает дополнительными 
преимуществами, такими 
как отложенная инициализация.
Переменная класса 
uniqueInstance содержит 
один и только один экземпляр Singleton.
Паттерн Одиночка реализуется 
классом общего назначения, который 
обладает собственными данными 
и методами.
208 глава 5
Кажется, у нас проблемы...
Похоже, программа управления нагревателем нас подвела; хотя мы усовершенствовали код и перешли на классическую реализацию паттерна Одиночка, метод fill() класса ChocolateBoiler почему-то начал заполнять емкость, 
которая уже была заполнена! 500 галлонов молока (и шоколада) пролилось 
на пол. Что произошло?!
Могло ли введение программных потоков 
привести к катастрофе? Ведь после того, как 
переменной uniqueInstance будет присвоен 
единственный экземпляр ChocolateBoiler, все 
вызовы getInstance() должны возвращать один 
и тот же экземпляр? Разве нет?
проблемы с потоками
Осторожно
Горячий 
шоколад
Мы не знаем, что произошло! Новый код работал 
идеально. Правда, мы недавно добавили в код 
управления нагревателем многопоточную 
оптимизацию...
паттерн одиночка
дальше   209
Первый 
поток
Есть два программных потока, в каждом из которых выполняется этот код.
Ваша задача — представить себя 
в роли JVM и определить, не могут 
ли два потока в какой-то ситуации 
получить два разных объекта 
нагревателя. Подсказка: 
проанализируйте последовательность операций 
в методе getInstance( ) и значение uniqueInstance и подумайте, могут ли они 
перекрываться. Магниты с фрагментами кода помогут вам в поиске 
возможной последовательности действий, в результате которой программа 
может получить два объекта ChocolateBoiler.
Представьте, что вы — JVM...
if (uniqueInstance == null) {
}
Второй 
поток
uniqueInstance = 
 new ChocolateBoiler();
return uniqueInstance;
public static ChocolateBoiler
getInstance() {
}
ChocolateBoiler boiler = 
 ChocolateBoiler.getInstance();
fill();
boil();
drain();
Значение 
uniqueInstance
Прежде чем читать дальше, проверьте свой ответ на с. 217!
210 глава 5
public class Singleton {
 private static Singleton uniqueInstance;
 // Другие переменные экземпляра
 private Singleton() {}
 public static synchronized Singleton getInstance() {
 if (uniqueInstance == null) {
 uniqueInstance = new Singleton();
 }
 return uniqueInstance;
 }
 // Другие методы
}
Решение проблемы многопоточного доступа
Наши многопоточные проблемы решаются почти тривиально: метод getInstance() 
объявляется синхронизированным:
Включая в объявление 
getInstance() ключевое слово 
synchronized, мы заставляем 
каждый поток дождаться своей 
очереди для входа в него. Иначе 
говоря, два потока не смогут 
войти в метод одновременно.
Согласен, 
это решает проблему. 
Но синхронизация обходится 
недешево, как быть с этим?
В точку! На самом деле ситуация еще серьезнее: синхронизация актуальна только при первом вызове этого метода. 
Иначе говоря, после того, как переменной uniqueInstance 
будет присвоен экземпляр синглетного класса, необходимость в дальнейшей синхронизации этого метода отпадает. 
После первого выполнения синхронизация только приводит к лишним затратам ресурсов!
проблемы многопоточности
паттерн одиночка
дальше   211
При таком подходе мы доверяем JVM создание уникального экземпляра Singleton при загрузке класса. JVM гарантирует, что экземпляр будет создан до того, как какой-либо поток 
сможет обратиться к статической переменной uniqueInstance. 
public class Singleton {
 private static Singleton uniqueInstance = new Singleton();
 private Singleton() {}
 public static Singleton getInstance() {
 return uniqueInstance;
 }
}
Можно ли усовершенствовать многопоточную реализацию?
Безусловно, в большинстве Java-приложений мы должны позаботиться о том, чтобы паттерн работал в многопоточном коде. Но синхронизация метода getInstance() приводит 
к значительным затратам ресурсов. Что же делать?
Есть несколько вариантов.
1. Ничего не делать, если производительность getInstance() не критична
для вашего приложения 
Да, вы не ошиблись: если вызов getInstance() не приводит к заметному ухудшению быстродействия, не обращайте внимания. Синхронизация getInstance() — простое и эффективное решение. Только помните, что синхронизация метода может замедлить его выполнение в сто и более раз. Если метод getInstance() применяется в интенсивно используемой 
части приложения, возможно, вам стоит пересмотреть свое решение.
2. Создавайте экземпляр заранее
Если приложение всегда создает и использует экземпляр синглетного класса или затраты на создание не столь существенны, экземпляр можно создать заранее:
Экземпляр Singleton 
создается в статическом инициализаторе. 
Потоковая безопасность 
этого кода гарантирована!
Экземпляр уже существует, просто 
возвращаем его.
212 глава 5
 Будьте осторожны!
Проверяем экземпляр; 
если он не существует — входим в блок 
synchronized.
public class Singleton {
 private volatile static Singleton uniqueInstance;
 private Singleton() {}
 public static Singleton getInstance() {
 if (uniqueInstance == null) {
 synchronized (Singleton.class) {
 if (uniqueInstance == null) {
 uniqueInstance = new Singleton();
 }
 }
 }
 return uniqueInstance;
 }
}
Внутри блока повторяем проверку, и если значение все еще равно 
null, создаем экземпляр.
Синхронизация 
выполняется только 
при первом вызове!
Ключевое слово volatile гарантирует, что параллельные программные потоки будут правильно работать с переменной 
uniqueInstance при ее инициализации экземпляром Singleton.
Если производительность выполнения getInstance() критична, то этот способ 
реализации кардинально ускорит выполнение метода.
К сожалению, в Java 1.4 и ниже многие JVM 
содержат неверную синхронизацию условной 
блокировки. При необходимости использования 
JVM-версии, отличной от Java 5, рассмотрите 
другие способы реализации паттерна Одиночка.
Условная блокировка не 
работает в Java 1.4 и более 
ранних версиях!
3. Воспользуйтесь «условной блокировкой», чтобы свести к минимуму использование 
синхронизации в getInstance()
Сначала проверьте, создается ли новый экземпляр, и если нет, ТОГДА синхронизируйте фрагмент кода. 
В этом случае синхронизация будет выполняться только при первом вызове (что нам, собственно, и требовалось).
Давайте проверим код:
условная блокировка
паттерн одиночка
дальше   213
Тем временем на шоколадной фабрике...
Пока мы разбирались с проблемами многопоточности, нагреватель уже почистили, 
и он снова готов к работе. Но сначала необходимо исправить допущенную ошибку. 
Имеется несколько решений, каждое из которых обладает своими достоинствами 
и недостатками, — какое из них следует применить?
Опишите пригодность каждого решения для решения проблемы многопоточности в коде ChocolateBoiler: 
Синхронизация метода getInstance():
Раннее создание экземпляра:
Условная блокировка:
К этому моменту все проблемы шоколадной фабрики решены. Какое бы из многопоточных решений 
вы ни применили, нагреватель работает нормально, а новые сбои исключены. Поздравляем! В этой 
главе мы не только разлили 500 галлонов горячего шоколада, но и рассмотрели все потенциальные 
проблемы паттерна Одиночка. 
Поздравляем!
Возьми в руку карандаш
214 глава 5
В: Для такого простого паттерна, состоящего из одного класса, у Одиночки 
многовато проблем.
О: Пусть проблемы вас не смущают; 
возможно, правильная реализация потребует некоторых усилий. После чтения этой 
главы вы достаточно хорошо разбираетесь 
во всех тонкостях и сможете использовать 
этот паттерн для ограничения количества 
создаваемых экземпляров.
В: А почему не создать класс, у которого все методы и переменные определены как статические? Разве это не приведет к тому же результату?
О: Да, если ваш класс автономен и не 
участвует в сложных инициализациях. Но 
из-за особенностей статической инициализации в Java (прежде всего с участием 
нескольких классов) в этом сценарии возможны коварные, трудноуловимые ошибки, 
связанные с порядком инициализации. Если 
у вас нет веских причин для выбора именно 
такой реализации, лучше придерживаться 
традиционной объектной парадигмы.
В: А как насчет загрузчиков классов? 
Говорят, существует вероятность того, 
что два загрузчика классов получат собственный экземпляр синглетного класса.
О: Да, это правда, так как каждый загрузчик классов определяет пространство 
имен. Если вы используете два и более загрузчика, вы сможете загрузить один класс 
многократно (по одному разу для каждого 
загрузчика). Если класс будет синглетным, 
то мы получим несколько экземпляров 
синглетного объекта. Будьте внимательны! 
Одно из возможных решений — самостоятельное назначение загрузчика.
В: А отражение, сериализация/десериализация?
О: Да, отражение и сериализация/десериализация могут создать проблемы с 
паттерном Одиночка. Если вы – опытный 
пользователь JavaScript, уверенно использующий отражение, сериализацию и десериализацию, вам придется помнить об этом.
В: Ранее мы говорили о принципе 
слабого связывания. Разве Одиночка не 
нарушает этот принцип? В конце концов, 
каждый объект в коде, который зависит 
от Одиночки, будет сильно связан с этим 
конкретным объектом.
О: Да, это одна из стандартных претензий 
к паттерну Одиночка. Принцип слабого связывания рекомендует «стремиться к слабой 
связанности взаимодействующих объектов». 
Одиночке легко нарушить этот принцип: 
при внесении изменений в Одиночку вам с 
большой вероятностью придется вносить 
изменения в каждый объект, который с ним 
связан.
В: Меня учили, что класс должен делать 
что-то одно. Совмещение классом двух 
функций считается признаком плохого ООпроектирования. Разве паттерн Одиночка 
не нарушает это правило?
О: Вы говорите о «принципе одной обязанности»? Да, вы правы. Синглетный класс 
отвечает не только за управление своим 
экземпляром (и предоставление глобального 
доступа к нему), но и за выполнение своих 
основных функций в приложении. То есть он 
имеет не одну, а две обязанности. Однако 
все управление экземпляром осуществляется отдельной подсистемой класса, что 
упрощает общую архитектуру. Разработчики 
хорошо знают паттерн Одиночка, но некоторые считают, что его функциональность следует абстрагировать за пределами класса.
В: Я хотел субклассировать свой синглетный класс, но у меня возникли проблемы. Можно ли субклассировать такие 
классы? 
О: Одна из проблем с субклассированием синглетных классов связана с приватностью конструктора. Класс с приватным 
конструктором расширить нельзя. Следовательно, прежде всего конструктор придется изменить, чтобы он был открытым 
или защищенным. Но тогда класс перестает быть синглетным, потому что другие 
классы смогут создавать его экземпляры.
Изменение конструктора также создает 
другую проблему. Реализация паттерна 
Одиночка основана на статической переменной, поэтому при прямолинейном субклассировании все производные классы 
будут совместно использовать одну переменную экземпляра. Вам это не нужно, 
поэтому при субклассировании придется 
реализовать в базовом классе некое подобие системы управления доступом. 
Но что вы на самом деле приобретаете от субклассирования Одиночки? Как и 
большинство паттернов, этот не рассчитан на библиотечное использование, а его 
поддержка элементарно добавляется в 
любой существующий класс. Если в вашем приложении используется большое 
количество синглетных классов, возможно, вам стоит пересмотреть архитектуру.
В: Я не понимаю, почему глобальные 
переменные хуже паттерна Одиночка.
О: В Java глобальные переменные фактически представляют собой статические 
ссылки на объекты. У подобного использования глобальных переменных имеется 
пара недостатков. Один уже упоминался 
ранее: немедленное создание экземпляра 
вместо отложенного. Но мы должны помнить 
о предназначении этого паттерна: он должен 
обеспечить существование только одного 
экземпляра класса и глобальный доступ к 
нему. Глобальная переменная обеспечивает 
второе, но не первое. Кроме того, глобальные переменные вынуждают разработчиков 
загрязнять пространство имен множеством 
глобальных ссылок на мелкие объекты. Синглетным классам этот недостаток не присущ, 
хотя возможны и другие злоупотребления.
вопросы и ответы
часто Задаваемые вопросы
паттерн одиночка
дальше   215
Да, хорошая мысль!
Многие из перечисленных проблем — хлопоты с синхронизацией, 
проблемы с загрузчиками классов, отражение и проблемы сериализации/
десериализации— решаются использованием перечисления для создания 
Одиночки. Вот как это делается:
public enum Singleton {
 UNIQUE_INSTANCE;
 // Другие поля
}
public class SingletonClient {
public static void main(String[] args) {
 Singleton singleton = Singleton.UNIQUE_INSTANCE;
// здесь используется Одиночка
}
}
Да, вот и все. Проще некуда, верно? Возникает вопрос: зачем мы пошли на 
все хлопоты с созданием класса Singleton, содержащего метод getInstance(), 
последующей синхронизацией и т. д.? Это было сделано для того, чтобы 
вы по-настоящему поняли, как работает Одиночка. А теперь, когда вы это 
знаете, вы сможете использовать перечисление везде, где потребуется 
Одиночка, и при этом успешно пройдете собеседование, где вас спросят: 
«А как бы вы реализовали Одиночку без enum?» 
Сможете ли вы переработать реализацию для Choc-O-Holic так, 
чтобы в ней использовалось перечисление? Попробуйте. 
К тому же 
в доисторические 
времена, когда мы еще 
ходили в школу (пешком 
по снегу), в Java не было 
перечислений.
Мозговой
штурм
Я только что понял… Многие 
проблемы Одиночки можно решить 
при помощи перечисления (enum). 
Верно?
216 глава 5
Новые инструменты
  Паттерн Одиночка гарантирует, что в приложении 
существует не более одного 
экземпляра данного класса.
  Паттерн Одиночка также предоставляет глобальную точку 
доступа к этому экземпляру.
  Реализация паттерна Одиночка на языке Java использует 
приватный конструктор и статический метод в сочетании со 
статической переменной.
  Проанализируйте ограничения по производительности 
и затратам ресурсов, тщательно выберите реализацию 
Одиночки для многопоточного 
приложения.
  Будьте внимательны с условной блокировкой — в версиях 
до Java 5 она была небезопасной.
  Будьте внимательны при 
использовании загрузчиков 
классов — они могут привести 
к созданию нескольких экземпляров, а это противоречит 
основной цели паттерна.
  Если вы используете JVM версии ранее 1.2, создайте реестр 
синглетных объектов, чтобы 
предотвратить их уничтожение 
уборщиком мусора.
  Для упрощения реализации 
«Одиночки» можно воспользоваться перечислениями Java.
Паттерн Одиночка определяет альтернативный 
способ создания объектов — в данном случае уникальных объектов.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, 
что изменяется.
Отдавайте предпочтение композиции перед 
наследованием.
Программируйте на 
уровне интерфейсов.
Стремитесь к слабой 
связанности взаимодействующих объектов.
Классы должны быть 
открыты для расширения, но закрыты для изменения.
Код должен зависеть от 
абстракций, а не от конкретных классов.
Принципы
Стратегия — определяет семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет 
модифицировать алг
Паттерны
Наблюдатель — определяет отношение “один-комногим” между объектами 
таким образом, что при 
изменении со- стояния одного 
объекта
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a flexible 
alternative to subclassing 
for extending 
functionality.
Абстрактная фабрика — 
предосталвяет интерфейс 
для создания семейсв взаимосвязанных объектов без 
указания конкретных классов.
Фабричный Метод — 
определяет интерфейс 
создания объекта, но позволяет субклассам выбрать 
создаваемый экземпляр.
Одиночка гарантирует, 
что класс имеет только 
один экземпляр, и предоставляет глобальную точку 
доступа к этому экземпляру.
Если у класса вашего приложения 
должен существовать только один 
экземпляр, воспользуйтесь паттерном Одиночка. 
инструментарий проектирования
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Несмотря на внешнюю простоту, для правильной реализации паттерна Одиночка необходимо 
учесть многие нюансы. Впрочем, после прочтения этой главы вы сможете свободно использовать его в своем коде.
паттерн одиночка
дальше   217
Ответы 
к упражнениям
Сможете ли вы усовершенствовать класс ChocolateBoiler, преобразовав 
его в синглетную форму (то есть с единственным экземпляром)?
public class ChocolateBoiler {
 private boolean empty;
 private boolean boiled;
public void fill() {
 if (isEmpty()) {
 empty = false;
 boiled = false;
 // Заполнение нагревателя молочно-шоколадной смесью
 }
}
 // Остальной код ChocolateBoiler...
}
 private ChocolateBoiler() {
 empty = true;
 boiled = false;
 }
public static ChocolateBoiler getInstance() {
 if (uniqueInstance == null) {
 uniqueInstance = new ChocolateBoiler();
 }
 return uniqueInstance;
}
private static ChocolateBoiler uniqueInstance;
Первый 
поток Второй 
поток Значение uniqueInstance
if (uniqueInstance == null) {
uniqueInstance = 
 new ChocolateBoiler();
public static ChocolateBoiler
getInstance() {
public static ChocolateBoiler
getInstance() {
if (uniqueInstance == null) {
uniqueInstance = 
 new ChocolateBoiler();
return uniqueInstance;
return uniqueInstance;
null
null
null
<object1>
<object2>
<object2>
<object1>
Представьте, что вы — JVM...
Возвращаются два разных 
объекта! Мы 
получаем два 
экземпляра 
ChocolateBoiler!!!
Осторожно: 
опасность!
Возьми в руку карандаш
 Решение
218 глава 5
ответы к упражнениям
Простое и заведомо рабочее решение. Хорошо подходит для нашей задачи, 
Синхронизация метода getInstance():
Ранняя инициализация:
Условная блокировка:
в которой нет проблем с быстродействием.
Экземпляр нагревателя в нашем приложении необходим всегда, и ранняя 
инициализация не создаст проблем. 
Решение работает так же хорошо, как и синхронизация метода, хотя, 
возможно, оно будет менее очевидным для разработчика, знакомого 
со стандартным паттерном.
При отсутствии ограничений по производительности условная блокировка
выглядит как перебор. Также не забудьте убедиться в том,
что вы используете как минимум Java 5.
Опишите пригодность каждого решения для решения проблемы 
многопоточности в коде ChocolateBoiler: 
Возьми в руку карандаш
 Решение
В этой главе мы выходим на новый уровень инкапсуляции — на этот раз будут инкапсулироваться вызовы методов. Да, все верно — вызывающему объекту не нужно беспокоиться о 
том, как будут выполняться его запросы. Он просто использует инкапсулированный метод для решения своей задачи. Инкапсуляция позволяет 
решать и такие нетривиальные задачи, как регистрация или повторное 
использование для реализации функции отмены в коде. 
Инкапсуляция вызова 
6 Паттерн Команда
Тайники для инструкций произвели 
настоящую революцию в шпионском 
деле. Я просто оставляю запрос — 
а где-то меняются правительства и исчезают нежелательные свидетели. Мне не 
нужно беспокоиться о том, что, где и когда 
происходит, оно просто происходит!
220 глава 6
Недавно я получил от Джонни Харрикейна, исполнительного директора Weather-O-Rama, демоверсию и краткое 
описание их новой метеостанции. Архитектура продукта 
произвела на меня такое впечатление, что я решил предложить вашей фирме разработку API для нашего нового 
Пульта Домашней Автоматизации. Ваши услуги будут щедро оплачены акциями нашей фирмы.
Прилагаю прототип нашего революционного устройства. 
Пульт имеет семь программируемых ячеек (каждая из 
которых связывается с отдельным домашним устройством) 
и соответствующую кнопку «вкл/выкл» для каждой ячейки. 
Кроме того, устройство оснащено кнопкой глобальной отмены. 
Прикладываю к этому сообщению набор классов Java, написанных разными разработчиками для управления всевозможными домашними устройствами: светильниками, вентиляторами, ваннами-джакузи, акустическим оборудованием 
и т. д. 
Ваша задача — создать API для программирования пульта, 
чтобы каждая ячейка могла быть настроена на управление устройством или группой устройств. Также следует 
учесть, что пульт должен поддерживать как текущий набор устройств, так и все устройства, которые могут быть 
добавлены в будущем.
После знакомства с работой, выполненной вами для метеостанции Weather-O-Rama, мы не сомневаемся, что вы 
отлично справитесь с разработкой программного обеспечения для пульта!
Надеемся на успешное сотрудничество.
Искренне ваш,
Билл «X-10» Томпсон, исполнительный директор
автоматизируй дом, или проиграешь
паттерн команда
дальше   221
Для каждой из семи 
ячеек имеются кнопки «вкл» и «выкл». Пульт имеет семь 
программируемых 
ячеек. Каждая ячейка 
связывается с определенным устройством.
Отмена нажатия последней 
кнопки.
Эти две кнопки управляют 
устройством
в ячейке 1...
...эти — устройством в ячейке 2...
...и так далее.
Посмотрим, чего от нас хотят...
Здесь вписываются 
имена устройств.
222 глава 6
Классы управления устройствами
Просмотрите иерархию классов, приложенных к сообщению. Она дает некоторое представление об интерфейсах 
объектов, необходимых для управления пультом.
CeilingLight
on()
off()
dim()
Hottub
circulate()
jetsOn()
jetsOff()
setTemperaturet()
on()
off()
setInputChannel()
setVolume()
TV
OutdoorLight
on()
off()
GarageDoor
up()
down()
stop()
lightOn()
lightOff()
Stereo
on()
off()
setCd()
setDvd()
setRadio()
setVolume()
FaucetControl
openValue()
closeValue()
Thermostat
setTemperature()
()
GardenLight
setDuskTime()
setDawnTime()
manualOn()
manualOff()
CeilingFan
high()
medium()
low()
off()
getSpeed()
ApplianceControl
on()
off()
SecurityControl
arm()
disarm()
Sprinkler
waterOn()
waterOff() Light
on()
off()
Как видите, набор классов довольно обширный, а до появления унифицированного интерфейса еще очень далеко. Более того, в будущем наверняка появятся новые 
классы. Проектирование API для пульта в таких условиях — задача далеко не тривиальная.
классы устройств
Ого! Довольно много разных 
устройств, которыми должен 
управлять пульт.
И эти устройства имеют совершенно разные 
интерфейсы.
паттерн команда
дальше   223
Мэри: Да, я ожидала увидеть семейство классов с методами on() и off(), но 
классы содержат много других методов: dim(), setTemperature(), setVolume(), 
setInputChannel() и waterOn()...
Сью: Более того, в будущем появятся новые классы устройств с еще более разнообразными методами.
Мэри: Я думаю, важно рассматривать ситуацию с точки зрения разделения обязанностей.
Сью: В смысле?
Мэри: Я имею в виду, что пульт должен знать, как интерпретировать нажатия 
кнопок и выдавать запросы, но он не должен обладать полной информацией 
о домашней автоматизации или о том, как включить джакузи.
Сью: Но если пульт умеет только выдавать обобщенные запросы, как спроектировать его для выполнения таких действий, как, скажем, включение света или 
открытие двери гаража?
Мэри: Пока не знаю, но пульт в любом случае не должен привязываться к конкретной реализации классов устройств.
Сью: Что ты имеешь в виду?
Мэри: Программа не должна состоять из цепочки условных команд вида
«if slot1 == Light, then light.on(), else if slot1 = Hottub then hottub.jetsOn()». Это 
признак плохой архитектуры.
Сью: Согласна. Ведь при появлении нового класса устройства нам неизбежно 
придется изменять код, а это повышает риск ошибок и создает дополнительную 
работу!
Разговор в офисе
Сью
Ваши коллеги уже обсуждают, каким должен быть API...
Первое, что мы видим, — сам 
пульт устроен очень просто (всего 
две кнопки включения/выключения), 
но классы устройств весьма 
разнообразны.
224 глава 6
Мэри: Вот как? Расскажи подробнее.
Джо: Паттерн Команда отделяет сторону, выдающую запрос, от объекта, 
фактически выполняющего операцию. В нашем примере запрос поступает 
от пульта, а объектом, выполняющим операцию, будет экземпляр одного из 
классов устройств.
Сью: Но как такое возможно? Как разделить их? В конце концов, когда я нажимаю кнопку, пульт должен включить свет.
Джо: Для этого в архитектуру приложения вводятся объекты команд. Объект команды инкапсулирует запрос на выполнение некой операции (скажем, 
включение света) с конкретным объектом (допустим, с осветительной системой). Если для каждой кнопки в приложении хранится свой объект команды, 
при ее нажатии мы обращаемся к объекту команды с запросом на выполнение 
операции. Сам пульт понятия не имеет, что это за операция, — он знает только, 
как взаимодействовать с нужным объектом для выполнения операции. Получается, что пульт полностью отделен от объекта осветительной системы!
Сью: Да, это похоже на то, что нам нужно.
Мэри: А я пока плохо представляю, как работает этот паттерн. Давайте посмотрим, правильно ли я понимаю: используя этот паттерн, мы можем создать API, в котором объекты команд связываются с определенными ячейками, благодаря чему код пульта остается очень простым. При этом выполнение 
операции инкапсулируется в том объекте, который эту операцию должен выполнять.
Джо: Да, вроде так. И еще мне кажется, что паттерн поможет реализовать 
функцию отмены, хотя я пока не размышлял об этом.
Мэри: Выглядит заманчиво, но, по-моему, чтобы действительно хорошо понять суть этого паттерна, мне придется изрядно потрудиться.
Сью: И мне тоже.
Случайно 
услышал ваш разговор... 
Я еще с главы 1 сильно 
заинтересовался паттернами. Есть 
такой паттерн — Команда, и я 
подумал, что он нам может 
пригодиться.
паттерн Команда
паттерн команда
дальше   225
А тем временем в кафе... 
или
Краткое введение в паттерн Команда
Все мы отлично знаем, как работает кафе:
Посетитель передает 
Официантке свой 
Заказ.
1
Официантка 
получает Заказ, 
кладет его на 
стойку и говорит: 
«У нас заказ!»
Повар готовит блюда, входящие в ваш Заказ.
2
3
Кафе в Объектвиле
Жаль, что вас здесь нет...
Гамбургер с сыром
Молочный коктейль
Паттерн Команда довольно трудно понять по описанию. Но не 
огорчайтесь, у нас есть помощники: помните кафе из главы 1? 
С тех пор, как мы навещали Элис и Фло, прошло немало времени, 
но у нас есть веские причины, чтобы вернуться туда (помимо еды 
и дружеского общения): кафе поможет нам лучше понять паттерн 
Команда.
Давайте проанализируем взаимодействия между посетителем, 
официанткой, заказами и поваром. Так вы лучше поймете суть 
взаимодействий объектов, задействованных в паттерне Команда. 
А потом мы сможем вплотную заняться проектированием API для 
пульта управления домашней техникой.
Итак, в кафе Объектвиля...
226 глава 6
Гамбургер
с сыром
Молочный
коктейль
createOrder()
takeOrder()
Гамбургер
с сыром
Молочный
коктейль
orderUp()
makeBurger(), makeShake()
результат 
Бланк с записью блюд, 
заказанных посетителем.
Посетитель просматривает меню 
и создает заказ.
Получив Заказ, Официантка инициирует его обработку вызовом метода 
orderUp().
Заказ содержит 
все инструкции, 
необходимые для 
его выполнения. 
Для передачи 
распоряжений 
Повару используются вызовы 
методов вида 
makeBurger().
Повар выполняет 
инструкции, содер
жащиеся в Заказе, 
-
и готовит блюда.
Рассмотрим взаимодействия чуть более подробно...
...а так как кафе находится в Объектвиле, мы используем для их описания 
объекты и методы!
Начало
в кафе
Мне гамбургер 
с сыром и молочный коктейль.
паттерн команда
дальше   227
Роли и обязанности в кафе Объектвиля 
Бланк заказа инкапсулирует запрос на приготовление блюд.
Будем рассматривать бланк Заказа как объект запроса на 
приготовление еды. Как и любой другой объект, он может 
передаваться — от Официантки на стойку или следующей 
Официантке, которая сменяет первую. Его интерфейс состоит из единственного метода orderUp(), инкапсулирующего все действия, необходимые для приготовления. Кроме того, Заказ содержит ссылку на объект, который должен 
готовить блюда (Short-Order Cook). Инкапсуляция заключается в том, что Официантку не интересует содержимое заказа и то, кто будет его выполнять; она только кладет заказ 
на стойку и сообщает: «Поступил заказ!» Наверное, в реальной жизни официантка следит за тем, что 
записано на бланке и кто выполняет заказ, но мы-то находимся
в Объектвиле!
public void orderUp() {
 cook.makeBurger();
 cook.makeShake();
}
Задача Официантки — получить Заказ и вызвать 
его метод orderUp().
Работа Официантки проста: она получает Заказ и продолжает обслуживать посетителей, пока не вернется 
к стойке и не вызовет метод orderUp() для выполнения 
Заказа. Как упоминалось ранее, Официантка не беспокоится о том, что содержится в Заказе и кто его будет выполнять. 
Ей известно лишь то, что у Заказа есть метод orderUp(), который необходимо вызвать для выполнения операции.
В течение рабочего дня метод takeOrder() класса Официантки вызывается с множеством разных заказов от разных 
посетителей, но это Официантку не смущает. Она знает, 
что все Заказы поддерживают метод orderUp(), который 
необходимо вызвать для приготовления блюд.
Повар располагает всей информацией, 
необходимой для приготовления блюд.
Повар — тот объект, который умеет выполнять заказы. 
После того как Официантка вызовет метод orderUp(), за 
дело берется Повар — он реализует все методы, необходимые для создания блюд. Обратите внимание: Официантка 
и Повар ничем не связаны. Вся информация о заказанных 
блюдах инкапсулирована в Заказе; Официантка только вызывает метод для каждого Заказа, чтобы он был выполнен. 
Повар получает свои инструкции из бланка Заказа; ему никогда не приходится взаимодействовать с Официанткой напрямую.
Я ничего не 
готовлю сама, я только 
принимаю заказы и кричу: 
«Поступил заказ!»
Меня 
с Официанткой 
определенно ничего 
не связывает. И вообще 
она не в моем вкусе!
228 глава 6
Прежде чем двигаться дальше, 
хорошенько изучите приведенную пару 
страниц назад диаграмму с ролями 
и обязанностями, пока вы не начнете 
хорошо разбираться в объектах 
и взаимоотношениях. А когда это будет 
сделано, беритесь за паттерн Команда!
I’ll have a Burger 
with Cheese and a Malt 
Shake
Burger with 
Cheese
 Malt Shake
createOrder()
Burger with 
Cheese
 Malt Shake
takeOrder()
orderUp()
makeBurger(), makeShake()
output
The Order consists 
of an order slip 
and the customer’s 
menu items that 
are written on it
The customer knows 
what he wants 
prepared and 
creates an order
The Waitress takes the order, and 
when she gets around to it, she 
calls its orderUp() method to 
begin the order’s preparation
The Order 
has all the 
instructions 
need to 
prepare 
the meal. 
The Order 
directs the 
Short Order 
Cook with 
methods like 
makeBurger()
The Short 
Order Cook 
follows the 
instructions 
of the 
Order and 
produces 
the meal
Хорошо, у нас есть 
кафе с Официанткой, которая 
отделена от Повара объектом 
Заказа... и что? Ближе к делу!
Терпение, мы уже недалеко от цели...
Кафе можно рассматривать как модель паттерна ОО-проектирования, отделяющего объект-источник запроса от объекта, принимающего и выполняющего эти запросы. Например, 
в API пульта управления код, вызываемый при нажатии кнопки, должен отделяться от объектов конкретных классов, выполняющих эти запросы. Почему бы не связать каждую ячейку 
пульта с объектом, аналогичным объекту заказа из кафе? При 
нажатии кнопки будет вызываться аналог метода orderUp() такого объекта, а в доме будет включаться свет, причем пульт не 
будет ничего знать о том, как он включается и какие объекты 
задействованы в выполнении операции.
А теперь давайте немного сменим тему и перейдем от кафе 
к паттерну Команда...
кафе как модель паттерна команда
Мозговой
штурм
паттерн команда
дальше   229
createCommandObject()
setCommand()
execute()
action1(), action2()
Клиент отвечает за создание 
объекта команды, содержащего 
набор операций с получателем.
Клиент вызывает метод 
setCommand() Инициатора 
и передает ему объект команды. 
Инициатор сохраняет последний 
до момента использования.
В какой-то момент 
Инициатор вызывает 
метод execute() объекта команды...
...что приводит к активизации 
операций 
с Получателем.
Получатель
Команда
execute()
Инициатор
setCommand()
action1()
action2()
 ...
Клиент
create
Command
Object()
Команда
execute()
Получатель
public void execute {
 receiver.action1();
 receiver.action2(); Объект команды содер
}
-
жит единственный метод 
execute(), в котором инкапсулируются операции 
с Получателем.
Операции связываются с Получателем в объекте команды.
От кафе к паттерну Команда
Мы провели в кафе Объектвиля достаточно времени, чтобы изучить всех действующих лиц и их обязанности. А теперь диаграмма выполнения заказа будет переработана для паттерна Команда. Вы увидите, что участники остались прежними, изменились только имена!
Начало
1
2
3
Клиент создает объект 
команды.
Клиент вызывает setCommand() для сохранения объекта команды 
в Инициаторе.
Позднее... клиент обращается к инициатору 
с запросом на выполнение команды. Команда, 
загруженная Инициатором, может как уничтожаться после выполнения, так и оставаться 
для повторного использования.
1
3 Загрузка команды
2
230 глава 6
Сопоставьте роли и методы из примера с кафе с соответствующими ролями и методами паттерна Команда.
Кафе Паттерн Команда
Официантка
Повар
orderUp()
Заказ
Посетитель
takeOrder()
Команда
execute()
Клиент
Инициатор
Получатель
setCommand()
кто и что делает?
Кто и что делает?
паттерн команда
дальше   231
Наш первый объект команды
Не пора ли создать первый объект команды? Хотя API для пульта управления домашней техникой еще не спроектирован, построение реализации 
«снизу вверх» может нам помочь...
Реализация интерфейса Command
Начнем по порядку: все объекты команд реализуют единый интерфейс, который состоит всего 
из одного метода. В примере с кафе мы назвали этот метод orderUp(), но чаще встречается стандартное имя execute().
Интерфейс Command выглядит так:
Допустим, вы хотите реализовать команду для включения света. 
Обратившись к описаниям классов устройств, мы видим, что класс 
Light содержит два метода: on() и off(). Реализация команды выглядит примерно так:
public class LightOnCommand implements Command {
 Light light;
 
 public LightOnCommand(Light light) {
 this.light = light;
 }
 public void execute() {
 light.on();
 }
}
Очень простой интерфейс: 
всего один метод execute().
Метод execute вызывает метод on() объекта-получателя (то 
есть осветительной 
системы).
В переменной light конструктору передается конкретный объект, которым будет 
управлять команда (допустим, освещение в гостиной). 
При вызове execute получателем запроса будет объект 
light.
Итак, у нас имеется класс LightOnCommand. Давайте найдем ему практическое применение...
Реализация команды для включения света
Класс команды должен 
реализовать интерфейс Command.
Light
on()
off()
public interface Command {
 public void execute();
}
232 глава 6
Использование объекта команды
Упростим исходную задачу: допустим, пульт оснащен всего одной кнопкой и имеет всего одну ячейку 
для хранения управляемого устройства:
Следующий фрагмент кода поможет нам в тестировании упрощенной версии пульта. Обратите внимание на соответствие между отдельными строками и блоками диаграммы паттерна Команда:
Всего одна ячейка для хранения 
команды (и одно управляемое 
устройство).
Создание простого теста
public class SimpleRemoteControl {
 Command slot;
 public SimpleRemoteControl() {}
 public void setCommand(Command command) {
 slot = command;
 }
 public void buttonWasPressed() {
 slot.execute();
 }
}
public class RemoteControlTest {
 public static void main(String[] args) {
 SimpleRemoteControl remote = new SimpleRemoteControl();
 Light light = new Light();
 LightOnCommand lightOn = new LightOnCommand(light);
 remote.setCommand(lightOn);
 remote.buttonWasPressed();
 }
}
Метод для назначения команды. Может 
вызываться повторно, если клиент кода 
захочет изменить 
поведение кнопки.
Метод, вызываемый при нажатии 
кнопки. Мы просто берем объект 
команды, связанный с текущей 
ячейкой, и вызываем его метод 
execute().
Клиент в терминологии паттерна.
Объект remote — 
Инициатор; ему будет 
передаваться объект 
команды.
Создание объекта Light, 
который будет Получателем запроса.
Создание команды с указанием 
Получателя.
Команда передается Инициатору.
Имитируем нажатие кнопки.
%java RemoteControlTest
Light is On
%
File Edit Window Help DinerFoodYum
Результат выполнения тестового 
кода.
использование объекта команды
паттерн команда
дальше   233
GarageDoor
up()
down()
stop()
lightOn()
lightOff()
А теперь вы самостоятельно реализуете класс GarageDoorOpenCommand. Для начала вам понадобится диаграмма класса GarageDoor.
public class GarageDoorOpenCommand 
 implements Command {
}
Ваш класс готов — какой результат выведет следующий код? (Подсказка: метод up() класса GarageDoor выводит сообщение «Garage Door is Open».)
Ваш код
File Edit Window Help GreenEggs&Ham
%java RemoteControlTest
Здесь впишите свои 
результаты.
public class RemoteControlTest {
 public static void main(String[] args) {
 SimpleRemoteControl remote = new SimpleRemoteControl();
 Light light = new Light();
 GarageDoor garageDoor = new GarageDoor();
 LightOnCommand lightOn = new LightOnCommand(light);
 GarageDoorOpenCommand garageOpen = 
 new GarageDoorOpenCommand(garageDoor);
 remote.setCommand(lightOn);
 remote.buttonWasPressed();
 remote.setCommand(garageOpen);
 remote.buttonWasPressed();
 }
}
Возьми в руку карандаш
234 глава 6
Определение паттерна Команда
Паттерн Команда инкапсулирует запрос в виде 
объекта, делая возможной параметризацию клиентских объектов с другими запросами, организацию очереди или регистрацию запросов, а также поддержку отмены операций.
Итак, мы неплохо провели время в кафе Объектвиля, частично реализовали API пульта, а попутно составили довольно ясное представление о том, как организовано взаимодействие классов и объектов в паттерне Команда. Теперь 
мы определим паттерн Команда и разберемся с подробностями.
Начнем с официального определения:
Объект команды инкапсулирует запрос посредством привязки набора операций к конкретному получателю. Для этого 
информация об операции и получателе «упаковывается» 
в объекте с единственным методом execute(). При вызове 
метод execute() выполняет операцию с данным получателем. Внешние объекты не знают, какие именно операции 
выполняются и с каким получателем, они знают только, что 
при вызове метода execute() их запрос будет выполнен.
Мы уже рассмотрели пару примеров параметризации объектов в командах. В кафе Официантка параметризовалась разными заказами. В упрощенном примере с пультом ячейка 
сначала связывалась с командой включения света, а потом 
эта команда заменялась командой открытия двери гаража. 
Для ячейки пульта (как и для Официантки) совершенно неважно, какой объект команды с ней связан (при условии, 
что он реализует необходимый интерфейс команды).
С использованием команд для реализации очередей и регистрации, а также поддержки отмены мы пока не сталкивались. Не 
беспокойтесь, это весьма тривиальные расширения базового паттерна Команда. А разобравшись с основной схемой 
паттерна, вы легко освоите паттерн Метакоманда — механизм создания макропоследовательностей для выполнения 
серий команд.
Команда
execute() {
 receiver.action();
}
Получатель
action()
Инкапсулированный 
запрос.
LightOnCommand
execute()
Ячейка пульта
GarageDoorOpen
execute()
CeilingFanHigh
execute() StereoOff
execute()
Инициатор (например, 
ячейка пульта) может 
быть параметризован 
для разных запросов.
определение паттерна команда
паттерн команда
дальше   235
Связывает операции 
с Получателем. Инициатор выдает запрос, вызывая метод execute(), 
а ConcreteCommand выполняет его, активизируя 
операции Получателя.
Умеет выполнять 
операции, необходимые для выполнения 
запроса.
Объявляет интерфейс, общий для всех 
команд. Как вы уже знаете, для активизации команды вызывается метод execute(). 
Также обратите внимание на метод 
undo() — мы рассмотрим его позднее 
в этой главе.
Отвечает за создание ConcreteCommand 
и назначение Receiver.
Определение паттерна Команда: диаграмма классов
Хранит команду 
и в определенный момент отдает запрос 
на ее выполнение, вызывая метод execute().
Invoker <<interface>>
Command
execute()
undo()
action()
Receiver
Client
ConcreteCommand
execute()
undo()
public void execute() {
 receiver.action()
}
Метод execute 
активизирует 
операции с получателем, необходимые для выполнения запроса.
Каким образом архитектура паттерна Команда способствует отделению инициатора 
от получателя запроса? 
setCommand()
Мозговой
штурм
236 глава 6
Мэри: С чего начнем?
Сью: Как и в примере с SimpleRemote, нам понадобится механизм связывания команд с ячейками. В нашем случае имеются семь ячеек с кнопками «вкл» и «выкл». Таким образом, 
назначение команд будет выглядеть примерно так:
onCommands[0] = onCommand;
offCommands[0] = offCommand;
Кажется, теперь я довольно 
хорошо понимаю паттерн Команда. 
Джо, спасибо за дельный совет —
этот проект прославит
нашу фирму!
и так далее для каждого из семи командных слотов.
Мэри: А как пульт будет отличать освещение в гостиной от 
освещения на кухне?
Сью: Никак, в этом-то и дело! Пульт не знает ничего, кроме того, что при нажатии кнопки необходимо вызвать 
execute() для соответствующего объекта команды.
Мэри: Да, это понятно, но я говорю о реализации. Как 
нам убедиться, что активизируемые с пульта объекты будут 
включать и выключать правильные устройства?
Сью: При создании команд, связываемых с пультом, мы создаем разные команды для осветительных систем в гостиной 
и на кухне. Напомню, что получатель запроса определяется 
в команде, в которой он инкапсулируется. Таким образом, 
в момент нажатия кнопки совершенно неважно, к какой осветительной системе он относится (все необходимое происходит автоматически сразу же после вызова execute()).
Мэри: Кажется, поняла. Давай займемся программированием. Думаю, все прояснится само собой!
Сью: Отличная идея. Давай попробуем...
с чего начнем?
паттерн команда
дальше   237
CeilingFanOff
execute()
LightOnCommand
execute()
GarageDoorOpen
execute()
CeilingFanHigh
execute()
StereoOff
execute()
GarageDoorClose
execute()
LightOffCommand
execute()
LightOnCommand
execute()
LightOffCommand
execute()
StereoOnForC
execute() D
К другим ячейкам 
мы вернемся чуть 
позже.
Связывание команд с ячейками
Мы собираемся связать каждую ячейку пульта с командой. Таким образом, пульту отводится роль инициатора. При нажатии кнопки вызывается метод execute() соответствующей команды, что приводит 
к выполнению операции с получателем (осветительной системой, кондиционером и т. д.).
(1) Каждая ячейка связывается с командой.
(2) При нажатии кнопки вызывается метод execute() соответствующей команды.
Stereo
 off()
 on()
(3) Метод execute() выполняет операции с получателем. Инициатор
В нашем коде к имени каждой 
команды присоединяется суф
фикс «Command», но к
-
сожалению, в печатной версии нам 
не хватило места для неко
торых команд.
-
238 глава 6
public class RemoteControl {
 Command[] onCommands;
 Command[] offCommands;
 public RemoteControl() {
 onCommands = new Command[7];
 offCommands = new Command[7];
 Command noCommand = new NoCommand();
 for (int i = 0; i < 7; i++) {
 onCommands[i] = noCommand;
 offCommands[i] = noCommand;
 }
 }
 
 public void setCommand(int slot, Command onCommand, Command offCommand) {
 onCommands[slot] = onCommand;
 offCommands[slot] = offCommand;
 }
 public void onButtonWasPushed(int slot) {
 onCommands[slot].execute();
 }
 public void offButtonWasPushed(int slot) {
 offCommands[slot].execute();
 }
 
 
 public String toString() {
 StringBuffer stringBuff = new StringBuffer();
 stringBuff.append("\n------ Remote Control -------\n");
 for (int i = 0; i < onCommands.length; i++) {
 stringBuff.append("[slot " + i + "] " + onCommands[i].getClass().getName()
 + " " + offCommands[i].getClass().getName() + "\n");
 }
 return stringBuff.toString();
 }
}
Конструктор создает экземпляры команд и инициализирует массивы 
onCommands и offCommands.
В этой версии пульт будет поддерживать все семь команд «вкл/выкл», 
которые будут храниться в соответствующих массивах.
Метод setCommand() получает ячейку и команды включения/выключения 
для этой ячейки. Команды сохраняются в массивах для последующего 
использования.
При нажатии кнопки «вкл» 
или «выкл» пульт вызывает 
соответствующий метод: 
onButtonWasPushed()
или offButtonWasPushed().
Переопределяемый метод toString() выводит все 
ячейки с соответствующими командами. Мы 
воспользуемся им при тестировании пульта.
Реализация пульта
реализация пульта
паттерн команда
дальше   239
public class LightOffCommand implements Command {
 Light light;
 public LightOffCommand(Light light) {
 this.light = light;
 }
 public void execute() {
 light.off();
 }
}
Реализация команд
Мы уже поэкспериментировали с реализацией команды LightOnCommand для версии SimpleRemoteControl. Готовый код будет отлично работать и в новой версии. Реализация команд выключения выглядит практически так же:
Команда LightOffCommand 
почти неотличима от 
LightOnCommand, если не считать того, что получатель 
связывается с другой операцией: 
методом off().
Попробуем что-то более интересное. Как насчет команд включения/
выключения для стереосистемы? С выключением все просто: объект 
Stereo связывается с методом off() команды StereoOffCommand. С включением дело обстоит сложнее. Предположим, мы хотим написать команду StereoOnWithCDCommand...
Stereo
on()
off()
setCd()
setDvd()
setRadio()
setVolume()
public class StereoOnWithCDCommand implements Command {
 Stereo stereo;
 public StereoOnWithCDCommand(Stereo stereo) {
 this.stereo = stereo;
 }
 public void execute() {
 stereo.on();
 stereo.setCD();
 stereo.setVolume(11);
 }
}
По аналогии 
с LightOnCommand передается экзепляр стереосистемы, который сохраняется в локальной 
переменной экземпляра.
Для выполнения этого запроса необходимо вызвать три операции со стереосистемой: включить ее, установить режим воспроизведения CD 
и установить громкость на уровне 11. Почему 
именно 11?.. Но ведь 11 лучше 10, верно?
Пока неплохо. Просмотрите остальные классы устройств. Несомненно, 
к этому моменту вы сможете самостоятельно реализовать остальные 
классы команд.
240 глава 6
Проверяем пульт в деле
public class RemoteLoader {
 public static void main(String[] args) {
 RemoteControl remoteControl = new RemoteControl();
 Light livingRoomLight = new Light("Living Room");
 Light kitchenLight = new Light("Kitchen");
 CeilingFan ceilingFan= new CeilingFan("Living Room");
 GarageDoor garageDoor = new GarageDoor("");
 Stereo stereo = new Stereo("Living Room");
 
 LightOnCommand livingRoomLightOn = 
 new LightOnCommand(livingRoomLight);
 LightOffCommand livingRoomLightOff = 
 new LightOffCommand(livingRoomLight);
 LightOnCommand kitchenLightOn = 
 new LightOnCommand(kitchenLight);
 LightOffCommand kitchenLightOff = 
 new LightOffCommand(kitchenLight);
 
 CeilingFanOnCommand ceilingFanOn = 
 new CeilingFanOnCommand(ceilingFan);
 CeilingFanOffCommand ceilingFanOff = 
 new CeilingFanOffCommand(ceilingFan);
 GarageDoorUpCommand garageDoorUp =
 new GarageDoorUpCommand(garageDoor);
 GarageDoorDownCommand garageDoorDown =
 new GarageDoorDownCommand(garageDoor);
 StereoOnWithCDCommand stereoOnWithCD =
 new StereoOnWithCDCommand(stereo);
 StereoOffCommand stereoOff =
 new StereoOffCommand(stereo);
Программирование пульта практически завершено, остается лишь провести тестирование и написать документацию с описанием API. Это 
должно произвести впечатление на заказчика, не правда ли? Нам удалось 
разработать архитектуру, гибкую и простую в сопровождении, для которой фирмы-разработчики в будущем смогут легко создавать новые классы устройств.
Пора переходить к тестированию кода! 
Создание всех 
устройств.
Создание команд для 
управления освещением.
Создание команд для 
управления потолочным 
вентилятором.
Создание команд для 
управления дверью гаража.
Создание команд для управления стереосистемой.
тестирование пульта
паттерн команда
дальше   241
File Edit Window Help CommandsGetThingsDone
% java RemoteLoader
------ Remote Control -------
[slot 0] LightOnCommand LightOffCommand
[slot 1] LightOnCommand LightOffCommand
[slot 2] CeilingFanOnCommand CeilingFanOffCommand
[slot 3] StereoOnWithCDCommand StereoOffCommand
[slot 4] NoCommand NoCommand
[slot 5] NoCommand NoCommand
[slot 6] NoCommand NoCommand
Living Room light is on
Living Room light is off
Kitchen light is on
Kitchen light is off
Living Room ceiling fan is on high
Living Room ceiling fan is off
Living Room stereo is on
Living Room stereo is set for CD input
Living Room Stereo volume set to 11
Living Room stereo is off
%
 remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);
 remoteControl.setCommand(1, kitchenLightOn, kitchenLightOff);
 remoteControl.setCommand(2, ceilingFanOn, ceilingFanOff);
 remoteControl.setCommand(3, stereoOnWithCD, stereoOff);
 
 System.out.println(remoteControl);
 remoteControl.onButtonWasPushed(0);
 remoteControl.offButtonWasPushed(0);
 remoteControl.onButtonWasPushed(1);
 remoteControl.offButtonWasPushed(1);
 remoteControl.onButtonWasPushed(2);
 remoteControl.offButtonWasPushed(2);
 remoteControl.onButtonWasPushed(3);
 remoteControl.offButtonWasPushed(3);
 }
}
Готовые 
команды 
связываются 
с ячейками 
пульта.
Метод toString() выводит список 
ячеек и связанных с ними команд. 
(Заметим, что метод toString() 
будет вызываться автоматически, 
поэтому нам не придется вызывать toString() явно.)
Пульт готов к проверке! 
Перебираем все ячейки
и для каждой ячейки имитируем нажатие кнопок «вкл» 
и «выкл».
Проверяем результаты тестирования...
Вкл Выкл
Наши команды работают! Стоит напомнить, 
что результаты выполнения команд программируются во внешних классах устройств. 
Например, при включении освещения соответствующий класс выводит сообщение «Living 
Room light is on».
242 глава 6
Постойте-ка, а что это 
за команда NoCommand, 
которая связывается с ячейками 
с 4-й по 6-ю? Кто-то пытается 
смухлевать?
Верно подмечено. Мы действительно немного схитрили: нам не хотелось, чтобы код пульта проверял наличие команды при каждом 
обращении к ячейке. Например, в методе onButtonWasPushed() 
нам понадобится код следующего вида:
 public void onButtonWasPushed(int slot) {
 if (onCommands[slot] != null) {
 onCommands[slot].execute();
 }
 }
Что же делать? Реализовать команду, которая не делает ничего!
public class NoCommand implements Command {
 public void execute() { }
}
В конструкторе RemoteControl с каждой ячейкой связывается объект NoCommand по умолчанию, и мы знаем, что в каждой ячейке 
всегда присутствует допустимая команда.
 Command noCommand = new NoCommand();
 for (int i = 0; i < 7; i++) {
 onCommands[i] = noCommand;
 offCommands[i] = noCommand;
 }
В результатах тестового запуска мы видим ячейки, которые не 
были связаны с командой, если не считать команды по умолчанию 
NoCommand, назначенной при создании RemoteControl.
Объект NoCommand является примером пустого (null) объекта. Пустые объекты 
применяются тогда, когда вернуть «полноценный» объект невозможно, но вам хочется избавить клиента от необходимости проверять null-ссылки. Так, в  нашем 
примере при отсутствии полноценного объекта, который можно было бы связать 
с ячейкой пульта, используется суррогатный объект NoCommand с фиктивным методом execute.
Пустые объекты используются во многих паттернах проектирования, а некоторые 
авторы даже считают их самостоятельным паттерном.
объект null
Заслуженный 
помощник
паттернов
Заслуженный 
помощник 
паттернов
паттерн команда
дальше   243
Пора писать документацию...
Архитектура API пульта для фирмы Home Automation or Bust, Inc.
Вашему вниманию предлагается следующая архитектура и интерфейс прикладного программирования для пульта 
управления домашними электронными устройствами. Мы постарались сделать код пульта как можно более простым, чтобы с появлением новых классов в него не приходилось вносить изменения. Для логической изоляции класса пульта от классов устройств был применен паттерн Команда. Мы полагаем, что это приведет как к сокращению 
затрат на производство пультов, так и к значительному удешевлению сопровождения системы.
Общая схема архитектуры представлена на следующей диаграмме классов:
Каждая операция, активизируемая нажатием кнопки 
на пульте, реализуется простым объектом команды. 
Объект команды хранит ссылку на экземпляр класса 
устройства, реализующий метод execute, который 
вызывает один или несколько методов объекта. 
На диаграмме показаны два класса, реализующие 
операции включения и выключения света.
Классы устройств выполняют непосредственную работу по управлению 
домашней электроникой. В данном 
примере используется класс Light.
Все команды RemoteControl 
реализуют интерфейс 
команды, состоящий из единственного метода execute(). 
Команды инкапсулируют 
набор операций с классом 
устройства. Пульт активизирует эти операции вызовом 
метода execute().
Класс RemoteLoader создает 
объекты команд, связываемые с ячейками пульта. 
Каждый объект команды 
инкапсулирует запрос к некоторому устройству. 
RemoteControl
setCommand()
onButtonWasPushed()
offButtonWasPushed()
<<interface>>
Command
execute()
on()
off()
Light
RemoteLoader
LightOnCommand
execute() LightOffCommand
execute()
public void execute() {
 light.on()
} public void execute() {
 light.off()
}
onCommands
offCommands
Класс RemoteControl управляет набором 
объектов команд (по одному на кнопку). При 
нажатии кнопки вызывается соответствующий 
метод ButtonWasPushed(), который 
активизирует метод execute() объекта 
команды. Класс пульта больше ничего не 
знает о тех классах, к которым он обращается, 
так как он отделен от них объектом команды.
244 глава 6
представление команд лямбда-выражениями
public class RemoteLoader {
 public static void main(String[] args) {
 RemoteControl remoteControl = new RemoteControl();
 Light livingRoomLight = new Light("Living Room");
 ... 
 LightOnCommand livingRoomLightOn =
 new LightOnCommand(livingRoomLight);
 LightOffCommand livingRoomLightOff =
 new LightOffCommand(livingRoomLight);
 ...
 remoteControl.setCommand(0,() -> livingRoomLight.on(), 
 () -> livingRoomLight.off());
 ...
 }
}
Обновленный код с использованием лямбда-выражений:
Объект Light создается 
как обычно...
Хотите поднять свои навыки использования паттерна Команда на новый уровень? Лямбдавыражения Java позволяют пропустить этап создания конкретных объектов команд. С лямбдавыражениями вместо создания экземпляров конкретных объектов команд можно использовать 
объекты функций. Иначе говоря, объект функции может использоваться как команда. А заодно 
можно удалить все эти конкретные классы команд. 
Давайте посмотрим, как использовать лямбда-выражения в качестве команды для упрощения 
приведенного ранее кода:
После того как конкретные команды были заменены лямбда-выражениями, классы конкретных 
команд можно удалить (LightOnCommand, LightOffCommand, HottubOnCommand, 
HottubOffCommand и т. д.). Если сделать это для каждой конкретной команды, общее количество 
классов в приложении уменьшится с 22 до 9. 
Обратите внимание: это можно сделать только в том случае, если ваш интерфейс Command 
содержит один абстрактный метод. Стоит вам добавить второй абстрактный метод, и сокращенная 
запись с лямбда-выражением перестанет работать. 
Если вам нравится этот прием, обратитесь к своему любимому учебнику Java за дополнительной 
информацией о лямбда-выражениях.
Но конкретные 
объекты 
LightOnCommand 
и LightOffCommand 
можно удалить.
Вместо этого мы записываем конкретные 
команды как лямбда-выражения, которые 
выполняют ту же работу, которую 
выполнял метод execute() конкретной 
команды (то есть включение или 
выключение света). 
Позднее, когда вы нажмете 
одну из кнопок, пульт вызовет 
метод execute() объекта команды 
в позиции этой кнопки, которая 
представляется лямбда-выражением.
Для любознательных
паттерн команда
дальше   245
Мы отлично потрудились;
архитектура получилась 
замечательная... но вы не забыли 
об одной мелочи, которую требовал 
заказчик? КНОПКА 
ОТМЕНЫ!!!
public interface Command {
 public void execute();
 public void undo();
}
Стоп! Почти забыли... К счастью, с готовыми классами 
команд отмена реализуется довольно просто. Давайте 
шаг за шагом разберем, как реализовать поддержку отмены в нашем приложении...
Новый метод undo().
Что, собственно, нужно сделать?
Нужно реализовать поддержку отмены операций на пульте. Допустим, свет в гостиной выключен, а вы 
нажимаете на пульте кнопку включения. Разумеется, свет включается. Если теперь нажать кнопку отмены, то последняя операция отменяется — свет выключается. Прежде чем браться за более сложные 
примеры, разберемся с простейшим случаем:
1 Команды, поддерживающие механизм отмены, должны содержать метод undo(), парный по 
отношению к методу execute(). Метод undo() отменяет последнюю операцию, выполненную 
вызовом execute(). Таким образом, перед добавлением функциональности отмены в объекты 
команд необходимо добавить в интерфейс Command метод undo():
Как видите, ничего сложного.
Теперь мы перейдем к команде включения света и реализуем метод undo().
246 глава 6
реализация отмены
Впрочем, это еще не все; нужно включить в класс пульта механизм отслеживания последней нажатой кнопки, а также нажатия кнопки отмены.
Проще простого! На очереди команда LightOffCommand. На этот раз в методе undo() достаточно вызвать метод on() объекта Light.
public class LightOffCommand implements Command {
 Light light;
 public LightOffCommand(Light light) {
 this.light = light;
 }
 public void execute() {
 light.off();
 }
 public void undo() {
 light.on();
 }
}
Метод undo() снова включает выключенный свет!
public class LightOnCommand implements Command {
 Light light;
 public LightOnCommand(Light light) {
 this.light = light;
 }
 public void execute() {
 light.on();
 }
 public void undo() {
 light.off();
 }
}
execute() включает свет, 
поэтому undo() просто 
выключает его.
2 Начнем с класса LightOnCommand: если был вызван метод execute() класса LightOnCommand, значит, последним вызывался метод on(). Чтобы отменить его последствия, 
метод undo() вызывает противоположный метод off().
паттерн команда
дальше   247
3
public class RemoteControlWithUndo {
 Command[] onCommands;
 Command[] offCommands;
 Command undoCommand;
 public RemoteControlWithUndo() {
 onCommands = new Command[7];
 offCommands = new Command[7];
 Command noCommand = new NoCommand();
 for(int i=0;i<7;i++) {
 onCommands[i] = noCommand;
 offCommands[i] = noCommand;
 }
 undoCommand = noCommand;
 }
 
 public void setCommand(int slot, Command onCommand, Command offCommand) {
 onCommands[slot] = onCommand;
 offCommands[slot] = offCommand;
 }
 public void onButtonWasPushed(int slot) {
 onCommands[slot].execute();
 undoCommand = onCommands[slot];
 }
 public void offButtonWasPushed(int slot) {
 offCommands[slot].execute();
 undoCommand = offCommands[slot];
 }
 public void undoButtonWasPushed() {
 undoCommand.undo();
 }
 
 public String toString() {
 // Код toString...
 }
}
Для поддержки отмены достаточно внести в класс RemoteControl несколько незначительных изменений. Мы добавим новую переменную экземпляра для отслеживания последней команды. Далее при нажатии кнопки отмены мы обращаемся к этой команде и вызываем ее метод undo().
Переменная для хранения последней выполненной команды.
В переменную undoCommand 
изначально также заносится 
объект NoCommand, чтобы 
при нажатии кнопки отмены 
ранее любых других кнопок 
ничего не происходило.
При нажатии кнопки мы 
сначала читаем команду 
и выполняем ее, а затем сохраняем ссылку на нее в переменной undoCommand. 
При нажатии кнопки отмены мы 
вызываем метод undo() команды, хранящейся в переменной 
undoCommand. Вызов отменяет 
операцию последней выполненной 
команды.
Обновить для добавления 
undoCommand.
248 глава 6
тестирование отмены
public class RemoteLoader {
 public static void main(String[] args) {
 RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();
 Light livingRoomLight = new Light("Living Room");
 LightOnCommand livingRoomLightOn = 
 new LightOnCommand(livingRoomLight);
 LightOffCommand livingRoomLightOff = 
 new LightOffCommand(livingRoomLight);
 remoteControl.setCommand(0, livingRoomLightOn, livingRoomLightOff);
 remoteControl.onButtonWasPushed(0);
 remoteControl.offButtonWasPushed(0);
 System.out.println(remoteControl);
 remoteControl.undoButtonWasPushed();
 remoteControl.offButtonWasPushed(0);
 remoteControl.onButtonWasPushed(0);
 System.out.println(remoteControl);
 remoteControl.undoButtonWasPushed();
 }
}
Пора протестировать кнопку отмены!
Создание объекта Light и новых 
команд с поддержкой отмены.
Команды размещаются в ячейке 0.
Результаты тестирования...
Слегка переработаем тестовую программу, чтобы в ней тестировалась новая функция отмены:
Включение, выключение и отмена.
Выключение, включение и снова 
отмена.
File Edit Window Help UndoCommandsDefyEntropy
% java RemoteLoader
Light is on
Light is off
------ Remote Control -------
[slot 0] LightOnCommand LightOffCommand
[slot 1] NoCommand NoCommand
[slot 2] NoCommand NoCommand
[slot 3] NoCommand NoCommand
[slot 4] NoCommand NoCommand
[slot 5] NoCommand NoCommand
[slot 6] NoCommand NoCommand
[undo] LightOffCommand
Light is on
Light is off
Light is on
------ Remote Control -------
[slot 0] LightOnCommand LightOffCommand
[slot 1] NoCommand NoCommand
[slot 2] NoCommand NoCommand
[slot 3] NoCommand NoCommand
[slot 4] NoCommand NoCommand
[slot 5] NoCommand NoCommand
[slot 6] NoCommand NoCommand
[undo] LightOnCommand
Light is off
Отмена... Метод undo() объекта LightOffCommand снова 
включает свет.
Команды управления освещением.
Включение и выключение.
Теперь в undo хранится
LightOffCommand — последняя
выполненная команда.
Выключаем и снова включаем.
Нажата кнопка отмены,
свет снова выключается.
В undo хранится последняя
выполненная команда LightOnCommand.
паттерн команда
дальше   249
Реализация отмены с состоянием
Реализация отмены для освещения была поучительной, но слишком тривиальной. Как правило, реализация отмены требует управления состоянием. 
Рассмотрим более интересный пример — команды управления вентилятором. У вентилятора имеется несколько скоростей вращения, которые задаются соответствующими методами.
Исходный код класса CeilingFan:
public class CeilingFan {
 public static final int HIGH = 3;
 public static final int MEDIUM = 2;
 public static final int LOW = 1;
 public static final int OFF = 0;
 String location;
 int speed;
 public CeilingFan(String location) {
 this.location = location;
 speed = OFF;
 }
 
 public void high() {
 speed = HIGH;
 // Высокая скорость
 } 
 public void medium() {
 speed = MEDIUM;
 // Средняя скорость
 }
 public void low() {
 speed = LOW;
 // Низкая скорость
 }
 
 public void off() {
 speed = OFF;
 // Выключение вентилятора
 }
 
 public int getSpeed() {
 return speed;
 }
}
CeilingFan
high()
medium()
low()
off()
getSpeed()
Класс CeilingFan имеет локальную 
переменную состояния, представляющую скорость вращения вентилятора.
Методы, задающие скорость вращения вентилятора.
Для получения текущей 
скорости используется 
метод getSpeed().
Выходит, для 
правильной реализации 
отмены нам придется 
учитывать предыдущую 
скорость вращения...
250 глава 6
добавление отмены для вентилятора
public class CeilingFanHighCommand implements Command {
 CeilingFan ceilingFan;
 int prevSpeed;
 
 public CeilingFanHighCommand(CeilingFan ceilingFan) {
 this.ceilingFan = ceilingFan;
 }
 public void execute() {
 prevSpeed = ceilingFan.getSpeed();
 ceilingFan.high();
 }
 public void undo() {
 if (prevSpeed == CeilingFan.HIGH) {
 ceilingFan.high();
 } else if (prevSpeed == CeilingFan.MEDIUM) {
 ceilingFan.medium();
 } else if (prevSpeed == CeilingFan.LOW) {
 ceilingFan.low();
 } else if (prevSpeed == CeilingFan.OFF) {
 ceilingFan.off();
 }
 }
}
Давайте включим поддержку отмены в команды управления вентилятором. Для этого необходимо запомнить предыдущую скорость 
вращения вентилятора и восстановить сохраненную скорость при 
вызове метода undo(). Код команды CeilingFanHighCommand:
Добавляем локальную переменную состояния для хранения предыдущей скорости.
В методе execute перед изменением скорости ее предыдущее значение сохраняется
для возможной отмены.
В методе undo() вентилятор возвращается к 
предыдущей скорости.
Реализация отмены в командах управления вентилятором
Осталось написать еще три команды управления вентилятором: для низкой скорости, для средней скорости и для выключения. Вы представляете себе их возможную реализацию?
Мозговой
штурм
паттерн команда
дальше   251
Переходим к тестированию вентилятора
Пора загрузить в пульт новые команды управления 
вентилятором. Кнопка «вкл» ячейки 0 будет включать вентилятор на средней скорости, а кнопка 
«вкл» ячейки 1 включает его на высокой скорости. 
Обе соответствующие кнопки «выкл» просто выключают вентилятор.
Код тестового сценария:
public class RemoteLoader {
 public static void main(String[] args) {
 RemoteControlWithUndo remoteControl = new RemoteControlWithUndo();
 CeilingFan ceilingFan = new CeilingFan("Living Room");
 
 CeilingFanMediumCommand ceilingFanMedium = 
 new CeilingFanMediumCommand(ceilingFan);
 CeilingFanHighCommand ceilingFanHigh = 
 new CeilingFanHighCommand(ceilingFan);
 CeilingFanOffCommand ceilingFanOff = 
 new CeilingFanOffCommand(ceilingFan);
 
 remoteControl.setCommand(0, ceilingFanMedium, ceilingFanOff);
 remoteControl.setCommand(1, ceilingFanHigh, ceilingFanOff);
 
 remoteControl.onButtonWasPushed(0);
 remoteControl.offButtonWasPushed(0);
 System.out.println(remoteControl);
 remoteControl.undoButtonWasPushed();
 
 remoteControl.onButtonWasPushed(1);
 System.out.println(remoteControl);
 remoteControl.undoButtonWasPushed();
 }
}
Создаем экземпляры трех 
команд: для высокой скорости, 
для средней скорости
и для выключения.
Команды включения средней и 
высокой скорости помещаются 
в ячейки 0 и 1.
Сначала включаем среднюю скорость.
Потом выключаем вентилятор.
Отмена! Снова должна включиться 
средняя скорость.
На этот раз выбираем высокую.
И снова отмена; должна вернуться 
средняя скорость.
252 глава 6
тестирование вентилятора
% java RemoteLoader
Living Room ceiling fan is on medium
Living Room ceiling fan is off
------ Remote Control -------
[slot 0] CeilingFanMediumCommand CeilingFanOffCommand
[slot 1] CeilingFanHighCommand CeilingFanOffCommand
[slot 2] NoCommand NoCommand 
[slot 3] NoCommand NoCommand
[slot 4] NoCommand NoCommand
[slot 5] NoCommand NoCommand
[slot 6] NoCommand NoCommand
[undo] CeilingFanOffCommand
Living Room ceiling fan is on medium
Living Room ceiling fan is on high
------ Remote Control -------
[slot 0] CeilingFanMediumCommand CeilingFanOffCommand
[slot 1] CeilingFanHighCommand CeilingFanOffCommand
[slot 2] NoCommand NoCommand
[slot 3] NoCommand NoCommand
[slot 4] NoCommand NoCommand
[slot 5] NoCommand NoCommand
[slot 6] NoCommand NoCommand
[undo] CeilingFanHighCommand
Living Room ceiling fan is on medium
%
File Edit Window Help UndoThis!
Еще одна отмена — вентилятор 
возвращается к средней скорости.
Включаем на средней скорости, потом выключаем.
...в undo хранится последняя выполненная 
команда CeilingFanOffCommand.
Команды в пульте...
Отмена последней команды
возвращает среднюю скорость.
Включаем на высокой скорости.
Объект последней 
выполненной команды.
Тестирование...
Берем пульт, загружаем команды — и нажимаем кнопки!
паттерн команда
дальше   253
На каждом пульте должен быть Режим Вечеринки!
Hottub
on()
off()
circulate()
jetsOn()
jetsOff()
setTemperature()
Stereo
on()
off()
setCd()
setDvd()
setRadio()
setVolume()
Light
on()
off()
dim()
on()
off()
setInputChannel()
setVolume()
TV
public class MacroCommand implements Command {
 Command[] commands;
 public MacroCommand(Command[] commands) {
 this.commands = commands;
 }
 public void execute() {
 for (int i = 0; i < commands.length; i++) {
 commands[i].execute();
 }
 }
}
Мэри предлагает создать новую разновидность команд, которая может 
выполнять другие команды... причем 
сразу несколько! Классная идея, верно?
Берем массив команд и сохраняем 
их в объекте MacroCommand.
При выполнении макрокоманды все эти
команды будут последовательно выполнены.
Какой прок от пульта, если он не способен нажатием одной кнопки выключить свет, включить телевизор и стереосистему, запустить воспроизведение 
DVD и наполнить джакузи?
Хм-м, нашему пульту 
для каждого устройства 
нужна отдельная кнопка. 
Похоже, ничего не выйдет. Погоди, 
Сью, не торопись. 
Я думаю, это можно 
сделать без изменения кода 
пульта!
254 глава 6
создание макрокоманд
Использование макрокоманд
Чтобы использовать макрокоманды в своем приложении, выполняем следующие действия:
1 Сначала создается набор команд, которые войдут в макропоследовательность:
Light light = new Light("Living Room");
TV tv = new TV("Living Room");
Stereo stereo = new Stereo("Living Room");
Hottub hottub = new Hottub();
LightOnCommand lightOn = new LightOnCommand(light);
StereoOnCommand stereoOn = new StereoOnCommand(stereo);
TVOnCommand tvOn = new TVOnCommand(tv);
HottubOnCommand hottubOn = new HottubOnCommand(hottub);
Нам понадобятся команды для кнопок выключения. Запишите их в этом поле:
Затем мы создаем два массива (включение и выключение), которые 
заполняются соответствующими командами:
Command[] partyOn = { lightOn, stereoOn, tvOn, hottubOn};
Command[] partyOff = { lightOff, stereoOff, tvOff, hottubOff};
 
MacroCommand partyOnMacro = new MacroCommand(partyOn);
MacroCommand partyOffMacro = new MacroCommand(partyOff);
3 Затем макрокоманда, как обычно, связывается с кнопкой:
remoteControl.setCommand(0, partyOnMacro, partyOffMacro);
Создание объектов устройств 
(свет, телевизор, стерео, 
джакузи).
Создание команд 
включения для 
управления этими 
устройствами.
Массивы команд 
включения и выключения:
...и два объекта 
макрокоманд, 
в которых они 
хранятся.
Макрокоманда связывается с кнопкой, 
как и любая другая 
команда.
2
Возьми в руку карандаш
паттерн команда
дальше   255
File Edit Window Help You Can’tBeatABabka
% java RemoteLoader
------ Remote Control -------
[slot 0] MacroCommand MacroCommand
[slot 1] NoCommand NoCommand
[slot 2] NoCommand NoCommand
[slot 3] NoCommand NoCommand
[slot 4] NoCommand NoCommand
[slot 5] NoCommand NoCommand
[slot 6] NoCommand NoCommand
[undo] NoCommand
--- Pushing Macro On---
Light is on
Living Room stereo is on
Living Room TV is on
Living Room TV channel is set for DVD
Hottub is heating to a steaming 104 degrees
Hottub is bubbling!
--- Pushing Macro Off---
Light is off
Living Room stereo is off
Living Room TV is off
Hottub is cooling to 98 degrees
Две макрокоманды.
Все вложенные команды выполняются при вызове макрокоманды 
включения...
...и выключения. Похоже, 
все работает.
4 А дальше нажимаем кнопки и смотрим, как работает макрокоманда.
System.out.println(remoteControl);
System.out.println("--- Pushing Macro On---");
remoteControl.onButtonWasPushed(0);
System.out.println("--- Pushing Macro Off---");
remoteControl.offButtonWasPushed(0);
Результат
256 глава 6
упражнение с макрокомандами
В: Так ли необходим получатель? Почему объект команды не может реализовать всю логику execute()?
О: Как правило, мы стремимся к созданию «простых» объектов команд, которые 
просто инициируют операцию с получателем. Однако встречаются и «умные» объекты команд, которые реализуют б?ольшую 
часть логики, необходимой для выполнения запроса. Конечно, такой способ тоже 
возможен, однако следует помнить об 
ухудшении логической изоляции между 
инициатором и получателем, а также о 
потере возможности параметризации 
команд с разными получателями.
В: Как реализовать историю отмены? 
Иначе говоря, я хочу, чтобы кнопку отмены можно было нажимать многократно.
О: Отличный вопрос! На самом деле 
это несложно; вместо ссылки на последнюю выполненную команду необходимо 
хранить стек предыдущих команд. При нажатии кнопки отмены инициатор извлекает верхнюю команду из стека и вызывает 
метод undo().
В: Нельзя ли реализовать макрокоманду как обычную команду — создать объект PartyCommand и разместить вызовы других команд в методе 
execute() объекта PartyCommand?
О: Можно, но фактически это означает жестко фиксированную реализацию PartyCommand. Зачем идти на это? 
Макрокоманды позволяют динамически 
выбирать наборы команд, включаемые 
в PartyCommand, и обладают большей 
гибкостью. В общем случае решения на 
основе макрокоманд более элегантны 
и требуют меньшего объема кода.
Нашей макрокоманде не хватает только функциональности отмены. При нажатии кнопки отмены после вызова макрокоманды необходимо отменить 
действие всех вложенных команд. Перед вами код макрокоманды; напишите 
реализацию метода undo():
public class MacroCommand implements Command {
 Command[] commands;
 public MacroCommand(Command[] commands) {
 this.commands = commands;
 }
 public void execute() {
 for (int i = 0; i < commands.length; i++) {
 commands[i].execute();
 }
 }
 public void undo() {
 }
}
часто Задаваемые вопросы
Упражнение
паттерн команда
дальше   257
Расширенные возможности паттерна Команда: очереди запросов
Классы очередей заданий полностью отделены от 
объектов, выполняющих обработку. В один момент 
времени поток может выполнять финансовые расчеты, а в другой — загружать данные по сети. Для объекта очереди это совершенно неважно, он просто загружает объекты команд и вызывает их методы execute(). 
Если очередь реализована на базе паттерна Команда, 
метод execute() помещенного в нее объекта будет вызван при наличии свободного потока.
Поток
RayTrace
execute()
CompilerTask
Поток
Потоки, выполняющие 
задания
Объекты, реализующие
интерфейс команд, помещаются в очередь.
Программные потоки последовательно извлекают команды из очереди и вызывают их метод execute(), 
после чего возвращаются за следующим объектом команды.
Эффективный механизм 
организации вычислений 
в фиксированном наборе 
потоков.
FinancialComputation Command
CompilerTask
execute()
DownloadRequest
execute()
CompilerTask
execute()
NetworkFetch
execute()
FinancialComputation Command
execute()
RayTrace
execute()
DistributedComptation
execute()
execute()
DownloadRequest
CompilerTask
execute()
NetworkFetch
execute()
FinancialComputation Comman
execute() d
RayTrace
execute()
execute()
Очередь заданий
Команды 
Как использовать такую очередь 
в веб-сервере? Какие еще 
практические применения вы 
могли бы предложить?
execute()
DownloadRequest
Поток
execute()
NetworkFetch
Поток
execute()
Команды обеспечивают механизм инкапсуляции 
«вычислительных блоков» (получатель + набор операций) и передачи их в виде полноценных объектов. 
При этом сами операции могут инициироваться намного позже создания объекта команды в клиентском приложении (и даже в другом программном 
потоке). Этот сценарий находит применение во 
многих полезных приложениях: планировщиках, пулах потоков, очередях заданий и т. д.
Возьмем очередь заданий: команды ставятся в конец 
очереди, обслуживаемой группой программных потоков. Потоки извлекают команду из очереди, вызывают ее метод execute(), ожидают завершения 
вызова, уничтожают текущий объект команды и переходят к следующей команде.
Мозговой
штурм
258 глава 6
регистрация запросов
load
Семантика некоторых приложений требует регистрации всех выполняемых операций и возможности восстановления после сбоя. В паттерне 
Команда для поддержки этой семантики используются два метода: store() 
и load(). В языке Java в реализации этих методов можно воспользоваться 
средствами сериализации объектов, но тогда приходится учитывать стандартные ограничения сериализации.
Как работает регистрация? Информация о выполняемых командах сохраняется в журнальном файле на диске. Если в работе приложения происходит сбой, мы снова загружаем объекты команд и последовательно выполняем их методы execute().
В нашем примере с пультом такая регистрация не имеет смысла, однако 
многие приложения работают с большими структурами данных, которые невозможно быстро сохранить при каждом изменении. Регистрация позволяет сохранить все операции от последней контрольной точки 
и в случае возникновения сбоя применить их к контрольной точке. Скажем, в электронной таблице разумно реализовать восстановление посредством регистрации операций (вместо того, чтобы записывать копию 
таблицы на диск при каждом изменении). В более сложном приложении 
возможно транзакционное расширение механизма регистрации, чтобы 
все операции либо закреплялись как единое целое, либо одновременно 
отменялись.
<<interface>>
Command
execute()
undo()
store()
load()
При выполнении каждой 
команды информация 
о ней сохраняется на диске.
Расширенные возможности паттерна Команда: регистрация запросов
CommandOne
execute()
store()
load()
CommandTwo
execute()
store()
load()
CommandThree
execute()
store()
load()
store
store
store
1. execute()
Инициатор
2. execute()
3. execute()
CommandOne
execute()
store()
load()
CommandTwo
execute()
store()
load()
CommandThree
execute()
store()
load()
load
load
Инициато
3. execute()
р
2. execute()
1. execute()
Сбой!
Восстановление
После сбоя системы объекты заново 
загружаются и выполняются в правильном порядке.
Два метода для поддержки регистрации.
паттерн команда
дальше   259
Паттерн Команда в реальном мире
Помните маленькое приложение из главы 2?
public class SwingObserverExample {
	 // Подготовка ...
 JButton button = new JButton("Should I do it?");
 button.addActionListener(new AngelListener());
 button.addActionListener(new DevilListener());
 // Определение свойств фрейма
 }
 class AngelListener implements ActionListener {
 public void actionPerformed(ActionEvent event) {
 System.out.println("Don't do it, you might regret it!");
 }
 }
 class DevilListener implements ActionListener {
 public void actionPerformed(ActionEvent event) {
 System.out.println("Come on, do it!");
 }
 }
}
В этой главе мы упоминали о том, что библиотека Swing в Java полна наблюдателей в виде объектов ActionListener, которые прослушивают события компонентов 
пользовательского интерфейса.
Оказывается, ActionListener — не только 
интерфейс наблюдателя, он также является интерфейсом команды, и наши классы 
AngelListener и DevilListener — не только 
наблюдатели, но и конкретные команды. 
Получается, что в одном примере задействованы сразу два паттерна!
Ниже приведен код (по крайней мере самые важные его части) 
маленького приложения из главы 2. Попробуйте определить, кто в этом 
коде является клиентом, кто — командой, кто — вызывающим объектом, 
а кто — получателем.
%java SwingObserverExample
Come on, do it!
Don’t do it, you might regret it!
%
Лаконичный интерфейс.
Совет ангела
Совет дьявола
File Edit Window Help HeMadeMeDoIt
Данные, выводимые при 
нажатии кнопки.
Возьми в руку карандаш
260 глава 6
инструментарий проектирования
Стратегия — определяет 
семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет 
модифицировать алг
Новые инструменты
Ваш инструментарий постепенно 
расширяется! В этой главе он пополнился 
паттерном, позволяющим инкапсулировать 
методы в объектах Команды: сохранять 
их, передавать и активизировать по мере 
необходимости.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне 
интерфейсов.
Стремитесь к слабой связанности взаимодействующих 
объектов.
Классы должны быть открыты 
для расширения, но закрыты 
для изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Observer — defines a oneto-many dependency between 
objects so that when one 
object changes state, all its 
dependents are notified and 
updated automatically
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a flexible 
alternative to subclassing for 
extending functionality.
Abstract Factory — Provide 
an interface for creating 
families of related or depedent 
objects without specifying their 
concrete classes.
Factory Method — Define 
an interface for creating an 
object, but let subclasses decide 
which class to instantiate. 
Factory Method lets a class 
defer instantiation to 
the subclasses.
  Паттерн Команда отделяет объект, выдающий запросы, от объекта, который умеет эти запросы 
выполнять.
  Объект команды инкапсулирует 
получателя с операцией (или 
набором операций).
  Инициатор вызывает метод 
execute() объекта команды, что 
приводит к выполнению соответ- ствующих операций с получате- лем.
  Возможна параметризация 
инициаторов командами (даже 
динамическая во время выполнения).
  Команды могут поддерживать 
механизм отмены, восстанавливающий объект в состоянии 
до последнего вызова метода 
execute().
  Макрокоманды — простое 
расширение паттерна Команда, позволяющее выполнять 
цепочки из нескольких команд. 
В них также легко реализуется 
механизм отмены.
  На практике нередко встречаются «умные» объекты команд, 
которые реализуют запрос самостоятельно вместо его делегирования получателю.
  Команды также могут использоваться для реализации систем 
регистрации команд и поддержки транзакций.
Если вам потребуется отделить объект, выдающий запросы, 
от объектов, которые 
умеют эти запросы выполнять, — используйте 
паттерн Команда.
Принципы
Паттерны
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Одиночка гарантирует, что 
класс имеет только один экземпляр, и предоставляет 
глобальную точку доступа к 
этому экземпляру.
Команда — инкапсулирует запрос в виде объекта, 
делая возможной параметризацию клиентских 
объектов с другими запросами, организацию очереди 
или регистрацию запросов, 
а также поддержку отмены операций.
паттерн команда
дальше   261
public class SwingObserverExample {
	 // Подготовка ...
 JButton button = new JButton("Should I do it?");
 button.addActionListener(new AngelListener());
 button.addActionListener(new DevilListener());
 // Определение свойств фрейма
 }
 class AngelListener implements ActionListener {
 public void actionPerformed(ActionEvent event) {
 System.out.println("Don't do it, you might regret it!");
 }
 }
 class DevilListener implements ActionListener {
 public void actionPerformed(ActionEvent event) {
 System.out.println("Come on, do it!");
 }
 }
}
Ниже приведен код (по крайней мере самые важные его части) 
маленького приложения из главы 2. Попробуйте определить, кто в этом 
коде является клиентом, кто — командой, кто — вызывающим объектом, 
а кто — получателем.
Клиентом является класс, который настраивает компоненты Swing и назначает команды 
(AngelListener и DevilListener) 
в вызывающем объекте (Button).
Кнопка является вызывающим объектом. Кнопка вызывает методы 
actionPerformed() (аналог execute()) 
в командах (ActionListener) при нажатии кнопки.
ActionListener – интерфейс 
Command: он содержит один 
метод actionPerformed(), 
который, как и execute(), выполняется при активизации 
команды.
AngelListener и DevilListener — 
наши конкретные команды. 
Они реализуют интерфейс 
команды (в данном случае 
ActionListener).
Получателем в данном примере является 
объект System. Помните, что вызов команды 
приводит к выполнению действий с получа
телем. В типичном приложении Swing это 
-
привело бы к вызову действий в других компонентах пользовательского интерфейса. 
Возьми в руку карандаш
 Решение
262 глава 6
ответы к упражнениям
Сопоставьте роли и методы из примера с кафе с соответствующими ролями и методами паттерна Команда.
Кафе Паттерн Команда
Официантка
Повар
orderUp()
Заказ
Посетитель
takeOrder()
Команда
execute()
Клиент
Инициатор
Получатель
setCommand()
Кто и что делает?
решение
паттерн команда
дальше   263
File Edit Window Help GreenEggs&Ham
%java RemoteControlTest
Light is on
Garage Door is Open
%
public class GarageDoorOpenCommand implements Command {
 GarageDoor garageDoor;
 public GarageDoorOpenCommand(GarageDoor garageDoor) {
 this.garageDoor = garageDoor;
 }
 public void execute() {
 garageDoor.up();
 }
}
Возьми в руку карандаш
 Решение
Код класса GarageDoorOpenCommand:
264 глава 6
ответы к упражнениям
Напишите реализацию метода undo() для макрокоманды.
public class MacroCommand implements Command {
 Command[] commands;
 public MacroCommand(Command[] commands) {
 this.commands = commands;
 }
 public void execute() {
 for (int i = 0; i < commands.length; i++) {
 commands[i].execute();
 }
 }
 public void undo() {
 for (int i = 0; i < commands.length; i––) {
 commands[i].undo();
 }
 }
}
Команды для кнопок выключения.
LightOffCommand lightOff = new LightOffCommand(light);
StereoOffCommand stereoOff = new StereoOffCommand(stereo);
TVOffCommand tvOff = new TVOffCommand(tv);
HottubOffCommand hottubOff = new HottubOffCommand(hottub);
Возьми в руку карандаш
 Решение
В этой главе мы займемся всякими невозможными трюками — будем затыкать круглые дырки квадратными пробками. Невозможно, 
скажете вы? Только не с паттернами проектирования. Помните паттерн Декоратор? Мы «упаковывали» объекты, чтобы расширить их возможности. А в этой 
главе мы займемся упаковкой объектов с другой целью: чтобы имитировать 
интерфейс, которым они в действительности не обладают. Для чего? Чтобы 
адаптировать архитектуру, рассчитанную на один интерфейс, для класса, реализующего другой интерфейс. Но и это еще не все; попутно будет описан другой 
паттерн, в котором объекты упаковываются для упрощения их интерфейса.
Умение
 приспосабливаться
7 Паттерны Адаптер и Фасад
А ведь читатели думают, 
что мы смотрим скачки 
на ипподроме, а не сидим 
в фотостудии...
Такая у нас 
профессия — 
изображать то, чего 
на самом деле нет...
Разве это 
не должен быть 
футбольный матч? В этом пальто 
я совсем другой 
человек!
266 глава 7
Адаптер включается между вилкой ноутбука и розеткой европейского стандарта, он адаптирует европейскую розетку, чтобы вы могли подключить к ней свое 
устройство и пользоваться им. Или можно сказать иначе: адаптер приводит интерфейс розетки к интерфейсу, на который рассчитан ваш ноутбук.
Некоторые адаптеры предельно просты — они изменяют только форму разъема, 
чтобы она соответствовала форме вилки, а напряжение остается неизменным. 
Другие адаптеры устроены сложнее, им приходится повышать или понижать 
напряжение в соответствии с потребностями устройства.
С реальным миром понятно, а как насчет объектно-ориентированных адаптеров? Они играют ту же роль, что и их прототипы в реальном мире: адаптеры 
преобразуют интерфейс к тому виду, на который рассчитан клиент.
Адаптеры вокруг нас
Вы без труда поймете концепцию ОО-адаптера, потому что в реальном мире вокруг 
нас полно адаптеров. Простейший пример: вам доводилось подключать компьютер, 
выпущенный в США, к европейскому источнику питания? Скорее всего, вам понадобился адаптер питания...
Европейская розетка
Стандартная вилка Адаптер
Европейская розетка 
имеет один интерфейс 
подключения устройств.
Американский ноутбук 
рассчитан на другой 
интерфейс.
Адаптер обеспечивает 
согласование этих двух 
интерфейсов.
Какие еще реально 
существующие 
адаптеры вам 
известны?
адаптеры повсюду
паттерны адаптер и фасад
дальше   267
Допустим, у вас имеется готовая программная система, которая должна работать с новой библиотекой 
внешних классов, однако поставщик библиотеки слегка изменил их интерфейс:
Объектно-ориентированные адаптеры
Решать проблему за счет изменения существующего кода не хочется (а код внешних классов недоступен). Что же делать? Напишите класс, который адаптирует интерфейс новых классов к нужному вам.
Адаптер играет роль посредника: он получает запросы от клиента и преобразует их в запросы, понятные внешним классам.
Адаптер Внешний 
класс
Существующая 
система
Внешний 
класс
Существующая 
система
Интерфейс классов отличается от 
того, для которого был написан ваш код. 
Система работать не будет!
Адаптер реализует 
интерфейс, на который 
рассчитаны ваши классы... ...а также взаимодействует 
с внешними классами через их 
интерфейс для выполнения запросов.
Код не изменяется. Код
не изменяется. Новый код.
А вы можете предложить 
решение, при котором вам 
ВООБЩЕ не придется писать 
дополнительный код для 
интеграции с новыми внешними 
классами? Конечно, можно 
заставить разработчика 
предоставить адаптерный класс.
Внешний 
класс
Существующая Адаптер
система
268 глава 7
Если кто-то ходит как утка и крякает как утка, то это
 и есть может быть утка индюшка с утиным адаптером...
public interface Duck {
 public void quack();
 public void fly();
}
public class MallardDuck implements Duck {
 public void quack() {
 System.out.println("Quack");
 }
 public void fly() {
 System.out.println("I’m flying");
 }
}
Пора взглянуть на адаптеры в действии. Еще не забыли наших 
уток из главы 1? Давайте рассмотрим слегка упрощенную версию 
интерфейсов и классов иерархии Duck:
На этот раз 
утки реализуют 
интерфейс Duck.
Конкретный подкласс Duck:
Простейшие реализации 
выводят сообщения 
о выполняемой операции.
А теперь познакомьтесь с новым обитателем птичника:
public interface Turkey {
 public void gobble();
 public void fly();
}
Индюшки не крякают (у них нет 
метода quack())...
...но могут летать, хотя 
и недалеко.
адаптер для индюшки
дальше   269
паттерн адаптер
public class WildTurkey implements Turkey {
 public void gobble() {
 System.out.println("Gobble gobble");
 }
 public void fly() {
 System.out.println("I’m flying a short 
distance");
 }
}
Конкретная реализация 
обобщенного класса Turkey: 
как и класс MallardDuck, 
она просто выводит 
описания своих действий.
Допустим, нам не хватает объектов Duck и мы хотим использовать вместо них объекты 
Turkey. Разумеется, простая замена невозможна, потому что эти объекты обладают разными интерфейсами.
Создаем адаптер:
public class TurkeyAdapter implements Duck {
 Turkey turkey;
 public TurkeyAdapter(Turkey turkey) {
 this.turkey = turkey;
 }
 
 public void quack() {
 turkey.gobble();
 }
 
 public void fly() {
 for(int i=0; i < 5; i++) {
 turkey.fly();
 }
 }
}
Прежде всего необходимо реализовать 
интерфейс того типа, на который 
рассчитан ваш клиент.
Затем следует получить ссылку на 
адаптируемый объект; обычно это 
делается в конструкторе.
Адаптер должен реализовать все методы 
интерфейса. Преобразование quack() между 
классами выполняется просто — реализация 
вызывает gobble().
Хотя метод fly() входит в оба 
интерфейса, индюшка не умеет 
летать на дальние расстояния. Чтобы 
установить соответствие между 
этими методами, мы вызываем 
метод fly() класса Turkey пять раз.
Код под увеличительным стеклом
270 глава 7
Тестирование адаптера
public class DuckTestDrive {
 public static void main(String[] args) {
 Duck duck = new MallardDuck();
 Turkey turkey = new WildTurkey();
 Duck turkeyAdapter = new TurkeyAdapter(turkey);
 
 System.out.println("The Turkey says...");
 turkey.gobble();
 turkey.fly();
 System.out.println("\nThe Duck says...");
 testDuck(duck);
 
 System.out.println("\nThe TurkeyAdapter says...");
 testDuck(turkeyAdapter);
 }
 static void testDuck(Duck duck) {
 duck.quack();
 duck.fly();
 }
}
File Edit Window Help Don’tForgetToDuck
%java DuckTestDrive
The Turkey says...
Gobble gobble
I’m flying a short distance
The Duck says...
Quack
I’m flying
The TurkeyAdapter says...
Gobble gobble
I’m flying a short distance
I’m flying a short distance
I’m flying a short distance
I’m flying a short distance
I’m flying a short distance
Создаем объект Duck...
Нам понадобится тестовый код для проверки адаптера:
и объект Turkey.
Затем Turkey упаковывается в TurkeyAdapter и начинает выглядеть как Duck.
Теперь вызываем метод 
testDuck(), который получает объект Duck.
Тестируем методы Turkey.
Важный тест: выдаем Turkey 
за Duck...
Методы Duck.
Методы Turkey.
Адаптер вызывает gobble() 
при вызове quack() и выводит 
повторные сообщения при 
вызове fly(). Метод testDuck() 
и не подозревает, что он 
имеет дело с объектом Turkey, 
замаскированным под Duck!
Метод testDuck() получает объект Duck и вызывает его методы 
quack() и fly().
Тест
тестирование адаптера
паттерны адаптер и фасад
дальше   271
Адаптируемый объект
Клиент
Адаптер
request() translatedRequest()
Как работает паттерн Адаптер
Реализация клиента использует 
целевой интерфейс.
Адаптер реализует целевой 
интерфейс и хранит ссылку 
на экземпляр адаптируемого 
объекта.
целевой интерфейс
интерфейс 
адаптируемого 
объекта
Теперь, когда вы примерно представляете себе, как работает Адаптер, мы 
вернемся на пару шагов назад и снова рассмотрим все компоненты. 
Клиент обращается с запросом к адаптеру, вызывая 
его метод через целевой интерфейс.
Адаптер преобразует запрос в один или несколько 
вызовов к адаптируемому объекту (в интерфейсе последнего).
Клиент получает результаты вызова, даже не подозревая о преобразованиях, выполненных адаптером.
Как клиент работает с адаптером:
1
2
3
Обратите внимание: Клиент полностью изолирован 
от Адаптера, они ничего не 
знают друг о друге.
TurkeyAdapter реализует 
целевой интерфейс Duck.
Адаптируется 
интерфейс Turkey.
272 глава 7
Предположим, вам также понадобился адаптер для преобразования Duck в Turkey — 
назовем его DuckAdapter. Напишите код этого класса:
Как вы решили проблему с методом fly() (ведь, как известно, утки летают 
дальше, чем индюшки)? Наше решение приведено в конце главы. Сможете ли вы 
предложить что-нибудь лучше?
В: Какой объем работы должен выполняться адаптером? Ведь чтобы 
реализовать большой целевой интерфейс, придется ОСНОВАТЕЛЬНО потрудиться.
О: Сложность реализации адаптера 
пропорциональна размеру целевого интерфейса. Но подумайте, какой у вас выбор. Конечно, можно переработать все 
клиентские вызовы к интерфейсу, но это 
потребует огромной работы по анализу 
и изменению кода. А можно предоставить 
всего один класс, который инкапсулирует 
все изменения.
В: Всегда ли адаптер преобразует 
один и только один класс?
О: Задача паттерна Адаптер — преобразовать один интерфейс к другому 
интерфейсу. Хотя в большинстве наших 
примеров используется один адаптируемый объект, на практике адаптеру иногда 
приходится хранить два и более объекта, 
необходимых для реализации целевого 
интерфейса.
Проблема связана с другим паттерном — 
Фасадом; эти два паттерна часто путают. 
Мы еще вернемся к этой теме позднее 
в этой главе.
В: А если система состоит из новых 
и старых компонентов? Старые компоненты рассчитаны на старый интерфейс, 
но мы уже создали новые компоненты 
для нового интерфейса? Попеременное 
использование адаптеров и неадаптированных интерфейсов создаст путаницу. 
Разве не лучше переписать старый код 
и забыть об адаптере?
О: Не обязательно. Вы всегда можете 
создать Двойной адаптер с поддержкой 
обоих интерфейсов. Реализуйте оба интерфейса, чтобы адаптер мог использоваться в обеих ролях.
определение паттерна адаптер
часто Задаваемые вопросы
Возьми в руку карандаш
дальше   273
паттерн адаптер
Определение паттерна Адаптер
Паттерн Адаптер преобразует интерфейс класса к другому интерфейсу, на который рассчитан клиент. Адаптер обеспечивает 
совместную работу классов, невозможную в обычных условиях 
из-за несовместимости интерфейсов.
Довольно уток и индюшек; ниже приведено официальное определение паттерна Адаптер.
Итак, чтобы использовать клиент с несовместимым интерфейсом, мы создаем адаптер, 
который выполняет преобразование. Таким образом клиент отделяется от реализованного интерфейса; и если мы ожидаем, что интерфейс будет изменяться со временем, 
адаптер инкапсулирует эти изменения, чтобы клиент не приходилось изменять каждый раз, когда ему потребуется работать с новым интерфейсом. 
Мы проанализировали поведение паттерна в ходе выполнения; давайте также рассмотрим его диаграмму классов:
specificRequest()
Клиент
Adaptee
request()
<<interface>>
Target
request()
Adapter
В паттерне Адаптер проявляются многие признаки качественного ОО-проектирования: 
обратите внимание на использование композиции для «упаковки» адаптируемого объекта в измененный интерфейс. Дополнительное преимущество такого решения заключается в том, что адаптер будет работать с любым субклассом адаптируемого объекта. 
Также обратите внимание на то, что паттерн связывает клиент с интерфейсом, а не 
с реализацией; мы можем использовать несколько адаптеров, каждый из которых выполняет преобразование для своего набора классов. Кроме того, новые реализации могут добавляться позднее. Единственным ограничением является лишь их соответствие 
интерфейсу Target.
Адаптер реализует 
интерфейс Target.
Адаптер связывается 
с адаптируемым объектом 
посредством композиции.
Все запросы 
делегируются 
адаптируемому классу.
Клиент видит только 
интерфейс Target.
274 глава 7
Адаптеры объектов и классов
Мы привели формальное определение паттерна, но еще не рассказали всей истории. 
На самом деле существует две разновидности адаптеров: адаптеры объектов и адаптеры 
классов. В этой главе рассматриваются адаптеры объектов, а на диаграмме классов на 
предыдущей странице также изображен адаптер объектов.
Что же такое адаптер классов и почему мы о них ничего не рассказывали? Потому что 
для их реализации необходимо множественное наследование, запрещенное в языке 
Java. Но это не означает, что необходимость в адаптерах классов не возникнет, когда 
вы будете работать на языке с множественным наследованием! Рассмотрим диаграмму 
классов с множественным наследованием.
specificRequest()
request()
Adapter
Клиент Adaptee
request()
Target
Вместо применения 
композиции Adapter
субклассирует Adaptee
и Target.
Знакомая картина? Все верно: единственное различие заключается в том, что с адаптером классов мы субклассируем Target и Adaptee, а с адаптером объектов для передачи 
запросов Adaptee используется механизм композиции. 
Адаптеры объектов и адаптеры классов используют два 
различных способа адаптации (композиция и наследование). 
Как эти различия в реализации влияют на гибкость адаптера?
адаптеры объектов и классов
Мозговой
штурм
паттерны адаптер и фасад
дальше   275
Ваша задача — разместить магниты с утками и индюшками на частях диаграммы, описывающих роль этих птиц в приведенном ранее примере. (Постарайтесь не возвращаться на несколько страниц назад.) Добавьте свои 
примечания по поводу того, как работает эта схема.
Магниты с утками
specificRequest()
Клиент
Adaptee
request()
<<interface>>
Target
request()
Adapter
specificRequest()
request()
Adapter
Клиент Adaptee
request()
Target
Адаптер классов
Адаптер объектов
Разместите на диаграм
ме классов; укажите, какие 
-
части диаграммы представ
ляют уток (Duck), а какие
-
индюшек (Turkey).
— 
276 глава 7
specificRequest()
request()
Adapter
Клиент Adaptee
request()
Target
specificRequest()
Клиент
Adaptee
request()
<<interface>>
Target
request()
Adapter
Адаптер классов
Адаптер объектов
Клиент полагает, что он работает с Duck.
Клиент вызывает методы 
класса Duck.
Чтобы класс Turkey мог отвечать 
на запросы Duck, Adapter расширяет ОБА класса (Duck и Turkey).
Класс Turkey содержит 
другие методы, но паттерн 
Адаптер позволяет 
преобразовать вызовы 
методов Duck в вызовы 
методов Turkey.
Адаптер классов использует 
множественное наследование, 
поэтому в Java такое 
решение невозможно...
Как и в случае 
с адаптером 
классов, клиент 
вызывает
методы Duck.
Класс Turkey отличается от 
Duck по интерфейсу. Иначе говоря, 
Turkey не содержит метод quack() 
и т. д.
Adapter реализует 
интерфейс Duck, но 
при вызове метода он 
передает его Turkey.
Благодаря паттерну Адаптер Turkey получает вызовы 
клиента, обращенные к интерфейсу Duck.
Интерфейс Duck
Объект 
Turkey
Класс Duck Класс Turkey
ответы к упражнениям
Магниты с утками.
Решение
Клиент считает, 
что он с Duck 
работает.
паттерны адаптер и фасад
дальше   277
Адаптер объектов и Адаптер классов 
встречаются лицом к лицу.
Адаптер объектов Адаптер классов
Использование композиции дает мне немалые 
преимущества. Я могу адаптировать не только 
отдельный класс, но и все его субклассы.
Верно, у меня с этим проблемы — я рассчитан 
на один адаптируемый класс, но зато мне не 
приходится реализовать его заново. А если потребуется, я могу переопределить поведение 
адаптируемого класса, ведь речь идет о простом 
субклассировании.
Гибкость — возможно. Эффективность? Нет. 
Для моей работы необходим лишь один экземпляр меня самого, а лишние экземпляры адаптера и адаптируемого класса не нужны.
В моих краях рекомендуется отдавать предпочтение композиции перед наследованием; возможно, получается на несколько строк больше, 
но мой код просто делегирует вызовы адаптируемому объекту. Мы выбираем гибкость. 
Кого волнует один крошечный объект? Ты позволяешь быстро переопределить метод, но поведение, которое я добавляю в код адаптера, работает с моим адаптируемым классом и всеми его 
субклассами.
Подумаешь, нужно включить объект субкласса 
посредством композиции, и все заработает.
Хочешь увидеть лишние хлопоты? Взгляни 
в зеркало!
Да, а если в субклассе Adaptee добавится новое 
поведение? Что тогда?
Так ведь лишние хлопоты...
Беседа у камина
278 глава 7
Практическое применение адаптеров
Опытные Java-программисты помнят, что 
ранние реализации коллекций (Vector, 
Stack, Hashtable и некоторые другие) реализовали метод elements(), который 
возвращал перечислитель (Enumeration). 
Интерфейс Enumeration позволяет перебирать элементы коллекции, не зная 
конкретного механизма управления ими 
в коллекции. 
<<interface>>
Enumeration
hasMoreElements()
nextElement()
Проверяет, остались ли 
элементы в коллекции.
Возвращает следующий 
элемент в коллекции.
В обновленных классах коллекций используется более современный интерфейс итераторов. Как и перечисления, итераторы 
позволяют перебирать элементы коллекций, но также обладают возможностью 
удаления элементов.
<<interface>
Iterator
hasNext()
next()
remove()
Аналог метода 
hasMoreElements() из 
интерфейса Enumeration. 
Метод проверяет, не 
достигнут ли последний 
элемент коллекции.
Возвращает следующий 
элемент в коллекции.
Удаляет элемент из 
коллекции.
Нам часто приходится иметь дело со старым кодом, поддерживающим интерфейс Enumerator, хотя хотелось бы, 
чтобы новый код работал только с итераторами. Похоже, 
придется создать для него адаптер.
Перечисления
Итераторы
Использование перечислителей с кодом, рассчитанным на использование итераторов
Рассмотрим несколько реальных примеров применения простых адаптеров (по крайней мере более серьезных, чем превращение утки в индюшку)...
Перечисление имеет простой 
интерфейс.
практическое применение адаптеров
паттерны адаптер и фасад
дальше   279
Адаптация перечислителя к итератору
<<interface>>
Enumeration
hasMoreElements()
nextElement()
<<interface>>
Iterator
hasNext()
next()
remove()
Эти два метода напрямую 
соответствуют методам hasNext() 
и next() интерфейса Iterator.
Но что делать с методом remove() 
интерфейса Interator? В интерфейсе 
Enumeration ничего похожего нет.
Итак, наш адаптер должен реализовать целевой интерфейс, и адаптируемый объект должен включаться в него посредством композиции. Методы hasNext() и next() имеют четкие 
аналоги в адаптируемом и целевом интерфейсе: их можно просто передавать напрямую. 
Но что делать с методом remove()? Задумайтесь на минуту (ответ приведен на следующей 
странице). А пока посмотрим диаграмму классов:
<<interface>>
Enumeration
hasMoreElements()
nextElement()
<<interface>>
Iterator
hasNext()
next()
remove()
Новый код работает 
с итераторами, хотя 
в основу реализации 
заложен интерфейс 
Enumeration.
EnumerationIterator
hasNext()
next()
remove()
EnumerationIterator — 
это адаптер.
Адаптируемый 
класс реализует 
интерфейс 
Enumeration.
Перечислители в старом 
коде воспринимаются 
новым кодом как 
итераторы.
Целевой 
интерфейс
Интерфейс 
адаптируемого 
объекта.
Проектирование адаптера
Сначала мы сопоставляем два интерфейса, чтобы понять, как их методы соответствуют 
друг другу. Иначе говоря, нужно понять, какой метод адаптируемого объекта следует использовать при вызове того или иного метода целевого интерфейса.
280 глава 7
public class EnumerationIterator implements Iterator<Object> {
 Enumeration<?> enumeration;
 public EnumerationIterator(Enumeration<?> enumeration) {
 this.enumeration = enumeration;
 }
 public boolean hasNext() {
 return enumeration.hasMoreElements();
 }
 
 public Object next() {
 return enumeration.nextElement();
 }
 
 public void remove() {
 throw new UnsupportedOperationException();
 }
}
Чтобы адаптер воспринимался 
клиентским кодом как итератор, 
он реализует интерфейс Iterator.
Адаптируемый объект 
Enumeration сохраняется 
в переменной (композиция).
Метод hasNext() интерфейса Iterator 
передает управление методу 
hasMoreElements() интерфейса 
Enumeration...
...а метод next() интерфейса Iterator 
передает управление методу 
nextElement().
К сожалению, поддержать 
метод remove() 
интерфейса Iterator не 
удастся, поэтому мы 
просто выдаем исключение.
Мы знаем, что Enumeration не поддерживает метод remove() — этот интерфейс 
обеспечивает доступ «только для чтения». В адаптере невозможно реализовать 
полнофункциональный метод remove(); фактически лучшее, что мы можем сделать, — это выдать исключение времени выполнения. К счастью, проектировщики интерфейса Iterator предвидели такую необходимость и определили метод 
remove() так, чтобы он поддерживал UnsupportedOperationException.
В данной ситуации адаптер не идеален; клиенты должны следить за потенциальными исключениями. Но если клиент будет достаточно осторожен, а адаптер — хорошо документирован, такое решение вполне приемлемо.
Проблема с методом remove()
Программирование адаптера EnumerationIterator
Простой, но эффективный код адаптера для старых классов, которые продолжают 
работать с перечислителями:
адаптер еnumerationIterator
паттерны адаптер и фасад
дальше   281
Хотя язык Java развивается в направлении итераторов, осталось немало старого кода, который зависит от интерфейса Enumeration, 
поэтому адаптер, преобразующий Iterator в Enumeration, будет 
весьма полезен. 
Напишите обратный адаптер, который преобразует Iterator 
в Enumeration. Для тестирования своего кода используйте класс 
ArrayList. Он поддерживает интерфейс Iterator, но не поддерживает Enumeration.
Некоторые адаптеры питания не ограничиваются простым изменением интерфейса — 
они добавляют такие функции, как защита от скачков напряжения, индикаторы и т. д.
Если вам потребуется реализовать такие функции, какой паттерн вы выберете?
Мозговой
штурм
Упражнение
282 глава 7
Паттерн Декоратор и паттерн Адаптер 
обсуждают свои различия.
Декоратор Адаптер
Я — важная персона. Если при проектировании 
используется паттерн Декоратор, значит, в архитектуру добавляются новые обязанности или 
аспекты поведения.
Значит, вся слава достается вам, декораторам, 
а мы, адаптеры, сидим в канаве и выполняем 
всю грязную работу по преобразованию интерфейсов? Возможно, наша работа не так эффектна, но клиенты ценят нас за то, что мы упрощаем их жизнь.
Не стоит думать, что нам достается вся слава. 
Иногда я оказываюсь всего лишь очередным декоратором, который «упаковывается» в другие 
декораторы. Получая делегированный вызов 
метода, я не знаю, сколько декораторов уже приложило к нему руки и заметит ли кто-нибудь мою 
роль в обработке запроса.
Побывали бы вы адаптером, когда он сводит 
воедино несколько классов для получения 
нужного интерфейса... Это я понимаю. Но 
у нас есть поговорка: «Клиент со слабой связанностью — довольный клиент».
Тоже верно, но не думайте, что нам не приходится трудиться. Декорирование большого интерфейса требует весьма значительного объема 
кода.
А если адаптер хорошо справляется со своей работой, то клиент вообще не замечает его. Совершенно неблагодарная работа.
беседа у камина: декоратор и адаптер
Беседа у камина
паттерны адаптер и фасад
дальше   283
Но самое замечательное в нас, адаптерах, то, что 
мы позволяем клиентам использовать новые 
библиотеки без изменения кода; они просто полагаются на то, что мы выполним преобразования 
за них. Может, это и узкая специализация, но мы 
с ней хорошо справляемся.
Пожалуй, я соглашусь.
Декоратор Адаптер
Что ж, мы, декораторы, делаем примерно то 
же, но позволяем включать в классы новое поведение без изменения существующего кода. На мой 
взгляд, адаптер — всего лишь разновидность декоратора; в конце концов, вы, как и мы, просто 
инкапсулируете объекты.
Нет-нет, ничего подобного. Мы всегда преобразуем интерфейс внутреннего объекта, вы этого 
не делаете никогда. Я бы сказал, что декоратор 
является разновидностью адаптера, которая никогда не изменяет интерфейс!
Нет, мы расширяем поведение или обязанности 
объектов. Неправильно считать нас простой прокладкой.
Эй, ты кого назвал «простой прокладкой»? Долго ли ты протянешь, если тебе придется преобразовывать несколько интерфейсов?
Что ж, надо признать, на бумаге мы действительно немного похожи, но в своем предназначении мы очень далеки друг от друга.
284 глава 7
А теперь сменим тему...
В этой главе описан еще один паттерн.
Проведите стрелку от каждого паттерна к его предназначению:
Паттерн Предназначение
Декоратор
Адаптер
Фасад
Преобразует один интерфейс 
к другому
Не изменяет интерфейс, 
но добавляет новые 
обязанности
Упрощает интерфейс
Вы уже видели, как паттерн Адаптер преобразует интерфейс класса к другому интерфейсу, на который 
рассчитан ваш клиент. Также мы выяснили, что в Java эта задача решается «упаковкой» объекта, обладающего несовместимым интерфейсом, в объект, реализующий правильный интерфейс.
Наш следующий паттерн тоже изменяет интерфейс, но по другой причине: для его упрощения. Его 
название — Фасад — подобрано весьма удачно: паттерн скрывает все сложности внутреннего строения 
одного или нескольких классов за лаконичным, четко определенным фасадом.
кто и что делает?
Кто и что делает?
дальше   285
паттерн фасад
Amplifier
tuner
dvdPlayer
cdPlayer
on()
off()
setCd()
setDvd()
setStereoSound()
setSurroundSoud()
setTuner()
setVolume()
toString()
DvdPlayer
amplifier
on()
off()
eject()
pause()
play()
play()
setSurroundAudio()
setTwoChannelAudio()
stop()
CdPlayer
on()
off()
eject()
pause()
play()
play()
stop()
toString()
amplifier
Tuner
on()
off()
setAm()
setFm()
setFrequency()
toString()
amplifier
Screen
up()
down()
toString()
Projector
on()
off()
tvMode()
wideScreenMode()
toString()
dvdPlayer
PopcornPopper
on()
off()
pop()
toString()
TheaterLights
on()
off()
dim()
toString()
Прежде чем погружаться в подробности строения паттерна Фасад, давайте обратимся к модному нынче увлечению: построению домашнего 
кинотеатра для просмотра фильмов и сериалов. 
Вы изучили материал и собрали убойную систему с медиаплеером, проекционной видеосистемой, автоматизированным экраном, объемным 
звуком и даже машиной для приготовления попкорна.
Домашний кинотеатр
Вы провели целую неделю за прокладкой проводов, установкой 
проектора, подключением и настройкой аппаратуры. Теперь 
пора запустить систему и насладиться фильмом...
Много классов, много 
взаимодействий, много интерфейсов, которые нужно изучать 
и использовать.
286 глава 7
Выберите фильм, расслабьтесь и приготовьтесь встретиться с киноволшебством. Да, 
и еще одно... Чтобы посмотреть кино, нужно выполнить несколько операций:
Просмотр фильма (сложный способ)
Включить аппарат для попкорна.
Запустить приготовление попкорна.
Выключить свет.
Опустить экран.
Включить проектор.
Включить полноэкранный режим на проекторе.
Включить усилитель.
Выбрать на усилителе вход медиаплеера.
Включить на усилителе режим объемного звука.
Установить на усилителе среднюю громкость (5).
Включить медиаплеер.
Запустить фильм на воспроизведение.
12
11
10
9
8
7
6
5
4
3
2
1
13
Выбрать на проекторе вход медиаплеера.
как посмотреть фильм
Уже устал... А ведь 
всего-то включил всю 
аппаратуру!
дальше   287
паттерн фасад
Включить аппарат для попкорна, 
начать готовить попкорн...
Уменьшить яркость света до 10%...
Опустить экран...
Включить проектор и выбрать 
широкоэкранный режим для кино...
Включить усилитель, выбрать 
на нем медиаплеер, перевести 
в режим объемного звука 
и установить громкость 5...
Включить медиаплеер... 
и, НАКОНЕЦ, запустить фильм!
Рассмотрим те же операции в контексте классов и вызовов методов, 
необходимых для их выполнения:
Шесть разных классов!
Но это еще не все...
  Когда фильм закончится, как отключить всю аппаратуру? Не придется ли вам проделывать все заново в обратном порядке?
  А если вам захочется послушать радио, придется снова проделывать все операции?
  Если вы решите обновить свою систему, вероятно, вам придется изучать новую 
последовательность действий.
Что же делать? Очевидно, работать с домашним кинотеатром слишком сложно!
К счастью, паттерн Фасад способен избавить от лишних хлопот, чтобы мы просто получили удовольствие от просмотра...
popper.on();
popper.pop();
lights.dim(10);
screen.down();
projector.on();
projector.setInput(player);
projector.wideScreenMode();
amp.on();
amp.setStreamingPlayer(player);
amp.setSurroundSound();
amp.setVolume(5);
player.on();
player.play(movie);
288 глава 7
Фасад — именно то, что нам нужно: мы берем сложную подсистему и для 
упрощения работы с ней реализуем фасадный класс, который предоставляет общий, более удобный интерфейс. Не беспокойтесь: вся мощь 
сложной подсистемы остается в вашем распоряжении, но если вам нужен только упрощенный интерфейс, пользуйтесь Фасадом. 
Давайте посмотрим, как работает паттерн Фасад:
Свет, камера, фасад! 
watchMovie()
endMovie()
listenToRadio()
endRadio()
HomeTheaterFacade
TheaterLights
on()
off()
dim()
toString()
PopcornPopper
on()
off()
pop()
toString()
Screen
up()
down()
toString()
Tuner
on()
off()
setAm()
setFm()
setFrequency()
toString()
amplifier
Amplifier
tuner
Player
on()
off()
setStreamingPlayer()
setStereoSound()
setSurroundSoud()
setTuner()
setVolume()
toString()
Projector
on()
off()
tvMode()
wideScreenMode()
toString()
Player
StreamingPlayer
amplifier
on()
off()
pause()
play()
setSurroundAudio()
setTwoChannelAudio()
stop()
toString()
Мы создадим фасадный 
интерфейс для домашнего кинотеатра. Класс 
HomeTheaterFacade 
предоставляет простые методы, такие как 
watchMovie().
1
Фасад
Подсистема, которую упрощает 
паттерн Фасад.
on()
play()
Класс фасада рассматривает компоненты 
домашнего кинотеатра 
как подсистему и обращается с вызовами 
к этой подсистеме для 
реализации своего метода watchMovie().
2
свет камера фасад
дальше   289
паттерн фасад
watchMovie()
Клиентский код теперь обращается с вызовами к фасадному классу 
домашнего кинотеатра, а не к 
подсистеме. Таким образом, чтобы 
просмотреть фильм, мы вызываем 
всего один метод — watchMovie(), 
а он взаимодействует со светом, 
медиаплеером, проектором, усилителем, экраном и аппаратом для 
приготовления попкорна.
3
Клиент 
подсистемы 
фасада
Бывший президент 
школьного научного 
общества.
В паттерне Фасад подсистема 
остается открытой для непосредственного использования. Если вам 
понадобится расширенная функциональность классов подсистемы, 
обращайтесь к ним напрямую.
4
Но система должна 
остаться доступной 
и на низком уровне!
290 глава 7
В: Если фасад инкапсулирует классы подсистемы, как клиент сможет получить доступ к ним?
О: Фасады не «инкапсулируют» классы 
подсистемы, они всего лишь предоставляют упрощенный интерфейс к их функциям. 
Классы подсистемы остаются доступными 
для прямого использования со стороны 
клиентов, нуждающихся в более конкретных интерфейсах. Это одно из преимуществ паттерна Фасад: он предоставляет 
упрощенный интерфейс, оставляя доступ 
к полной функциональности подсистемы.
В: Добавляет ли фасад какую-либо 
функциональность или просто передает 
запросы подсистеме?
О: Фасад может «проявить сообразительность» в работе с подсистемой. 
Например, в случае с домашним кинотеатром он знает, что аппарат для попкорна 
нужно включить заранее.
В: Подсистема может иметь только 
один фасад?
О: Не обязательно. Паттерн позволяет 
создать для подсистемы любое количество фасадов.
В: Какими преимуществами обладает фасад, кроме упрощения интерфейса?
О: Паттерн Фасад также позволяет 
отделить клиентскую реализацию от конкретной подсистемы. Допустим, вы решили обновить свой домашний кинотеатр 
новыми компонентами с другим интерфейсом. Если клиентский код написан для 
работы с фасадом, а не с подсистемой, 
изменять его не придется — достаточно 
изменить фасад.
В: Выходит, различие между паттернами Адаптер и Фасад заключается 
в том, что адаптер инкапсулирует один 
класс, а фасад может представлять много классов?
О: Нет! Хотя в большинстве примеров 
адаптер адаптирует один класс, иногда 
приходится адаптировать несколько классов для формирования интерфейса, на 
который запрограммирован клиент. Различие между ними определяется не количеством «инкапсулируемых» классов, 
а целью. Целью паттерна Адаптер является изменение интерфейса и приведение его к тому виду, на который рассчитан 
клиент. Целью паттерна Фасад является 
упрощение интерфейса подсистемы.
Фасад не только 
упрощает интерфейс, но и обеспечивает логическую изоляцию 
клиента от подсистемы, состоящей 
из многих компонентов.
Фасад применяется для упрощения, 
а адаптер — для 
преобразования интерфейса 
к другой форме.
фасад vs адаптер
часто Задаваемые вопросы
дальше   291
паттерн фасад
Построение фасада для домашнего кинотеатра
Давайте по шагам разберем процесс построения фасада для домашнего 
кинотеатра. Прежде всего мы воспользуемся композицией, чтобы фасад имел доступ ко всем компонентам подсистемы:
В конструкторе фасада 
передаются ссылки 
на все компоненты. 
Фасад присваивает их 
соответствующим 
переменным экземпляра.
Композиция: компоненты 
подсистемы, которые мы 
собираемся использовать.
Сейчас мы займемся ими...
public class HomeTheaterFacade {
 Amplifier amp;
 Tuner tuner;
 StreamingPlayer player;
 Projector projector;
 TheaterLights lights;
 Screen screen;
 PopcornPopper popper;
 public HomeTheaterFacade(Amplifier amp, 
 Tuner tuner, 
 StreamingPlayer player; 
 Projector projector, 
 Screen screen,
 TheaterLights lights,
 PopcornPopper popper) {
 this.amp = amp;
 this.tuner = tuner;
 this.player = player;
 this.projector = projector;
 this.screen = screen;
 this.lights = lights;
 this.popper = popper;
 }
 // Другие методы
}
292 глава 7
Реализация упрощенного интерфейса
Настало время свести компоненты подсистемы в единый интерфейс.
Начнем с методов watchMovie() и endMovie():
Метод watchMovie() выполняет 
те же операции, которые ранее 
выполнялись нами вручную. Обратите 
внимание: выполнение каждой операции 
делегируется соответствующему 
компоненту подсистемы.
Метод endMovie() 
выключает всю 
аппаратуру за 
нас. И снова каждая 
операция делегируется 
соответствующему 
компоненту 
подсистемы.
Вспомните фасады, которые встречались вам в Java API. В каких областях вы предложили бы создать новые фасады?
реализация фасада
Мозговой
штурм
public void watchMovie(String movie) {
 System.out.println("Get ready to watch a movie...");
 popper.on();
 popper.pop();
 lights.dim(10);
 screen.down();
 projector.on();
 projector.wideScreenMode();
 amp.on();
 amp.setStreamingPlayer(player);
 amp.setSurroundSound();
 amp.setVolume(5);
 player.on();
 player.play(movie);
}
public void endMovie() {
 System.out.println("Shutting movie theater down...");
 popper.off();
 lights.on();
 screen.up();
 projector.off();
 amp.off();
 player.stop();
 player.off();
}
дальше   293
паттерн фасад
Сеанс начинается!
Просмотр фильма (простой способ)
public class HomeTheaterTestDrive {
 public static void main(String[] args) {
 // Создание экземпляров компонентов
 HomeTheaterFacade homeTheater = 
 new HomeTheaterFacade(amp, tuner, dvd, cd, 
 projector, screen, lights, popper);
 homeTheater.watchMovie("Raiders of the Lost Ark");
 homeTheater.endMovie();
 }
}
%java HomeTheaterTestDrive
Get ready to watch a movie...
Popcorn Popper on
Popcorn Popper popping popcorn!
Theater Ceiling Lights dimming to 10%
Theater Screen going down
Projector on
Projector in widescreen mode (16x9 aspect ratio)
Amplifier on
Amplifier setting Streaming player to Streaming Player
Amplifier surround sound on (5 speakers, 1 subwoofer)
Amplifier setting volume to 5
Streaming Player on
Streaming Player playing "Raiders of the Lost Ark"
Shutting movie theater down...
Popcorn Popper off
Theater Ceiling Lights on
Theater Screen going up
Projector off
Amplifier off
Streaming Player stopped "Raiders of the Lost Ark"
Streaming Player off
%
File Edit Window Help SnakesWhy’dItHaveToBeSnakes? 
Сначала мы создаем фасад 
со всеми компонентами 
подсистемы.
Упрощенный интерфейс используется 
для запуска и для прекращения 
просмотра.
Результат.
Вызов метода 
watchMovie() фасада 
выполняет всю
работу за нас...
...просмотр закончен, 
вызов endMovie() 
выключает 
аппаратуру.
Компоненты создаются прямо 
в ходе тестирования. Обычно клиент 
получает фасад, а не создает его.
294 глава 7
Определение паттерна Фасад
Паттерн Фасад предоставляет унифицированный интерфейс 
к группе интерфейсов подсистемы. Фасад определяет высокоуровневый интерфейс, упрощающий работу с подсистемой.
При использовании паттерна Фасад мы создаем класс, который упрощает и унифицирует набор более 
сложных классов, образующих некую подсистему. В отличие от многих других паттернов, Фасад относительно прост; в нем нет умопомрачительных абстракций, в которых приходится подолгу разбираться. Но от этого он не становится менее полезным; паттерн Фасад предотвращает появление сильных 
связей между клиентом и подсистемой и, как вы вскоре увидите, способствует соблюдению нового 
принципа объектно-ориентированного проектирования.
Но прежде чем переходить к новому принципу, мы рассмотрим официальное определение паттерна:
В этом определении нет ничего такого, чего бы вы не знали; самое важное, что нужно запомнить об 
этом паттерне, — это его предназначение. Определение четко и недвусмысленно говорит, что целью 
фасада является упрощение работы с подсистемой за счет использования упрощенного интерфейса. 
Это хорошо видно из диаграммы классов паттерна:
Клиент Facade
классы подсистемы
Унифицированный интерфейс, с которым 
проще работать.
Собственно, это всё; в вашем арсенале появился новый паттерн! А теперь можно и перейти к новому принципу ОО-проектирования. Будьте внимательны: он противоречит некоторым распространенным представлениям!
Сложная подсистема
Клиент, жизнь 
которого упрощает паттерн 
Фасад.
определение паттерна фасад
дальше   295
паттерн фасад
Принцип минимальной информированности
Принцип проектирования
Принцип минимальной информированности: общайтесь только 
с близкими друзьями.
Принцип минимальной информированности требует сократить взаимодействия между объектами до 
нескольких близких «друзей». Обычно он формулируется в следующем виде:
Что это означает на практике? Что при проектировании системы для любого объекта следует обратить 
особое внимание на количество классов, с которыми 
он взаимодействует, и не то, каким образом организовано это взаимодействие. 
Этот принцип препятствует созданию архитектур 
с большим количеством тесно связанных классов, 
в которых изменение в одной части системы каскадно распространяется в другие части. При формировании многочисленных зависимостей между классами система теряет гибкость и становится сложной 
для понимания, а затраты на ее сопровождение возрастают.
Со сколькими классами связан этот фрагмент 
кода?
 public float getTemp() {
 return station.getThermometer().getTemperature();
 }
Мозговой
штурм
296 глава 7
Эти правила запрещают вызывать 
методы для объектов, полученных 
в результате вызова других методов!
Под «компонентом» следует 
понимать любой объект, на 
который ссылается переменная 
экземпляра. Иначе говоря, речь 
идет об объекте, связанном 
отношением типа СОДЕРЖИТ.
Но как добиться этой цели? Принцип дает некоторые рекомендации. Возьмем произвольный объект; 
согласно принципу, из любого метода должны вызываться только методы, принадлежащие:
  самому объекту;
  объектам, переданным в параметрах метода;
  любому объекту, созданному внутри метода;
  любым компонентам объекта.
Ограничения кажутся вам слишком жесткими? Какой 
вред принесет вызов метода объекта, полученного 
в результате другого вызова? Дело в том, что он обращен к одной из подчастей другого объекта, а следовательно, увеличивает число объектов, о которых непосредственно «знает» текущий объект. В таких случаях 
принцип требует, чтобы объект выдавал этот запрос 
за нас (чтобы круг «друзей» оставался по возможности узким). Пример:
Как НЕ приобретать друзей и оказывать влияние на объекты
public float getTemp() {
 Thermometer thermometer = station.getThermometer();
 return thermometer.getTemperature();
}
Без 
принципа
public float getTemp() {
 return station.getTemperature();
}
С принципом
Здесь мы получаем объект 
Thermometer от station, а затем 
вызываем метод getTemperature() 
самостоятельно.
В класс Station включается метод, 
который обращается с запросом 
к Thermometer за нас. Тем самым 
сокращается количество классов, 
от которых зависит наш код.
принцип минимальной информированности
дальше   297
паттерн фасад
В: Существует похожий принцип, называемый «законом 
Деметры», — как они связаны?
О: Это два разных названия одного принципа. Мы предпочитаем термин «принцип минимальной информированности» по двум 
причинам: (1) он более интуитивен и (2) слово «закон» наводит 
на мысль о том, что этот принцип должен применяться всегда. 
Однако принципы следует применять только тогда, когда они 
приносят практическую пользу, а перед их применением следует 
учесть все факторы (абстракции/скорость, затраты памяти/времени и т. д.)
В: Есть ли недостатки у принципа минимальной информированности?
О: Да. Хотя принцип сокращает зависимости между объектами, а анализ показал, что это снижает затраты на сопровождение, применение принципа приводит к тому, что разработчику приходится писать больше классов-«оберток» для вызова 
методов других компонентов. Это усложняет код и увеличивает 
время разработки, а также снижает быстродействие на стадии 
выполнения.
Ограничение вызовов методов
Приведенный ниже класс Car демонстрирует все возможности вызова методов, 
соответствующие принципу минимальной информированности:
public class Car {
Engine engine;
// Другие переменные экземпляра
public Car() {
 // Инициализация
}
public void start(Key key) {
 Doors doors = new Doors();
 
 boolean authorized = key.turns();
 if (authorized) {
 engine.start();
 updateDashboardDisplay();
 doors.lock();
 }
}
public void updateDashboardDisplay() {
 // Перерисовка экрана
}
}
Разрешен вызов локальных 
методов объекта.
Методы можно вызывать 
и для объекта, переданного 
в параметре.
Разрешен вызов методов для 
компонентов объекта.
Разрешен вызов методов для 
объекта, экземпляры которого 
создаются текущим методом.
Компонент класса, мы 
можем вызывать его 
методы.
Создание нового объекта — вызов 
методов допустим.
часто Задаваемые вопросы
298 глава 7
public House {
 WeatherStation station;
 // Другие методы и конструктор
 public float getTemp() {
 return station.getThermometer().getTemperature();
 }
}
Приведите пример стандартной конструкции Java, нарушающей принцип 
минимальной информированности.
Нужно ли переживать по этому поводу?
Ответ: Как насчет System.out.println()?
Нарушают ли какие-либо из этих классов принцип минимальной 
информированности? Почему?
public House {
 WeatherStation station;
 // Другие методы и конструктор
 public float getTemp() {
 Thermometer thermometer = station.getThermometer();
 return getTempHelper(thermometer);
 }
 public float getTempHelper(Thermometer thermometer) {
 return thermometer.getTemperature();
 }
}
ОСТОРОЖНО, ОПАСНАЯ ЗОНА! 
БЕРЕГИТЕСЬ НЕОБОСНОВАННЫХ 
ДОПУЩЕНИЙ!
нарушение принципа минимальной информированности
Мозговой
штурм
Возьми в руку карандаш
дальше   299
паттерн фасад
Фасад и принцип минимальной информированности 
Клиент
У клиента только один «друг»: 
HomeTheaterFacade. В ОО-программировании это ХОРОШО!
HomeTheaterFacade 
управляет всеми 
компонентами 
подсистемы 
за клиента. 
Клиентский код 
остается простым 
и гибким. 
Если подсистема 
становится слишком 
сложной, можно ввести 
дополнительные фасады 
для формирования 
логических уровней.
Обновление 
компонентов 
домашнего 
кинотеатра 
не отразится 
на клиентском 
коде.
watchMovie()
endMovie()
listenToRadio()
endRadio()
HomeTheaterFacade
TheaterLights
on()
off()
dim()
toString()
PopcornPopper
on()
off()
pop()
toString()
Screen
up()
down()
toString()
Tuner
on()
off()
setAm()
setFm()
setFrequency()
toString()
amplifier
Amplifier
tuner
player
on()
off()
setStreamingPlayer()
setStereoSound()
setSurroundSoud()
setTuner()
setVolume()
toString()
Projector
on()
off()
tvMode()
wideScreenMode()
toString()
player
StreamingPlayer
amplifier
on()
off()
pause()
play()
setSurroundAudio()
setTwoChannelAudio()
stop()
toString()
300 глава 7
Стратегия — определяет семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет 
модифицировать алг
Новые инструменты
Наш инструментарий основательно разросся! 
В этой главе были описаны два паттерна, изменяющие интерфейсы и сокращающие привязку 
клиента к используемой системе.
Абстрация
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение 
композиции перед наследованием.
Программируйте на уровне 
интерфейсов.
Стремитесь к слабой связанности взаимодействующих 
объектов.
Классы должны быть открыты для расширения, но закрыты для изменения.
Код должен зависеть от абстракций, а не от конкретных классов.
Взаимодействуйте только 
с «друзьями».
Принципы
Паттерны
Observer — defines a 
one-to-many dependency 
between objects so that 
when one object changes 
state, all its dependents are 
notified and updated 
automatically
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a flexible 
alternative to subclassing for 
extending functionality.
Abstract Factory — Provide 
an interface for creating 
families of related or 
depedent objects without 
specifying their concrete 
classes.
Singleton — Ensure a class 
only has one instance and 
provide a global point of 
access to it.
  Если вам понадобится использовать существующий 
класс с неподходящим интерфейсом — используйте 
адаптер.
  Если вам понадобится упростить большой интерфейс 
или семейство сложных 
интерфейсов — используйте 
фасад.
  Адаптер приводит интерфейс к тому виду, на 
который рассчитан клиент.
  Фасад изолирует клиента от 
сложной подсистемы.
  Объем работы по реализации адаптера зависит 
от размера и сложности 
целевого интерфейса.
  Реализация фасада основана на композиции и делегировании.
  Существуют две разновидности адаптеров: адаптеры 
объектов и адаптеры классов. Для адаптеров классов 
необходимо множественное 
наследование.
  Для подсистемы можно 
реализовать несколько 
фасадов.
...и ДВА новых паттерна. Оба изменяют интерфейсы: 
Адаптер — для преобразования,
Фасад — для унификации и упрощения.
инструментарий проектирования
КЛЮЧЕВЫЕ 
МОМЕНТЫ
У нас появился 
новый принцип 
проектирования...
Команда — инкапсулирует запрос в виде объекта, 
делая возможной параметризацию клиентских 
объектов с другими запросами, организацию очереди 
или регистрацию запросов, 
а также поддержку отмены операций.
Адаптер — преобразует 
интерфейс класса к другому интерфейсу, на который 
рассчитан клиент. Адаптер 
обеспечивает совместную 
работу классов, невозможную в обычных условиях из-за несовместимости 
интерфейсов.
Фасад — предоставляет 
унифицированный интерфейс 
к группе интерфейсов подсистемы. Фасад определяет 
высокоуровневый интерфейс, 
упрощающий работу с подсистемой.
дальше   301
паттерны адаптер и фасад
public House {
 WeatherStation station;
 // Другие методы и конструктор
 public float getTemp() {
 return station.getThermometer().getTemperature();
 }
}
Нарушают ли какие-либо из этих классов принцип 
минимальной информированности? Почему?
public House {
 WeatherStation station;
 // Другие методы и конструктор
 public float getTemp() {
 Thermometer thermometer = station.getThermometer();
 return getTempHelper(thermometer);
 }
 public float getTempHelper(Thermometer thermometer) {
 return thermometer.getTemperature();
 }
}
Принцип нарушается! Мы 
вызываем метод объекта, 
полученного в результате 
вызова другого метода.
Принцип не нарушается! 
Но что реально изменилось 
с перемещением вызова 
в другой метод?
Возьми в руку карандаш
 Решение
Предположим, вам также понадобился адаптер для 
преобразования Duck в Turkey — назовем его DuckAdapter. 
Напишите код этого класса:
public class DuckAdapter implements Turkey {
 Duck duck;
 Random rand;
 public DuckAdapter(Duck duck) {
 this.duck = duck;
 rand = new Random();
 }
 
 public void gobble() {
 duck.quack();
 }
 
 public void fly() {
 if (rand.nextInt(5) == 0) {
 duck.fly();
 }
 }
}
Теперь Duck адаптируется 
в Turkey, поэтому реализуем 
интерфейс Turkey.
Сохраняем ссылку на адаптируемый 
объект Duck.
Случайный объект используется 
в методе fly().
Вызов gobble() превращается 
в quack().
Так как утки летают намного 
дальше индюшек, мы решили, что 
утка будет летать в среднем один 
раз из пяти.
Возьми в руку карандаш
 Решение
302 глава 7
ответы к упражнениям
Вы уже видели, как реализовать адаптер, преобразующий Enumeration
в Iterator. Напишите обратный адаптер, преобразующий Iterator в Enumeration.
public class IteratorEnumeration implements Enumeration<Object> {
 Iterator<?> iterator;
 public IteratorEnumeration(Iterator<?> iterator) {
 this.iterator = iterator;
 }
 public boolean hasMoreElements() {
 return iterator.hasNext();
 }
 public Object nextElement() {
 return iterator.next();
 }
}
Проведите стрелку от каждого паттерна к его предназначению:
Паттерн Предназначение
Декоратор
Адаптер
Фасад
Преобразует один интерфейс 
к другому
Не изменяет интерфейс, но 
добавляет новые обязанности
Упрощает интерфейс
Возьми в руку карандаш
 Решение
Кто и что делает?
решение
Обратите 
внимание: 
тип сделан 
обобщенным 
параметром, 
чтобы решение работало 
для объектов 
любого типа.
Мы уже «набили руку» на инкапсуляции; мы инкапсулировали создание объектов, вызовы методов, сложные интерфейсы, уток, пиццу... Что дальше? Следующим шагом будет 
инкапсуляция алгоритмических блоков, чтобы субклассы могли в любой 
момент связаться с нужным алгоритмом обработки. В этой главе даже 
будет описан принцип проектирования, вдохновленный голливудской 
практикой. Итак, приступим.
8 Паттерн Шаблонный Метод
Да, у меня отличный 
начальник... Пока мне не 
приходится лезть под землю.
Вы его здесь видите?..
И никто не видит!
Инкапсуляция 
 алгоритмов 
304 глава 8
Пора принимать кофеин
Одни люди не могут жить без кофе, другие не могут жить 
без чая. Общий ингредиент? Кофеин, конечно! 
Но это еще не все; способы приготовления чая и кофе 
имеют много общего. Посмотрите сами:
Рецепт 
приготовления 
кофе очень 
похож на рецепт 
приготовления 
чая, не правда ли? 
Starbuzz Coffee: 
Учебное пособие для бариста
(1) Вскипятить воду
(2) Заварить кофе в горячей воде
(3) Перелить кофе в чашку
(4) Добавить сахар и молоко
Рецепт чая Starbuzz
Рецепт кофе Starbuzz
При приготовлении напитков Starbuzz необходимо 
тщательно соблюдать следующие рецепты: 
(1) Вскипятить воду
(2) Заварить чай в горячей воде
(3) Перелить чай в чашку
(4) Добавить лимон
Совершенно секретно — рецепты являются коммерческой тайной
Starbuzz Coffee!
рецепты кофе и чая похожи
паттерн шаблонный метод
дальше   305
Давайте поиграем в «бариста от программирования» 
и напишем классы для кофе и чая.
Сначала кофе:
Кофе и чай (на языке Java)
public class Coffee {
 void prepareRecipe() {
 boilWater();
 brewCoffeeGrinds();
 pourInCup();
 addSugarAndMilk();
 }
 public void boilWater() {
 System.out.println("Boiling water");
 }
 public void brewCoffeeGrinds() {
 System.out.println("Dripping Coffee through 
filter");
 }
 public void pourInCup() {
 System.out.println("Pouring into cup");
 }
 public void addSugarAndMilk() {
 System.out.println("Adding Sugar and Milk");
 }
}
Класс Coffee для
приготовления кофе: 
Рецепт кофе взят прямо из 
учебного пособия. 
Каждый шаг реализован 
в виде отдельного метода.
Каждый из этих 
методов реализует 
один шаг алгоритма: 
кипячение воды, 
настаивание кофе, 
разливание по 
чашкам, добавление 
сахара и молока.
306 глава 8
public class Tea {
 void prepareRecipe() {
 boilWater();
 steepTeaBag();
 pourInCup();
 addLemon();
 }
 public void boilWater() {
 System.out.println("Boiling water");
 }
 public void steepTeaBag() {
 System.out.println("Steeping the tea");
 }
 public void addLemon() {
 System.out.println("Adding Lemon");
 }
 public void pourInCup() {
 System.out.println("Pouring into cup");
 }
}
Реализация очень 
похожа на реализацию 
Coffee; шаги 2 и 4 
различаются, но рецепт 
почти не изменился.
А эти два метода 
в точности 
совпадают 
с методами 
Coffee! Имеет 
место явное 
дублирование кода.
А теперь чай...
Эти два 
метода 
специфичны 
для класса Tea.
реализация tea
Дублирование кода —
верный признак того, что 
в архитектуру необходимо вносить 
изменения. Раз чай и кофе так похожи, 
может, стоит выделить их сходные 
аспекты в базовый класс?
паттерн шаблонный метод
дальше   307
Головоломка
Классы Coffee и Tea содержат дублирующийся код. Взгляните еще раз на эти 
классы и нарисуйте обновленную диаграмму классов, в которой из этих классов 
устраняется избыточность:
308 глава 8
Сэр, вам налить абстрактного кофе?
Каждый субкласс 
реализует 
свой рецепт 
приготовления 
напитка.
Упражнение с классами Coffee и Tea на первый 
взгляд кажется весьма заурядным. Первая версия 
может выглядеть примерно так:
prepareRecipe()
boilWater()
pourInCup()
CaffeineBeverage
prepareRecipe()
steepTeaBag()
addLemon()
Tea
prepareRecipe()
brewCoffeeGrinds()
addSugarAndMilk()
Coffee
Методы boilWater() 
и pourInCup() — общие 
для обоих субклассов, 
поэтому они определяются 
в суперклассе..
Метод prepareRecipe() 
различается 
в субклассах, поэтому 
он определяется как 
абстрактный.
Методы, специфические 
для Coffee и Tea, 
остаются в субклассах.
Субклассы 
переопределяют 
метод 
prepareRecipe().
Как вам результаты переработки архитектуры? Хорошо? Хм-м, взгляните еще разок. Не упустили 
ли мы некоторые общие аспекты? В чем еще проявляется сходство классов Coffee и Tea?
абстракция: первый заход
Мозговой
штурм
паттерн шаблонный метод
дальше   309
Рецепт кофе Starbuzz
Рецепт чая Starbuzz
(1) Вскипятить воду
(2) Заварить чай в горячей воде
(3) Перелить чай в чашку
(4) Добавить лимон
Продолжаем переработку...
Что еще общего у классов Coffee и Tea? Начнем с рецептов.
Обратите внимание: оба рецепта следуют одному алгоритму:
1 Вскипятить воду.
2
3
4
Использовать горячую воду для настаивания 
кофе или чая.
Перелить напиток в чашку.
Добавить соответствующие дополнения 
в напиток.
Эти две операции 
уже выведены 
в базовый класс.
Эти операции не 
абстрагированы, 
но по сути 
одинаковы — просто 
они выполняются 
с разными 
напитками.
Итак, нельзя ли абстрагировать и метод prepareRecipe()? Давайте посмотрим...
(1) Вскипятить воду
(2) Заварить кофе в горячей воде
(3) Перелить кофе в чашку
(4) Добавить сахар и молоко
310 глава 8
Абстрагирование prepareRecipe()
Первая проблема: класс Coffee использует методы brewCoffeeGrinds() 
и addSugarAndMilk(), тогда как класс Tea использует методы steepTeaBag() 
и addLemon().
Давайте шаг за шагом рассмотрим процесс абстрагирования 
prepareRecipe() в субклассах (то есть классах Coffee и Tea)...
1
Однако процессы заваривания кофе и чая мало чем различаютcя. Давайте создадим новый метод (скажем, с именем brew()) и будем использовать его для заварки 
как кофе, так и чая.
Аналогичным образом добавление сахара и молока имеет много общего с добавлением лимона. Для выполнения этой операции мы создадим новый метод 
addCondiments(). Обновленная версия метода prepareRecipe() выглядит так:
 void prepareRecipe() {
 boilWater();
 brew();
 pourInCup();
 addCondiments();
 }
 void prepareRecipe() {
 boilWater();
 steepTeaBag();
 pourInCup();
 addLemon();
 }
Tea
 void prepareRecipe() {
 boilWater();
 brewCoffeeGrinds();
 pourInCup();
 addSugarAndMilk();
 }
Coffee
Новый метод prepareRecipe() необходимо связать с кодом. Для этого 
мы начнем с суперкласса CaffeineBeverage:
2
абстрагирование алгоритма
(Код приведен 
на следующей 
странице.)
паттерн шаблонный метод
дальше   311
public abstract class CaffeineBeverage {
 
 final void prepareRecipe() {
 boilWater();
 brew();
 pourInCup();
 addCondiments();
 }
 abstract void brew();
 
 abstract void addCondiments();
 void boilWater() {
 System.out.println("Boiling water");
 }
 
 void pourInCup() {
 System.out.println("Pouring into cup");
 }
}
Теперь для приготовления чая и кофе 
будет использоваться один метод — 
prepareRecipe(). Этот метод объявлен с ключевым словом final, потому 
что суперклассы не должны переопределять этот метод! Шаги 2 и 4 заменены обобщенными вызовами brew() 
и addCondiments().
CaffeineBeverage — 
абстрактный класс, как 
и в исходной архитектуре.
Так как классы Coffee и Tea 
реализуют эти методы по-разному, 
мы объявляем их абстрактными. 
Субклассы должны предоставить их 
реализацию!
Не забывайте: эти методы 
перемещены в класс 
CaffeineBeverage (см. диаграмму 
классов).
Теперь приготовление напитков определяется суперклассом CaffeineBeverage, так что классам Coffee и Tea остается лишь предоставить реализации нужных методов:
3
public class Tea extends CaffeineBeverage {
 public void brew() {
 System.out.println("Steeping the tea");
 }
 public void addCondiments() {
 System.out.println("Adding Lemon");
 }
}
public class Coffee extends CaffeineBeverage {
 public void brew() {
 System.out.println("Dripping Coffee through filter");
 }
 public void addCondiments() {
 System.out.println("Adding Sugar and Milk");
 }
}
Как и в исходной архитектуре, 
Tea и Coffee расширяют класс 
CaffeineBeverage.
Класс Tea должен определить 
brew() и addCondiments() — два 
абстрактных метода из Caffeine 
Beverage. 
То же самое должен сделать 
и класс Coffee, только вместо 
пакетика чая и лимона он 
добавляет в напиток сахар 
и молоко.
312 глава 8
Нарисуйте новую диаграмму классов после перемещения 
реализации prepareRecipe() в класс CaffeineBeverage:
диаграмма классов напитков
Возьми в руку карандаш
паттерн шаблонный метод
дальше   313
Что мы сделали?
1 Вскипятить воду
2
3
4
Заварить чай в горячей воде
Перелить чай в чашку
Добавить лимон
1 Вскипятить воду
2
3
4
Заварить кофе в горячей воде
Перелить кофе в чашку
Добавить сахар и молоко
2
4
Заварить чай в горячей воде
Добавить лимон
Субкласс Tea
Субкласс 
Coffee
2
4
Заварить кофе в горячей воде
Добавить сахар и молоко
1 Вскипятить воду
2
3
4
Заварить
Перелить в чашку
Добавить 
CaffeineBeverage
Tea
Coffee
CaffeineBeverage знает 
последовательность 
действий в рецепте; 
шаги 1 и 3 он выполняет 
самостоятельно, но при 
выполнении шагов 2 и 4 
зависит от классов Tea 
и Coffee.
Мы осознали, что два 
рецепта фактически 
совпадают, хотя 
некоторые шаги 
требуют разных 
реализаций. 
Соответственно, мы 
обобщили рецепт 
и вынесли его в базовый 
класс.
обобщение
Выполнение 
некоторых шагов зависит от 
субкласса
обобщение
Выполнение 
некоторых 
шагов зависит от субкласса
314 глава 8
Паттерн Шаблонный Метод
В сущности, мы только что реализовали паттерн Шаблонный Метод. Что это такое? Рассмотрим 
структуру класса CaffeineBeverage:
void final prepareRecipe() {
}
brew();
pourInCup();
addCondiments();
boilWater();
 abstract void brew();
 abstract void addCondiments();
 void boilWater() {
 // реализация
 }
 void pourInCup() {
 // реализация
 }
}
public abstract class CaffeineBeverage {
В шаблоне каждый шаг 
алгоритма представлен 
некоторым методом.
prepareRecipe() — шаблонный 
метод. Почему?
Потому что:
 (1) Бесспорно, это метод.
 (2) Он служит шаблоном для 
алгоритма — в данном 
случае алгоритма 
приготовления напитка.
Реализация одних методов 
предоставляется этим 
классом...
...реализация других 
предоставляется субклассом.
Методы, которые 
должны предоставляться 
субклассами, объявляются 
абстрактными.
Шаблонный Метод определяет основные шаги алгоритма и позволяет 
субклассам предоставить реализацию одного или нескольких шагов.
паттерн шаблонный метод
паттерн шаблонный метод
дальше   315
Готовим чай...
Давайте последовательно разберем процедуру приготовления чая, обращая особое внимание на то, как работает шаблонный метод. Вы увидите, что шаблонный метод управляет 
алгоритмом, в некоторых точках алгоритма он дает возможность субклассу предоставить свою реализацию...
1
Tea myTea = new Tea();
Для начала нам понадобится объект Tea...
2
myTea.prepareRecipe();
Затем вызываем шаблонный метод:
который следует алгоритму приготовления напитков...
boilWater();
brew();
pourInCup();
addCondiments();
3
boilWater();
Сначала кипятим воду:
Эта операция выполняется в CaffeineBeverage.
prepareRecipe()
boilWater()
pourInCup()
CaffeineBeverage
brew()
addCondiments();
Tea
4
brew();
Затем необходимо заварить чай — только субкласс знает, как 
это правильно делается:
5
pourInCup();
Чай переливается в чашку; эта операция выполняется одинаково для всех напитков, поэтому она тоже выполняется 
в CaffeineBeverage:
6
addCondiments();
В чай кладутся добавки, специфические для конкретного напитка, поэтому операция реализуется в субклассе:
Метод prepareRecipe() 
определяет алгоритм, 
а реализации 
(полностью 
или частично) 
предоставляются 
субклассами.
За сценой
316 глава 8
Что дает Шаблонный Метод?
Тривиальная реализация
Tea и Coffee
Новый класс CaffeineBeverage 
на базе Шаблонного Метода
Алгоритм определяется классами 
Coffee и Tea.
Модификация алгоритма требует 
открытия субклассов и внесения 
множественных изменений.
Алгоритм находится в одном месте, 
в котором вносятся изменения в коде 
алгоритма.
Частичное дублирование кода 
в классах Coffee и Tea.
Класс CaffeineBeverage обеспечивает повторное использование кода 
между субклассами.
Алгоритм определяется классом 
CaffeineBeverage.
Добавление новых классов в такой 
структуре требует значительной 
работы.
Структура классов на базе паттерна 
Шаблонного Метода обеспечивает 
простое добавление новых классов — 
они лишь должны реализовать пару 
методов.
Вся информация об алгоритме 
сосредоточена в классе 
CaffeineBeverage, а субклассы 
предоставляют полную реализацию.
Знание алгоритма и его реализации 
распределено по многим классам.
что дает шаблонный метод?
паттерн шаблонный метод
дальше   317
Определение паттерна Шаблонный Метод
Паттерн Шаблонный Метод задает «скелет» алгоритма 
в методе, оставляя определение реализации некоторых шагов субклассам. Субклассы могут переопределять некоторые 
части алгоритма без изменения его структуры.
Вы уже видели, как паттерн Шаблонный Метод применяется на практике. Теперь обратимся к официальному определению и уточним некоторые подробности:
Основной задачей паттерна является создание шаблона алгоритма. Что такое «шаблон алгоритма»? 
Как было показано ранее, это метод, а конкретнее — метод, определяющий алгоритм в виде последовательности шагов. Один или несколько шагов определяются в виде абстрактных методов, реализуемых 
субклассами. Таким образом гарантируется неизменность структуры алгоритма, при том что часть реализации предоставляется субклассами.
Рассмотрим следующую диаграмму классов:
templateMethod()
primitiveOperation1()
primitiveOperation2()
AbstractClass
primitiveOperation1()
primitiveOperation2()
ConcreteClass
primitiveOperation1();
primitiveOperation2();
Класс AbstractClass 
содержит шаблонный 
метод...
...и абстрактные 
версии операций, 
используемых 
в шаблонном методе.
ConcreteClass реализует 
абстрактные 
операции, вызываемые 
в ходе выполнения 
templateMethod().
В схеме может быть 
задействовано много 
классов ConcreteClass, 
каждый из которых 
реализует полный набор 
операций, необходимых 
для работы шаблонного 
метода. 
Шаблонный метод использует методы primitiveOperation в реализации 
алгоритма. Он изолирован от фактической реализации этих операций.
318 глава 8
Абстрактный класс; он 
должен субклассироваться 
классами, предоставляющими 
реализацию операций.
Давайте повнимательнее присмотримся к определению AbstractClass, 
включая шаблонный метод и примитивные операции.
abstract class AbstractClass {
 
 final void templateMethod() {
 primitiveOperation1();
 primitiveOperation2();
 concreteOperation();
 }
 abstract void primitiveOperation1();
 
 abstract void primitiveOperation2();
 
 void concreteOperation() {
 // реализации
 }
}
Шаблонный метод; 
объявляется с ключевым 
словом final, чтобы 
субклассы не могли изменить 
последовательность шагов 
в алгоритме.
Шаблонный метод 
определяет 
последовательность 
шагов, каждый из которых 
представлен методом.
В данном примере 
две примитивные 
операции должны 
реализоваться 
конкретными 
субклассами.
Конкретная операция, определенная 
в абстрактном классе. Она может 
переопределяться в субклассах, хотя 
переопределение также можно 
запретить, объявив concreteOperation() 
с ключевым словом final. Вскоре мы 
расскажем об этом подробнее.
шаблонный метод под увеличительным стеклом
Код под увеличительным стеклом
паттерн шаблонный метод
дальше   319
А сейчас мы еще подробнее рассмотрим методы, которые могут определяться в абстрактном классе:
abstract class AbstractClass {
 
 final void templateMethod() {
 primitiveOperation1();
 primitiveOperation2();
 concreteOperation();
 hook();
 }
 abstract void primitiveOperation1();
 
 abstract void primitiveOperation2();
 
 final void concreteOperation() {
 // реализация
 }
 void hook() {}
}
Примитивы-методы никуда 
не делись; они объявлены 
абстрактными и реализуются 
конкретными субклассами.
Субклассы могут переопределять такие 
методы (называемые «перехватчиками»), 
но не обязаны это делать. Пример 
использования методов-перехватчиков 
представлен на следующей странице.
Конкретный 
метод, который не 
делает ничего!
В templateMethod() 
включен вызов нового 
метода.
Код под микроскопом
Конкретная операция определяется 
в абстрактном классе. Эта объявлена 
с ключевым словом final, чтобы 
субклассы не могли переопределить 
ее. Она может использоваться 
как напрямую шаблонным методом, 
так и субклассами.
320 глава 8
Перехватчики в паттерне 
Шаблонный Метод
public abstract class CaffeineBeverageWithHook {
 final void prepareRecipe() {
 boilWater();
 brew();
 pourInCup();
 if (customerWantsCondiments()) {
 addCondiments();
 }
 }
 abstract void brew();
 abstract void addCondiments();
 void boilWater() {
 System.out.println("Boiling water");
 }
 void pourInCup() {
 System.out.println("Pouring into cup");
 }
 boolean customerWantsCondiments() {
 return true;
 }
}
«Перехватчиком» называется метод, объявленный абстрактным классом, но имеющий пустую 
реализацию (или реализацию по умолчанию). 
Он дает возможность субклассу «подключаться» к алгоритму в разных точках. Впрочем, субкласс также может проигнорировать имеющийся перехватчик.
Рассмотрим пример возможного применения 
перехватчиков (другие примеры будут описаны 
позднее):
Добавляем условную конструкцию, 
результат которой определяется 
вызовом конкретного метода 
customerWantsCondiments(). Только 
если вызов вернет true, мы 
вызываем addCondiments().
Метод с (почти) пустой 
реализацией по умолчанию: 
просто возвращает true
и не делает ничего более. 
Перехватчик: субкласс может 
переопределить этот метод, 
но не обязан этого делать.
реализация перехватчика
Я могу переопределить 
метод-перехватчик, 
а могу и не переопределять. 
Если не переопределю, 
абстрактный класс предоставит 
реализацию по умолчанию.
паттерн шаблонный метод
дальше   321
public class CoffeeWithHook extends CaffeineBeverageWithHook {
 public void brew() {
 System.out.println("Dripping Coffee through filter");
 }
 public void addCondiments() {
 System.out.println("Adding Sugar and Milk");
 }
 public boolean customerWantsCondiments() {
 String answer = getUserInput();
 if (answer.toLowerCase().startsWith("y")) {
 return true;
 } else {
 return false;
 }
 }
 private String getUserInput() {
 String answer = null;
 System.out.print("Would you like milk and sugar with your coffee (y/n)? ");
 BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
 try {
 answer = in.readLine();
 } catch (IOException ioe) {
 System.err.println("IO error trying to read your answer");
 }
 if (answer == null) {
 return "no";
 }
 return answer;
 }
}
Использование перехватчиков
Чтобы использовать метод-перехватчик, мы переопределяем его в субклассе. В данном 
случае перехватчик управляет выполнением класса CaffeineBeverage определенной части 
алгоритма, а именно добавками к напитку.
Как узнать, нужно ли класть клиенту в кофе сахар/молоко? Да просто спросить!
Здесь вы 
переопределяете 
перехватчик 
и задаете нужную 
функциональность.
Предлагаем пользователю принять 
решение и возвращаем true или false 
в зависимости от 
полученных данных.
В этом фрагменте мы спрашиваем пользователя, нужно ли добавить 
в напиток сахар/молоко. Входные 
данные читаются из командной
строки.
322 глава 8
public class BeverageTestDrive {
 public static void main(String[] args) {
 TeaWithHook teaHook = new TeaWithHook();
 CoffeeWithHook coffeeHook = new CoffeeWithHook();
 System.out.println("\nMaking tea...");
 teaHook.prepareRecipe();
 System.out.println("\nMaking coffee...");
 coffeeHook.prepareRecipe();
 }
}
Проверяем, как работает код
Вода закипает... Следующая тестовая программа 
приготовит горячий чай и кофе. 
%java BeverageTestDrive
Making tea...
Boiling water
Steeping the tea
Pouring into cup
Would you like lemon with your tea (y/n)? y
Adding Lemon
Making coffee...
Boiling water
Dripping Coffee through filter
Pouring into cup
Would you like milk and sugar with your coffee (y/n)? n
%
File Edit Window Help send-more-honesttea
Запускаем...
Чашка горячего чая... 
и, конечно, с лимоном!
И кофе тоже — но без 
добавок, вредных для 
фигуры!
Создаем чай.
Создаем кофе.
Вызываем prepareRecipe() 
для обоих!
тестовый запуск
паттерн шаблонный метод
дальше   323
В: Как при создании шаблонного метода определить, когда использовать абстрактные методы, а когда — перехватчики?
О: Используйте абстрактные методы, если субкласс ДОЛЖЕН 
предоставить реализацию метода или шага алгоритма. Перехватчики используются для необязательных частей алгоритма.
В: Для чего нужны перехватчики?
О: Как мы уже говорили, при помощи перехватчика субкласс 
может реализовать необязательную часть алгоритма. Если эта 
часть не важна для реализации субкласса, он ее пропускает. Также перехватчик может дать субклассу возможность среагировать 
на предстоящий или только что выполненный шаг шаблонного 
метода. Ранее мы уже рассмотрели пример, в котором перехватчик давал субклассу возможность принять решение вместо 
абстрактного класса.
В: Должен ли субкласс реализовать все абстрактные методы абстрактного суперкласса? 
О: Да, каждый конкретный субкласс определяет полный набор 
абстрактных методов и предоставляет полную реализацию неопределенных шагов алгоритма шаблонного метода.
В: Вероятно, количество абстрактных методов должно 
быть минимальным, иначе их реализация в субклассе потребует слишком большого объема работы?
О: Об этом стоит помнить при написании шаблонных методов. 
Иногда эта цель достигается за счет укрупнения шагов алгоритма, 
но это приводит к потере гибкости.
Также следует помнить, что некоторые шаги могут быть необязательными; реализуйте их в виде перехватчиков (вместо 
абстрактных методов), чтобы упростить реализацию субклассов.
Пожалуй, возможность 
задать клиенту вопрос была бы 
полезной для всех субклассов?
И знаете что? Мы с вами согласимся. Но 
признайте: до того, как вам пришла в голову подобная мысль, это был классный 
пример использования перехватчиков для 
условного управления выполнением алгоритма в абстрактном классе. Верно?
Несомненно, вы сможете придумать много 
других, более реалистичных сценариев использования шаблонных методов и перехватчиков в своем коде.
часто Задаваемые вопросы
324 глава 8
Голливудский принцип
Голливудский принцип
Не вызывайте нас — мы вас сами 
вызовем. 
Представляем новый принцип проектирования, 
который называется «Голливудский принцип».
Легко запоминается, верно? Но какое отношение этот принцип имеет к ОО-проектированию?
Голливудский принцип помогает предотвратить «разложение зависимостей» — явление, при котором компоненты 
высокого уровня зависят от компонентов низкого уровня, 
которые зависят от компонентов низкого уровня, которые 
зависят... и т. д. Разобраться в архитектуре такой системы 
очень трудно.
Голливудский принцип позволяет компонентам низкого 
уровня подключаться к системе, но компоненты высокого 
уровня сами определяют, когда и как они должны использоваться. Иначе говоря, компоненты высокого уровня запрещают компонентам низкого уровня «проявлять инициативу».
Компонент высокого уровня
Компонент 
низкого 
уровня
Другой 
компонент 
низкого 
уровня
Компоненты 
низкого уровня 
участвуют 
в обработке 
данных.
Но компоненты 
высокого уровня 
управляют тем, 
когда и как это 
происходит.
Компонент низкого 
уровня никогда 
не обращается 
к компоненту 
высокого уровня 
напрямую.
голливудский принцип
Я уже говорил 
прежде и скажу снова: 
не звоните мне, я вам сам 
позвоню!
паттерн шаблонный метод
дальше   325
Какие еще паттерны используют Голливудский 
принцип?
Фабричный Метод и Наблюдатель; другие варианты?
Голливудский принцип и Шаблонный Метод
Связь между Голливудским принципом и Шаблонным Методом достаточно очевидна: при проектировании с использованием паттерна Шаблонный Метод мы фактически запрещаем субклассам обращаться с вызовами к суперклассу. Каким образом? Давайте еще раз взглянем на 
архитектуру CaffeineBeverage: 
prepareRecipe()
boilWater()
pourInCup()
brew()
addCondiments()
CaffeineBeverage
brew()
addCondiments()
Tea
brew()
addCondiments()
Coffee
CaffeineBeverage — компонент 
высокого уровня. Он определяет 
алгоритм рецепта и обращается 
с вызовами к субклассам только 
тогда, когда они необходимы для 
реализации метода.
Tea и Coffee никогда не 
обращаются с вызовами к абстрактному 
классу — сначала он 
обращается к ним.
Субклассы только 
предоставляют 
подробности реализации. 
Клиенты зависят 
от абстрактции 
CaffeineBeverage, а
конкретных классов Tea 
не от 
или Coffee; это способ
ствует сокращению 
-
зависимостей в системе.
Мозговой
штурм
326 глава 8
В: Как Голливудский принцип связан 
с принципом инверсии зависимостей, 
который мы рассматривали несколько 
глав назад?
О: Принцип инверсии зависимостей 
учит нас избегать использования конкретных классов и по возможности работать 
с абстракциями. Голливудский принцип 
направлен на построение инфраструктур 
и компонентов, в которых компоненты 
низкого уровня могут участвовать в вычислениях без формирования зависимостей 
между компонентами низкого и высокого уровня. Таким образом, оба принципа 
обеспечивают логическую изоляцию, но 
принцип инверсии зависимостей является 
более сильным и общим утверждением 
относительно того, как избегать зависимостей в архитектуре.
В: Запрещено ли компоненту низкого 
уровня вызывать методы компонента 
высокого уровня? 
О: Нет. Более того, компонент низкого 
уровня часто в конечном итоге вызывает 
метод, определенный на более высоком 
уровне иерархии наследования. Мы лишь 
хотим избежать создания циклических зависимостей между компонентами высокого 
и низкого уровня.
Соедините каждый паттерн с его описанием:
Описание
Шаблонный Метод Инкапсуляция взаимозаменяемых 
вариантов поведения и выбор 
нужного варианта посредством 
делегирования
Субклассы определяют 
реализацию шагов алгоритма
Субклассы решают, какие 
конкретные классы создавать
кто и что делает
Кто и что делает?
часто Задаваемые вопросы
Паттерн
Стратегия
Фабричный Метод
паттерн шаблонный метод
дальше   327
Шаблонные методы на практике
Паттерн Шаблонный Метод очень часто применяется на 
практике; вы найдете множество примеров его применения 
в готовом коде. Будьте осмотрительны, потому что многие реализации шаблонных методов заметно отличаются от «канонических» реализаций этого паттерна.
Столь широкое распространение этого паттерна объясняется 
тем, что он идеально подходит для создания инфраструктур, 
которые управляют общим ходом выполнения некоторой задачи, но при этом дают возможность пользователю указать, что 
конкретно должно происходить на каждом шаге алгоритма.
Давайте проведем небольшую экскурсию на природе (то есть 
в Java API)...
Во время учебы мы изучаем классические 
паттерны. А в реальном мире нужно уметь 
распознавать паттерны вне контекста, а также 
разновидности паттернов, потому что 
в реальном мире квадратная дырка не всегда 
имеет действительно квадратную форму.
328 глава 8
public static void sort(Object[] a) {
 Object aux[] = (Object[])a.clone();
 mergeSort(aux, a, 0, a.length, 0);
}
private static void mergeSort(Object src[], Object dest[],
 int low, int high, int off) 
{
 // ...
 for (int i=low; i<high; i++){
 for (int j=i; j>low &&
 ((Comparable)dest[j-1]).compareTo((Comparable)dest[j])>0; j--)
 {
 swap(dest, j, j-1);
 }
 }
 
 // ...
}
Какая операция часто выполняется с массивами? Конечно, сортировка!
Хорошо понимая этот факт, проектировщики 
класса Java Arrays предоставили нам удобный 
шаблонный метод для выполнения сортировки. 
Давайте посмотрим, как он работает:
Сортировка на базе Шаблонного Метода
Функциональность сортировки обеспечивается 
совместной работой двух методов.
compareTo() — метод, 
который необходимо реализовать для «заполнения 
пробелов» в Шаблонном 
Методе.
Конкретный метод, уже 
определенный в классе Arrays.
Мы немного упростили 
код, чтобы было легче 
объяснять. Полную 
версию можно загрузить 
на сайте Sun.
Шаблонный 
Метод
Вспомогательный метод sort() 
создает копию массива и передает ее 
вместе с приемным массивом методу 
mergeSort(). Также передается длина 
массива и признак начала сортировки 
с первого элемента.
Метод mergeSort() содержит алгоритм сортировки, 
реализация которого зависит от метода compareTo(). 
За техническими подробностями обращайтесь 
к исходному коду Java.
сортировка на базе шаблонного метода
паттерн шаблонный метод
дальше   329
Массив объектов 
Duck, который нужно 
отсортировать.
Сортируем уток...
Метод compareTo() сравнивает два объекта и возвращает информацию об их соотношении (первый 
объект меньше второго, больше либо равен ему). Метод sort() использует его для сравнения объектов 
в массиве.
Разве
я больше
тебя?
Допустим, у вас имеется массив объектов Duck и этот массив 
нужно отсортировать. Как это сделать? Шаблонный метод sort 
из класса Arrays определяет алгоритм, но мы должны указать 
ему, как сравнить два объекта, а для этого нужно реализовать 
метод compareTo()... Понятно?
Нет, непонятно. Разве 
мы не должны что-то 
субклассировать, как положено 
в паттерне Шаблонный Метод? 
Массив ничего не субклассирует, 
как же мы будем использовать 
sort()?
Хороший вопрос. Дело вот в чем: проектировщики sort() хотели, чтобы метод мог 
использоваться для всех массивов, поэтому они реализовали sort() в виде статического метода. Но это вполне нормальное решение — оно работает почти так же, 
как метод суперкласса. Но поскольку метод sort() все-таки не определяется в суперклассе, он должен знать, что вы реализовали метод compareTo(); в противном случае у него не хватит информации для определения полного алгоритма сортировки.
Для решения этой проблемы проектировщики воспользовались интерфейсом 
Comparable. От вас потребуется лишь реализовать этот интерфейс, состоящий из 
единственного метода compareTo().
Что делает метод compareTo()?
Не знаю, так
говорит метод 
compareTo().
330 глава 8
Сравнение объектов Duck
Итак, для сортировки объектов Duck необходимо реализовать метод compareTo(), тем самым вы предоставите классу Arrays информацию, необходимую для завершения алгоритма 
сортировки.
Реализация класса Duck выглядит так:
При отсутствии реального 
субклассирования класс должен 
реализовать интерфейс Comparable. 
Переменные экземпляров
Объект Duck просто выводит 
значения переменных name 
и weight.
Метод необходим для сортировки...
Метод compareTo() получает другой 
объект Duck и сравнивает его с ТЕКУЩИМ 
объектом Duck.
Здесь определяется правило 
сравнения объектов Duck. 
Если значение переменной 
weight ТЕКУЩЕГО объекта 
Duck меньше значения weight 
объекта otherDuck, метод 
возвращает -1; если они 
равны — возвращает 0; а если 
больше — возвращает 1.
реализация сomparable
public class Duck implements Comparable<Duck> {
 String name;
 int weight;
 
 public Duck(String name, int weight) {
 this.name = name;
 this.weight = weight;
 }
 public String toString() {
 return name + " weighs " + weight;
 }
 
 public int compareTo(Duck otherDuck) {
 
 if (this.weight < otherDuck.weight) {
 return -1;
 } else if (this.weight == otherDuck.weight) {
 return 0;
 } else { // this.weight > otherDuck.weight
 return 1;
 }
 }
}
паттерн шаблонный метод
дальше   331
Пример сортировки
%java DuckSortTestDrive
Before sorting:
Daffy weighs 8
Dewey weighs 2
Howard weighs 7
Louie weighs 2
Donald weighs 10
Huey weighs 2
After sorting:
Dewey weighs 2
Louie weighs 2
Huey weighs 2
Howard weighs 7
Daffy weighs 8
Donald weighs 10
%
File Edit Window Help DonaldNeedsToGoOnADiet
До сортировки
После сортировки
public class DuckSortTestDrive {
 public static void main(String[] args) {
 Duck[] ducks = { 
 new Duck("Daffy", 8), 
 new Duck("Dewey", 2),
 new Duck("Howard", 7),
 new Duck("Louie", 2),
 new Duck("Donald", 10), 
 new Duck("Huey", 2)
 };
 System.out.println("Before sorting:");
 display(ducks);
 Arrays.sort(ducks);
 System.out.println("\nAfter sorting:");
 display(ducks);
 }
 public static void display(Duck[] ducks) {
 for (Duck d : ducks) {
 System.out.println(d);
 }
 }
}
Давайте начнем сортировку!
Тестовая программа для сортировки объектов Duck...
Создаем массив 
объектов Duck.
Выводим значения 
name и weight.
Сортировка!
(Повторно) выводим 
значения name и weight.
Мы вызываем 
статический 
метод sort 
класса Arrays 
и передаем ему 
массив объектов 
Duck.
332 глава 8
Как сортируются объекты Duck
Давайте проследим за тем, как работает метод sort() 
класса Arrays. Нас прежде всего интересует то, как шаблонный метод определяет алгоритм и как в некоторых 
точках алгоритма он обращается к Duck за реализацией 
текущего шага...
1
Duck[] ducks = {new Duck("Daffy", 8), ... };
Прежде всего понадобится массив объектов 
Duck:
2
Arrays.sort(ducks);
Затем мы вызываем шаблонный метод sort() 
класса Arrays и передаем ему созданный массив:
Метод sort() (и вспомогательный метод mergeSort()) определяют процедуру сортировки.
for (int i=low; i<high; i++){
 ... compareTo() ...
 ... swap() ...
}
3
ducks[0].compareTo(ducks[1]);
Чтобы отсортировать массив, метод последовательно сравнивает его элементы до тех пор, пока 
весь список не будет приведен к порядку сортировки. Чтобы узнать, как сравнивать два объекта 
Duck, метод sort обращается за помощью к методу 
compareTo() класса Duck. Метод compareTo() вызывается для первого объекта Duck и получает 
объект Duck, с которым он сравнивается:
sort()
swap()
Arrays
compareTo()
toString()
Duck
4
swap()
Если объекты Duck нарушают порядок сортировки, 
они меняются местами при помощи конкретного метода swap() класса Arrays:
Метод sort() определяет 
алгоритм, и никакой класс 
этого изменить не может. 
Он рассчитывает на то, 
что класс, реализующий 
Comparable, предоставит 
реализацию compareTo().
5 Метод sort продолжает сравнивать и менять местами 
объекты Duck, пока элементы массива не будут располагаться в правильном порядке!
Первый объект 
Duck. Объект Duck, с которым 
он сравнивается. Не связаны наследованием (в отличие 
от типичного шаблонного метода).
за сценой: сортировка
За сценой
паттерн шаблонный метод
дальше   333
В: А этот пример вообще относится 
к паттерну Шаблонный Метод?
О: В описании паттерна говорится об 
определении алгоритма с возможностью 
определения реализации отдельных его 
шагов в субклассах — сортировка массива под это описание определенно не 
подходит! Но как мы знаем, на практике 
паттерны часто приходится подгонять под 
ограничения контекста и реализации.
Проектировщики метода Arrays sort() 
столкнулись с препятствием: в общем случае субклассировать массив Java невозможно, а они хотели, чтобы метод sort мог 
использоваться для всех массивов (хотя 
разные массивы относятся к разным классам). Исходя из этого, они определили
статический метод и поручили определение способа сортируемым объектам. 
Таким образом, несмотря на отличия от 
«канонических» шаблонных методов, эта 
реализация вполне соответствует духу 
паттерна.
В: Такая реализация сортировки напоминает скорее паттерн Стратегия. Почему мы считаем ее Шаблонным Методом? 
О: Вероятно, такое впечатление возникает из-за того, что в паттерне Стратегия 
используется композиция. И это в какомто смысле верно, ведь мы используем
объект Arrays для сортировки массива. 
Однако в паттерне Стратегия включаемый 
класс реализует весь алгоритм, а алгоритм сортировки, реализованный в Arrays, 
неполон; недостающий метод compareTo() 
должен быть предоставлен классом. 
В этом состоит его сходство с паттерном 
Шаблонный Метод.
В: Встречаются ли другие примеры 
шаблонных методов в Java API?
О: Да, встречаются. Например, в библиотеке java.io класс InputStream содержит метод read(), который реализуется 
субклассами и используется шаблонным 
методом read(byte b[], int off, int len). 
Всем известно, что композиции следует отдавать предпочтение перед наследованием. Авторы 
реализации sort() решили не использовать наследование, а вместо этого реализовали sort() 
как статический метод, связываемый с Comparable посредством композиции на стадии выполнения. В чем преимущества такого решения? Недостатки? Как бы вы подошли к решению этой 
проблемы? Не усложняют ли эту задачу особенности массивов Java?
Вспомните другой паттерн, который представляет собой специализированную версию Шаблонного Метода. В этой специализации примитивные операции используются для создания 
и возвращения объектов. Что это за паттерн?
Мозговой
штурм
Мозговой
штурм
2
часто Задаваемые вопросы
334 глава 8
Шаблонный метод в JFrame
public class MyFrame extends JFrame {
 public MyFrame(String title) {
 super(title);
 this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 this.setSize(300,300);
 this.setVisible(true);
 }
 public void paint(Graphics graphics) {
 super.paint(graphics);
 String msg = "I rule!!";
 graphics.drawString(msg, 100, 100);
 }
 public static void main(String[] args) {
 MyFrame myFrame = new MyFrame("Head First Design Patterns");
 }
}
Экскурсия по шаблонным методам продолжается... Следующая остановка — 
JFrame!
Для тех, кто еще не знаком с JFrame, поясняем: это основной контейнер 
Swing, наследующий метод paint(). По умолчанию paint() не делает ничего, потому что является перехватчиком! Переопределяя paint(), можно 
подключиться к алгоритму, используемому JFrame для перерисовки своей 
части экрана, и включить в JFrame свой графический вывод. Простейший 
пример использования JFrame для переопределения метода paint():
Расширяем класс JFrame, который содержит 
метод update(), управляющий перерисовкой 
экрана. Чтобы подключиться к этому 
алгоритму, мы переопределяем метод paint().
Алгоритм перерисовки JFrame 
вызывает paint(). По умолчанию 
метод paint() не делает 
ничего... это перехватчик. 
Переопределенная версия paint() 
выводит сообщение в окне.
Сообщение, которое 
выводится на панели 
вследствие перехвата 
метода paint().
Подробности 
несущественны! 
Просто некая 
инициализация...
перехватчик paint
паттерн шаблонный метод
дальше   335
Специализированные списки и AbstractList
Последняя остановка в нашем сафари: AbstractList.
Коллекции списков в Java, такие как ArrayList и 
LinkedList, расширяют класс AbstractList, что позволяет 
предоставить часть базовых реализаций для поведения 
списков. Если вы хотите создать собственный специализированный список — допустим, список, содержащий 
только строки, — вы можете расширить AbstractList, чтобы получить базовое поведение списка автоматически.
AbstractList содержит шаблонный метод subList(), который зависит от двух абстрактных методов, get() и size(). 
Таким образом, когда вы расширяете AbstractList для создания собственного специализированного списка, вы 
предоставляете реализации этих методов.
Ниже приведена реализация специализированного списка, содержащего только объекты String; в этой реализации используются массивы:
Создаем подсписок, состоящий из 
одного элемента, начиная с индекса 2.
Создаем специализированный 
список, расширяя AbstractList.
subList()
get(int)
size()
iterator()
hashCode()
// other methods
AbstractList
get(int)
size()
MyList
get(3);
size();
public class MyStringList extends AbstractList<String> {
private String[] myList;
MyStringList(String[] strings) {
myList = strings;
}
public String get(int index) {
return myList[index];
}
public int size() {
return myList.length;
}
public String set(int index, String item) {
String oldString = myList[index];
myList[index] = item;
return oldString;
}
}
String[] ducks = { "Mallard Duck", "Redhead Duck", "Rubber Duck", "Decoy Duck"};
MyStringList ducksList = new MyStringList(ducks);
List ducksSubList = ducksList.subList(2, 3);
Шаблонный метод subList() в реализации MyStringList тестируется примерно так:
Необходимо реализовать 
методы get() и size(), оба 
метода используются 
шаблонным методом subList().
Также реализуется метод set(), 
чтобы иметь возможность 
изменять список.
336 глава 8
Послушай, что ты делаешь в моей главе? Я думал, 
что ты общаешься только с занудами вроде Фабричного Метода.
Эй, я все 
слышу!
Полегче — ведь вы с Фабричным Методом вроде 
как родственники?
Да я же пошутил! Хотя серьезно, что ты здесь делаешь? Уже восемь глав о тебе ни слуху ни духу!
Раз уж тебя так долго не было, стоит напомнить 
читателю, кто ты такой.
Не знаю, право, после главы 1 меня часто останавливают на улице и спрашивают: «Скажите, 
а вы случайно не тот паттерн...» Так что меня 
хорошо знают. Только ради тебя: я определяю 
семейство алгоритмов и обеспечиваю их взаимозаменяемость. Инкапсуляция позволяет легко 
использовать разные алгоритмы на стороне клиента.
Выходит, у нас много общего. Но моя задача несколько иная: я определяю общую структуру алгоритма, поручая часть работы субклассам. Это 
позволяет мне выбирать разные реализации отдельных шагов алгоритма, сохраняя под контролем его структуру. А ты, похоже, свои алгоритмы 
не контролируешь...
Сравнение Шаблонного Метода 
и Стратегии.
Шаблонный Метод Стратегия Фабричный Метод
Я бы не стал это называть так... Но как бы то ни 
было, я не ограничиваюсь применением наследования для реализаций алгоритмов. Я предоставляю клиентам выбор разных реализаций 
алгоритмов через композицию.
Я слышал, что твоя глава подходит к концу, и решил посмотреть, как дела. У нас много общего, 
и я подумал, что смогу помочь...
беседа у камина: шаблонный метод и стратегия
Беседа у камина
дальше   337
паттерн шаблонный метод
Иногда ты бываешь более эффективным (ненамного) и требуешь меньшего количества объектов. И иногда бываешь менее сложным по сравнению с моей моделью делегирования... но я 
более гибок, потому что использую композицию. 
Со мной клиенты могут изменять алгоритмы во 
время выполнения, просто переключаясь на 
другой объект стратегии. Не зря же именно меня
выбрали для главы 1!
Да, пожалуй... А как насчет зависимостей? У тебя 
их явно больше, чем у меня.
Это почему? Мой суперкласс объявляется абстрактным.
Но тебе приходится зависеть от реализации 
в суперклассе методов, являющихся частью твоего алгоритма. Я не завишу ни от кого, я могу реализовать весь алгоритм самостоятельно!
Да-да, я уже говорил: рад за тебя. Спасибо, что 
зашел, но мне нужно добраться до конца этой 
главы.
Ладно, ладно, не обижайся. Не буду мешать, но 
если тебе что-то понадобится — только скажи. 
Всегда готов помочь.
Шаблонный Метод Стратегия
Да, я помню. Но я лучше контролирую свой алгоритм и не допускаю дублирования кода. Собственно, если все части моего алгоритма одинаковы, 
кроме, допустим, одной строки, мои классы намного эффективнее твоих. Весь дублирующийся 
код выделяется в суперкласс и совместно используется всеми субклассами.
Рад за тебя, но не будем забывать, что меня используют чаще других паттернов. Почему? Потому что я предоставляю основной механизм 
повторного использования кода, позволяющий 
задавать поведение в субклассах. Сам понимаешь, этот механизм идеально подходит для создания инфраструктур.
Понятно. Не вызывайте нас, мы вас сами вызовем...
338 глава 8
инструментарий проектирования
Стратегия — определяет
семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость.
Паттерн позволяет модифицировать алг
Новые инструменты
Ваш инструментарий дополнился паттерном 
Шаблонный Метод. Этот паттерн позволяет 
организовать повторное использование кода 
с сохранением контроля над алгоритмами.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне 
интерфейсов.
Стремитесь к слабой связанности взаимодействующих 
объектов.
Классы должны быть открыты для расширения, но закрыты для изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Взаимодействуйте только 
с «друзьями».
Не вызывайте нас — мы вас 
сами вызовем.
Принципы
Паттерны
Observer — defines a
one-to-many dependency
between objects so that
when one object changes
state, all its dependents
are notified and updated
automatically
Decorator — Attach
additional responsibilities
to an object dynamically. Decorators provide a
flexible alternative to
subclassing for extending
functionality.
Abstract Factory —
Provide an interface
for creating families of
related or depedent objects
without specifying their
concrete classes.
Factory Method  —
Define an interface for
creating an object, but
let subclasses decide
which class to instantiate. 
Factory Method lets a
class defer instantiation to
the subclasses.
Singleton — Ensure a class
only has one instance and
provide a global point of
access to it.
Command — Encapsulates
a request as an object,
thereby letting you
parameterize clients with
different requests, queue or
log requests, and support undoable operations.
  Шаблонный Метод определяет основные шаги алгоритма, оставляя 
субклассам возможность определения реализации этих шагов.
  Паттерн Шаблонный Метод 
играет важную роль в повторном 
использовании кода.
  Абстрактный класс Шаблонного Метода может определять 
конкретные методы, абстрактные 
методы и перехватчики.
  Абстрактные методы реализуются субклассами.
  Перехватчики не делают ничего 
или определяют поведение по 
умолчанию в абстрактном классе, но могут переопределяться 
в субклассах.
  Чтобы субкласс не мог изменить 
алгоритм в Шаблонном Методе, 
объявите последний с ключевым 
словом final.
  Голливудский принцип указывает на то, что решения должны 
приниматься модулями высокого уровня, которые знают, как 
и когда обращаться с вызовами 
к модулям низкого уровня.
  Паттерн Шаблонный Метод часто 
встречается в реальном коде, 
но (как и с любым паттерном) 
не ждите, что он всегда будет 
реализован «по учебникам».
  Паттерны Стратегия и Шаблонный 
Метод инкапсулируют алгоритмы; 
один использует наследование, 
а другой — композицию.
  Фабричный Метод является 
специализированной версией 
Шаблонного Метода.
Adapter — Encapsulates
a request as an object,
thereby letting you
parameterize clients with
different requests, queue 
or log requests, and 
support undoable 
operations.
Новейший принцип 
напоминает, что 
алгоритм определяется 
суперклассом, поэтому 
последний должен сам 
обращаться к субклассам, 
когда потребуется.
А только что 
изученный паттерн позволяет 
классам, реализующим алгоритм, передать 
выполнение некоторых шагов 
в субклассы.
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Фасад — предоставляет
унифицированный интерфейс
к группе интерфейсов подсистемы. Фасад определяет
высокоуровневый интерфейс,
упрощающий работу с подсистемой.
Шаблонный Метод — определяет «скелет» алгоритма 
в методе, оставляя определение реализации некоторых шагов 
субклассам. Субклассы могут 
переопределять некоторые части 
алгоритма без изменения его 
структуры.
паттерн шаблонный метод
дальше   339
Соедините каждый паттерн с его описанием:
Паттерн Описание
Шаблонный Метод
Стратегия
Фабричный Метод
Инкапсуляция взаимозаменяемых 
вариантов поведения и выбор 
нужного варианта посредством 
делегирования
Субклассы определяют реализацию шагов алгоритма
Субклассы решают, какие 
конкретные классы создавать
Нарисуйте новую диаграмму классов после перемещения реализации prepareRecipe() в класс 
CaffeineBeverage:
Возьми в руку карандаш
 Решение
Кто и что делает?
решение
prepareRecipe()
boilWater()
pourInCup()
brew()
addCondiments()
CaffeineBeverage
brew()
addCondiments()
Coffee
brew()
addCondiments()
Tea

Существует много способов создания коллекций. Объекты можно 
разместить в контейнере Array, Stack, List, Hashmap — выбирайте сами. Каждый способ обладает своими достоинствами и недостатками. Но в какой-то 
момент клиенту потребуется перебрать все эти объекты, и когда это произойдет, собираетесь ли вы раскрывать реализацию коллекции? Надеемся, 
нет! Это было бы крайне непрофессионально. В этой главе вы узнаете, как 
предоставить клиенту механизм перебора объектов без раскрытия информации о способе их хранения. Также в ней будут описаны способы создания 
суперколлекций. А если этого недостаточно, вы узнаете кое-что новое относительно обязанностей объектов.
9 Паттерны Итератор и Компоновщик
Управляемые
 коллекции
Я всегда 
тщательно 
инкапсулирую свои 
коллекции!
342 глава 9
Мэл
Лу
Отличные новости! Теперь мы можем заказать аппетитный завтрак 
с блинчиками и обед в одном месте! Но похоже, у поваров возникла небольшая проблема...
Сенсация в Объектвиле: бистро объединяется с блинной!
слияние компаний
Они хотят использовать меню 
моей блинной для завтраков, 
а меню бистро — для обедов. 
Мы согласовали реализацию 
элементов меню...
...но не можем 
согласовать реализацию 
самих меню. Мой коллега хранит 
элементы в контейнере ArrayList, а я 
использовал Array. Ни один из нас 
не желает изменять свою реализацию... 
Для нее написано слишком много кода, 
который от нее зависит.
паттерны итератор и компоновщик
дальше   343
public class MenuItem {
 String name;
 String description;
 boolean vegetarian;
 double price;
 public MenuItem(String name, 
 String description, 
 boolean vegetarian, 
 double price) 
 {
 this.name = name;
 this.description = description;
 this.vegetarian = vegetarian;
 this.price = price;
 }
 
 public String getName() {
 return name;
 }
 
 public String getDescription() {
 return description;
 }
 
 public double getPrice() {
 return price;
 }
 
 public boolean isVegetarian() {
 return vegetarian;
 }
}
Проверяем элементы меню Бистро Вегетарианский сэндвич с беконом 
2.99
 (Соевый) Бекон с салатом и помидорами
Сэндвич с беконом 
2.99
 Бекон с салатом и помидорами
Суп дня 3.29
 Тарелка супа и картофельный салат
Хот- дог 3.05
 Хот-дог с кислой капустой, луком и сыром
Тушеные овощи и бурый рис 
3.99
 Рагу из тушеных овощей с бурым рисом
Завтрак K&B 2.99
 Оладьи с яичницей и тостами
Основной завтрак 2.99
 Оладьи с яичницей и колбасой
Оладьи с черникой 3.49
 Оладьи со свежей черникой
 и черничным сиропом
Вафли 3.59
 Вафли с черникой или клубникой
(на выбор клиента)
 Блинная
Объект MenuItem содержит 
несколько полей: имя, описание, флаг 
вегетарианского блюда и цена. Все эти 
значения передаются конструктору 
для инициализации объекта MenuItem.
Методы для чтения/
записи полей элемента 
меню.
По крайней мере, Лу и Мэл согласовали реализацию класса MenuItem. 
Рассмотрим содержимое обоих меню, 
а заодно познакомимся с реализацией.
В меню бистро много обеденных 
блюд, а меню блинной состоит из 
завтраков. С каждым элементом 
меню связывается название, 
описание и цена.
344 глава 9
public class PancakeHouseMenu {
 List<MenuItem> menuItems;
 public PancakeHouseMenu() {
 menuItems = new ArrayList<MenuItem>();
 
 addItem("K&B’s Pancake Breakfast", 
 "Pancakes with scrambled eggs, and toast", 
 true,
 2.99);
 addItem("Regular Pancake Breakfast", 
 "Pancakes with fried eggs, sausage", 
 false,
 2.99);
 addItem("Blueberry Pancakes",
 "Pancakes made with fresh blueberries",
 true,
 3.49);
 addItem("Waffles",
 "Waffles, with your choice of blueberries or strawberries",
 true,
 3.59);
 }
 public void addItem(String name, String description,
 boolean vegetarian, double price)
 {
 MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
 menuItems.add(menuItem);
 }
 public ArrayList<MenuItem> getMenuItems() {
 return menuItems;
 }
 // другие методы
}
Я выбрал 
ArrayList, чтобы 
меню можно было 
легко расширить.
Две реализации меню 
Давайте разберемся, о чем спорят Лу и Мэл. 
Оба повара потратили немало времени и 
сил на написание кода хранения элементов 
меню и другого кода, который от него зависит.
Лу хранит элементы 
меню в ArrayList.
Каждый элемент меню 
включается в ArrayList 
в конструкторе.
Чтобы добавить новый элемент 
меню, Лу создает новый объект 
MenuItem, задает все необходимые 
аргументы и включает созданный 
объект в ArrayList.
Лу написал большой объем кода, зависящего 
от реализации ArrayList. И он не хочет 
переписывать весь код заново!
Метод getMenuItems() возвращает 
список элементов меню.
Реализация меню блинной.
Для каждого объекта MenuItem 
задается имя, описание, признак 
вегетарианского блюда и цена.
два меню
паттерны итератор и компоновщик
дальше   345
public class DinerMenu {
 static final int MAX_ITEMS = 6;
 int numberOfItems = 0;
 MenuItem[] menuItems;
 
 public DinerMenu() {
 menuItems = new MenuItem[MAX_ITEMS];
 addItem("Vegetarian BLT",
 "(Fakin’) Bacon with lettuce & tomato on whole wheat", true, 2.99);
 addItem("BLT",
 "Bacon with lettuce & tomato on whole wheat", false, 2.99);
 addItem("Soup of the day",
 "Soup of the day, with a side of potato salad", false, 3.29);
 addItem("Hotdog",
 "A hot dog, with saurkraut, relish, onions, topped with cheese",
 false, 3.05);
 // a couple of other Diner Menu items added here
 }
 
 public void addItem(String name, String description, 
 boolean vegetarian, double price) 
 {
 MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
 if (numberOfItems >= MAX_ITEMS) {
 System.err.println("Sorry, menu is full! Can’t add item to menu");
 } else {
 menuItems[numberOfItems] = menuItem;
 numberOfItems = numberOfItems + 1;
 }
 }
 public MenuItem[] getMenuItems() {
 return menuItems;
 }
 // ...Другие методы меню...
}
А вот реализация Мэла.
Мэл выбрал другой подход: он использует 
массив Array, чтобы ограничить 
максимальный размер меню.
Мэл тоже создает элементы 
меню в конструкторе при помощи 
вспомогательного метода addItem().
Метод addItem() получает все 
параметры, необходимые для создания MenuItem, и создает объект. 
Он также проверяет, не нарушает ли новый объект максимальный размер массива.
Мэл ТОЖЕ написал большой объем кода, зависящего от 
выбранной им реализации меню. И он слишком занят, 
чтобы переписывать этот код заново.
Мэл ограничивает размер меню, 
чтобы не запоминать слишком 
много рецептов.
Метод getMenuItems() возвращает массив 
элементов меню.
Какой еще Arraylist... 
Я выбрал НОРМАЛЬНЫЙ 
массив, чтобы ограничить 
максимальный размер 
меню.
346 глава 9
Чтобы понять, какие сложности возникают с двумя разными представлениями меню, мы попробуем реализовать клиент, использующий оба меню. Допустим, новая 
компания, возникшая в результате слияния, наняла вас 
для создания официантки с поддержкой Java (не забывайте, что вы находитесь в Объектвиле!). Спецификация 
требует, чтобы официантка могла при необходимости напечатать сокращенное меню и даже определить, является 
ли блюдо вегетарианским, не обращаясь к повару!
Сначала просмотрим спецификацию, а затем шаг за шагом разберемся, что потребуется для ее реализации...
Какие проблемы создает наличие двух разных реализаций меню?
Официантка 
с поддержкой 
Java.
Спецификация официантки с поддержкой Java
Официантка с поддержкой Java: проект «Элис»
printMenu()
 — выводит каждый элемент меню
printBreakfastMenu()
 — выводит только блюда завтраков
printLunchMenu()
 — выводит только обеденные блюда
printVegetarianMenu()
 — выводит все вегетарианские блюда
isItemVegetarian(name)
 — по названию блюда возвращает true, если 
оно является вегетарианским, или false в противном случае
Спецификация 
официантки
официантка с поддержкой java
паттерны итератор и компоновщик
дальше   347
1
3
2
Чтобы вывести полное меню, необходимо вызвать метод getMenuItems() для всех элементов обеих реализаций. Обратите внимание: методы возвращают разные типы:
PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
ArrayList<MenuItem> breakfastItems = pancakeHouseMenu.getMenuItems();
DinerMenu dinerMenu = new DinerMenu();
MenuItem[] lunchItems = dinerMenu.getMenuItems();
Чтобы вывести меню блинной, мы перебираем элементы контейнера ArrayList, а для вывода меню бистро перебираются элементы 
Array.
Реализация каждого метода будет представлять собой вариацию на 
эту тему — содержимое двух меню будет перебираться в двух разных 
циклах. А если вдруг добавится новый ресторан со своей реализацией, то в программе будут использоваться три разных цикла.
for (int i = 0; i < breakfastItems.size(); i++) {
 MenuItem menuItem = breakfastItems.get(i);
 System.out.print(menuItem.getName() + " ");
 System.out.println(menuItem.getPrice() + " ");
 System.out.println(menuItem.getDescription());
}
for (int i = 0; i < lunchItems.length; i++) {
 MenuItem menuItem = lunchItems[i];
 System.out.print(menuItem.getName() + " ");
 System.out.println(menuItem.getPrice() + " ");
 System.out.println(menuItem.getDescription());
}
Методы внешне 
похожи, но вызовы 
возвращают 
разные типы.
Теперь нам 
придется 
написать два 
разных цикла для 
перебора двух 
реализаций меню...
...один цикл
для ArrayList...
другой —
для Array.
Здесь проявляются 
различия реализации: блюда 
для завтрака хранятся 
в ArrayList, а обеденные 
блюда — в Array.
Начнем с реализации метода printMenu():
Реализация спецификации: первая попытка
348 глава 9
? A. Мы программируем для конкретных реализаций PancakeHouseMenu и DinerMenu, а не для 
интерфейсов.
? B. Официантка не реализует Java 
Waitress API, а следовательно, не 
соответствует стандарту.
? C. Если мы решим перейти с DinerMenu на другое меню с реализацией в виде хеш-таблицы, нам придется изменять большой объем кода.
? D. Официантка должна знать, как 
в каждом объекте меню организована внутренняя коллекция элементов, 
а это нарушает инкапсуляцию.
? E. В реализации присутствует дублирование кода: метод printMenu() содержит два разных цикла для перебора 
двух разновидностей меню. А при появлении третьего меню понадобится 
еще один цикл.
? F. Реализация не использует язык 
MXML (Menu XML), что снижает ее 
универсальность.
Какие из следующих утверждений относятся к нашей реализации 
printMenu()? 
Мы оказались в затруднительном положении. Мэл и Лу не желают изменять свои реализации, потому что им придется переписать большой объем кода в соответствующих классах меню. Но если ни один из них не уступит, наша реализация официантки 
окажется сложной в сопровождении и расширении.
Хорошо бы найти механизм, позволяющий им реализовать единый интерфейс для 
своих меню (они и так достаточно близки, если не считать возвращаемого типа метода getMenuItems()). Это позволит нам свести к минимуму конкретные ссылки, 
а также избавиться от повторения циклов при переборе элементов меню.
Заманчиво, верно? Но как это сделать?
Что дальше?
что дальше?
Возьми в руку карандаш
паттерны итератор и компоновщик
дальше   349
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
ArrayList
Коллекция ArrayList 
объектов MenuItem
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Array
Коллекция 
Array объектов 
MenuItem
for (int i = 0; i < breakfastItems.size(); i++) {
 MenuItem menuItem = breakfastItems.get(i);
}
for (int i = 0; i < lunchItems.length; i++) {
 MenuItem menuItem = lunchItems[i];
}
Как инкапсулировать перебор элементов?
Инкапсулируйте то, что изменяется, — это едва ли не самое важное из всего, 
о чем говорится в книге. Понятно, что изменяется в данном случае: механизм 
перебора для разных коллекций объектов (элементов меню). Но как его инкапсулировать? Давайте подробно разберем эту идею...
1 Для перебора элементов ArrayList используются методы size() и get():
2 Для перебора элементов массива используется поле length 
объекта Array и синтаксис выборки элементов массива:
lunchItems[0]
lunchItems[1]
lunchItems[2]
lunchItems[3]
get(0)
get(1) get(2) get(3) Для получения элемента 
используется метод 
get().
Для получения элемента 
используются индексы 
элементов.
350 глава 9
3 Почему бы не создать объект (назовем его итератором), 
инкапсулирующий механизм перебора объектов 
в коллекции? Попробуем сделать это для ArrayList:
Iterator iterator = breakfastMenu.createIterator();
while (iterator.hasNext()) {
 MenuItem menuItem = iterator.next();
}
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
ArrayList Iterator
Запрашиваем 
у breakfastMenu 
итератор для 
перебора объектов 
MenuItem.
Пока остаются элементы...
Получить следующий 
элемент.
4 Теперь сделаем то же для Array:
Iterator iterator = lunchMenu.createIterator();
while (iterator.hasNext()) {
 MenuItem menuItem = iterator.next();
}
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Array
lunchItems[0]
lunchItems[1]
lunchItems[2]
lunchItems[3]
Iterator
Клиент просто вызывает 
hasNext() и next(); во внутренней 
реализации итератор вызывает 
get() для ArrayList.
Аналогичная ситуация: клиент 
вызывает hasNext() и next(), 
а итератор во внутренней 
реализации индексирует Array.
Код точно 
такой же, как 
для ArrayList.
get(0)
get(1)
get(2)
get(3)
next()
next()
инкапсуляция итераций
паттерны итератор и компоновщик
дальше   351
Паттерн Итератор
Похоже, наш план инкапсуляции перебора элементов вполне реален. И как вы, вероятно, уже догадались, для решения этой задачи существует паттерн проектирования, 
который называется Итератор.
Первое, что необходимо знать о паттерне Итератор, — то, что он зависит от специального интерфейса (допустим, Iterator). Одна из возможных форм интерфейса Iterator:
hasNext()
next()
<<interface>>
Iterator
Метод hasNext() 
проверяет, остались ли 
в коллекции элементы 
для перебора.
Метод next() 
возвращает 
следующий объект 
в коллекции.
При наличии такого интерфейса мы можем реализовать 
итераторы для любых видов коллекций объектов: массивов, списков, хеш-карт... Допустим, мы хотим реализовать итератор для коллекции Array из нашего примера. 
Реализация будет выглядеть так:
DinerMenuIterator — 
реализация Iterator 
для перебора массива
объектов MenuItem. 
hasNext()
next()
<<interface>>
Iterator
hasNext()
next()
DinerMenuIterator
Давайте реализуем этот итератор и свяжем его с коллекцией DinerMenu, чтобы вы лучше поняли, как работает 
механизм перебора...
Под термином КОЛЛЕКЦИЯ мы 
подразумеваем группу объектов. 
Такие объекты могут храниться в разных 
структурах данных: списках, массивах, 
хеш-картах... но при этом все равно 
остаются коллекциями.
352 глава 9
public interface Iterator {
 boolean hasNext();
 MenuItem next();
}
Добавление итератора в DinerMenu
Два метода интерфейса:
hasNext() возвращает флаг, 
который указывает, остались ли 
в коллекции элементы для перебора...
Чтобы добавить итератор в DinerMenu, сначала необходимо определить 
интерфейс Iterator:
...а метод next() возвращает 
следующий элемент.
Теперь необходимо реализовать конкретный итератор для коллекции DinerMenu:
public class DinerMenuIterator implements Iterator {
 MenuItem[] items;
 int position = 0;
 public DinerMenuIterator(MenuItem[] items) {
 this.items = items;
 }
 public MenuItem next() {
 MenuItem menuItem = items[position];
 position = position + 1;
 return menuItem;
 }
 public boolean hasNext() {
 if (position >= items.length || items[position] == null) {
 return false;
 } else {
 return true;
 }
 }
}
Реализуем интерфейс 
Iterator.
Конструктор получает 
массив объектов, для перебора 
которых создается итератор.
В переменной position хранится 
текущая позиция перебора 
в массиве.
Метод next() возвращает 
следующий элемент массива 
и увеличивает текущую позицию.
Метод hasNext() 
возвращает true, если 
в массиве еще остались 
элементы для перебора. 
Так как для меню бистро выделен 
массив максимального размера, нужно 
проверить не только достижение 
границы массива, но и равенство 
следующего элемента null (признак 
последнего элемента). 
использование итератора
паттерны итератор и компоновщик
дальше   353
public class DinerMenu {
 static final int MAX_ITEMS = 6;
 int numberOfItems = 0;
 MenuItem[] menuItems;
 
 // конструктор
 
 // addItem
 public MenuItem[] getMenuItems() {
 return menuItems;
 }
 
 public Iterator createIterator() {
 return new DinerMenuIterator(menuItems);
 }
 // другие методы
}
Переработка DinerMenu с использованием итератора
Итак, у нас есть итератор. Пора интегрировать его с DinerMenu; для этого необходимо 
лишь добавить один метод, который создает объект DinerMenuIterator и возвращает 
его клиенту:
Метод getMenuItems() нам больше 
не понадобится. Более того, его 
присутствие нежелательно, потому 
что он раскрывает внутреннюю 
реализацию!
Метод createIterator() создает 
объект DinerMenuIterator 
для массива menuItems 
и возвращает его клиенту.
Метод возвращает интерфейс Iterator. Клиенту 
не нужно знать ни то, как коллекция menuItems 
хранится в DinerMenu, ни то, как реализован 
DinerMenuIterator. Клиент просто использует 
итератор для перебора элементов.
Самостоятельно реализуйте итератор для меню блинной 
(PancakeHouseIterator) и внесите изменения, необходимые
для его интеграции с PancakeHouseMenu. 
Упражнение
354 глава 9
Исправление кода Waitress
public class Waitress {
 PancakeHouseMenu pancakeHouseMenu;
 DinerMenu dinerMenu;
 public Waitress(PancakeHouseMenu pancakeHouseMenu, DinerMenu dinerMenu) {
 this.pancakeHouseMenu = pancakeHouseMenu;
 this.dinerMenu = dinerMenu;
 }
 public void printMenu() {
 Iterator pancakeIterator = pancakeHouseMenu.createIterator();
 Iterator dinerIterator = dinerMenu.createIterator();
 System.out.println("MENU\n----\nBREAKFAST");
 printMenu(pancakeIterator);
 System.out.println("\nLUNCH");
 printMenu(dinerIterator);
 }
 private void printMenu(Iterator iterator) {
 while (iterator.hasNext()) {
 MenuItem menuItem = iterator.next();
 System.out.print(menuItem.getName() + ", ");
 System.out.print(menuItem.getPrice() + " -- ");
 System.out.println(menuItem.getDescription());
 }
 }
 // другие методы
}
В конструкторе 
передаются два объекта 
меню.
Метод printMenu() 
теперь создает два 
итератора,
по одному для 
каждого меню.
А затем вызывает 
перегруженный метод 
printMenu() для каждого 
итератора.
Перегруженный 
метод printMenu() 
использует Iterator 
для перебора 
и вывода элементов 
меню.
В этой версии 
используется
один цикл.
Проверяем, 
остались ли еще 
элементы.
Получаем 
следующий 
элемент.
Выводим 
название, цену 
и описание 
текущего 
элемента.
Теперь поддержку итераторов необходимо интегрировать в реализацию официантки. Попутно мы избавимся от избыточности в коде. Процесс интеграции весьма прямолинеен: сначала мы создаем метод 
printMenu(), которому передается Iterator, а затем 
вызываем createIterator() для каждого меню, получаем Iterator и передаем его новому методу. Новая версия 
с поддержкой 
итераторов.
использование итератора
паттерны итератор и компоновщик
дальше   355
Тестирование кода
File Edit Window Help GreenEggs&Ham
% java DinerMenuTestDrive
MENU
----
BREAKFAST
K&B’s Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs, and toast
Regular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage
Blueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries
Waffles, 3.59 -- Waffles, with your choice of blueberries or strawberries
LUNCH
Vegetarian BLT, 2.99 -- (Fakin’) Bacon with lettuce & tomato on whole wheat
BLT, 2.99 -- Bacon with lettuce & tomato on whole wheat
Soup of the day, 3.29 -- Soup of the day, with a side of potato salad
Hotdog, 3.05 -- A hot dog, with saurkraut, relish, onions, topped with cheese
Steamed Veggies and Brown Rice, 3.99 -- Steamed vegetables over brown rice
Pasta, 3.89 -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
%
public class MenuTestDrive {
 public static void main(String args[]) {
 PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
 DinerMenu dinerMenu = new DinerMenu();
 Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu);
 waitress.printMenu();
 }
}
Создаем новые меню.
Создаем объект 
Waitress и передаем ему созданные 
объекты меню.
А затем выводим их 
содержимое.
Запускаем тест...
Система готова, можно переходить к тестированию. Напишем небольшую тестовую программу и посмотрим, как работает официантка...
Сначала перебираем 
меню завтраков...
...а затем 
меню 
обедов — 
и все
в одном 
цикле.
356 глава 9
Что мы сделали? Вот это да! Код 
остался прежним — 
добавился только метод 
createIterator()!
Гамбургер
Прежде всего мы осчастливили поваров обоих заведений. Проблема с различиями успешно решена, а существующий код сохранен. 
После создания PancakeHouseMenuIterator 
и DinerMenuIterator им осталось лишь добавить метод createIterator() — и ничего более.
Заодно мы упростили свою работу — класс 
Waitress стал значительно проще в сопровождении и расширении. Давайте еще раз внимательно рассмотрим, что же было сделано, 
и проанализируем последствия:
Старая реализация, сложная 
в сопровождении
Новая реализация 
на базе итераторов
Плохая инкапсуляция работы 
с меню; мы видим, что одна реализация использует Array, а другая — 
ArrayList.
Клиентский код привязан к конкретным классам (MenuItem[ ] 
и ArrayList).
Клиентский код использует интерфейс (Iterator).
Для перебора элементов необходимы два цикла.
Достаточно одного цикла, который 
полиморфно обрабатывает элементы любой коллекции, реализующей Iterator.
Реализации надежно инкапсулированы. Клиентский код не знает, как 
классы меню хранят свои коллекции элементов.
Клиентский код привязан к двум 
конкретным классам меню, несмотря на почти полное совпадение их 
интерфейсов.
Интерфейсы двух классов меню 
теперь полностью совпадают... 
Но код Waitress все еще привязан 
к двум конкретным классам меню. 
Эту проблему необходимо решить.
сравнение реализаций
паттерны итератор и компоновщик
дальше   357
hasNext()
next()
<<interface>>
Iterator
Прежде чем переходить к усовершенствованиям, рассмотрим 
текущую архитектуру «в перспективе».
Итератор позволяет перебирать 
элементы коллекции без загромождения 
интерфейса коллекции методами, 
обеспечивающими поддержку перебора. 
Кроме того, реализация итератора может 
быть выведена за пределы коллекции; 
иначе говоря, мы инкапсулировали процесс 
перебора.
Классы меню реализуют новый 
метод createIterator(); они 
отвечают за создание итератора 
для соответствующей реализации 
меню.
printMenu()
Waitress
createIterator()
PancakeHouseMenu
menuItems
createIterator()
DinerMenu
menuItems
hasNext()
next()
DinerMenuIterator
hasNext()
next()
PancakeHouseMenuIterator
Взгляд на текущую архитектуру
Два класса содержат 
практически одинаковые 
наборы методов, но не 
реализуют общий интерфейс. 
Мы исправим этот 
недостаток.
Мы используем 
общий интерфейс 
Iterator, реализованный двумя 
конкретными 
классами.
Итератор позволяет отделить 
клиентский код от фактической 
реализации конкретного класса. 
Официантке не нужно знать, 
как реализовано меню — на базе 
Array, ArrayList и т. д.; для нее 
важно лишь то, что она может 
получить Iterator для перебора 
элементов.
358 глава 9
Вносим усовершенствования...
Итак, наборы методов PancakeHouseMenu и DinerMenu полностью совпадают, но мы еще не определили для них общий интерфейс. Сейчас мы сделаем это. 
Законный вопрос: почему мы не воспользовались интерфейсом Iterator языка Java? Это было сделано 
для того, чтобы вы могли при необходимости построить итератор с нуля. Теперь, когда это было сделано, мы переключимся на интерфейс Iterator языка Java, потому что он обладает рядом преимуществ 
по сравнению с нашей доморощенной реализацией. Что это за преимущества? Скоро увидите.
Для начала рассмотрим интерфейс java.util.Iterator: 
hasNext()
next()
remove()
<<interface>>
Iterator
Почти не отличается от 
предыдущей реализации.
Добавлен метод для удаления 
последнего элемента, 
возвращаемого методом next() 
коллекции.
В: А если мне не нужна возможность удаления элементов 
из коллекции?
О: Реализация метода remove() не считается обязательной. 
Но, разумеется, сам метод должен присутствовать, так как он 
является частью интерфейса Iterator. Если вы не разрешаете remove() в своем итераторе, инициируйте исключение java.
lang.UnsupportedOperationException. В документации Iterator API 
указано, что это исключение может инициироваться в remove(), 
и любой нормальный клиент будет проверять его при вызове метода remove().
В: Как метод remove() работает с несколькими программными потоками, которые могут использовать разные итераторы 
для одной коллекции объектов?
О: Поведение remove() для коллекций, изменяющихся в процессе перебора, не определено. Будьте внимательны при программировании параллельного доступа к коллекции в многопоточной модели.
Проще простого: нужно сменить интерфейс, расширяемый классами PancakeHouseMenuIterator 
и DinerMenuIterator, верно? Почти... Хотя на самом деле еще проще. Не только пакет java.util содержит собственный интерфейс Iterator, но и у класса ArrayList имеется метод iterator(), возвращающий итератор, то есть для ArrayList реализовывать итератор вообще не нужно. Тем не менее для 
DinerMenu это сделать все равно придется, так как класс Array не поддерживает метод iterator().
часто Задаваемые вопросы
использование итераторов java
паттерны итератор и компоновщик
дальше   359
Интеграция с java.util.Iterator
 public Iterator<MenuItem> createIterator() {
 return menuItems.iterator();
 }
Начнем с класса PancakeHouseMenu; перевести его на java.util.Iterator будет 
совсем несложно. Достаточно удалить класс PancakeHouseMenuIterator, добавить директиву import java.util.Iterator в начало PancakeHouseMenu и изменить одну строку в PancakeHouseMenu:
Вместо создания собственного 
итератора мы просто вызываем 
метод iterator() для объекта 
menuItems.
На этом доработка PancakeHouseMenu завершена.
Теперь необходимо внести изменения, позволяющие DinerMenu работать с java.util.Iterator.
Сначала импортируем java.util.
Iterator — интерфейс, который 
мы собираемся реализовать.
Текущая реализация вообще 
не изменяется...
Не забывайте, что метод remove() не 
является обязательным в интерфейсе 
Iterator. Удаление позиций меню 
официанткой не имеет смысла, поэтому 
если она попытается это сделать, мы 
просто выдаем исключение.
import java.util.Iterator;
 
public class DinerMenuIterator implements Iterator<MenuItem> {
 MenuItem[] items;
 int position = 0;
 public DinerMenuIterator(MenuItem[] items) {
 this.items = items;
 }
 public MenuItem next() {
 // Реализация
 }
 public boolean hasNext() {
 // Реализация
 }
 
 public void remove() {
 throw new UnsupportedOperationException
 ("You shouldn't be trying to remove menu items.");
 }
}
360 глава 9
Работа почти завершена...
Осталось только дать классам Menu общий интерфейс и немного переработать код официантки. Интерфейс Menu очень прост: возможно, 
когда-нибудь мы дополним его новыми методами (скажем, addItem), но 
пока этот метод не будет включен в открытый интерфейс:
public interface Menu {
 public Iterator<MenuItem> createIterator();
}
Простой интерфейс 
с единственным методом, 
который возвращает клиентам 
итератор для элементов меню.
Теперь мы должны добавить директиву implements Menu в определения 
классов PancakeHouseMenu и DinerMenu, а также обновить код Waitress:
import java.util.Iterator;
public class Waitress {
 Menu pancakeHouseMenu;
 Menu dinerMenu;
 public Waitress(Menu pancakeHouseMenu, Menu dinerMenu) {
 this.pancakeHouseMenu = pancakeHouseMenu;
 this.dinerMenu = dinerMenu;
 }
 public void printMenu() {
 Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();
 Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();
 System.out.println("MENU\n----\nBREAKFAST");
 printMenu(pancakeIterator);
 System.out.println("\nLUNCH");
 printMenu(dinerIterator);
 }
 private void printMenu(Iterator iterator) {
 while (iterator.hasNext()) {
 MenuItem menuItem = (MenuItem)iterator.next();
 System.out.print(menuItem.getName() + ", ");
 System.out.print(menuItem.getPrice() + " -- ");
 System.out.println(menuItem.getDescription());
 }
 }
 // другие методы
}
Класс Waitress тоже использует java.util.Iterator.
Конкретные классы 
Menu заменяются 
интерфейсом Menu.
Ничего не 
меняется.
переработка официантки
паттерны итератор и компоновщик
дальше   361
Классы PancakeHouseMenu и DinerMenu реализуют интерфейс 
Menu. Класс Waitress может обращаться к объекту меню как к реализации интерфейса, а не как к экземпляру конкретного класса. Таким 
образом, мы сокращаем зависимости между Waitress и конкретными 
классами — «программируем на уровне интерфейса, а не реализации».
Новый интерфейс Menu состоит из единственного метода createIterator(), реализуемого классами PancakeHouseMenu и DinerMenu. 
Каждый класс несет ответственность за создание конкретного итератора, соответствующего внутренней реализации коллекции.
printMenu()
Waitress
createIterator()
PancakeHouseMenu
menuItems
createIterator()
DinerMenu
menuItems
hasNext()
next()
remove()
<<interface>>
Iterator
Новый интерфейс Menu 
определяет новый метод createIterator().
Теперь класс Waitress 
работает только 
с реализациями Menu 
и Iterator. 
Класс Waitress отделен от реализации меню, поэтому теперь 
реализация Iterator может использоваться для перебора любых меню, независимо от того, 
какой контейнер используется 
для хранения их элементов.
PancakeHouseMenu и DinerMenu теперь 
реализуют интерфейс Menu; это 
означает, что они должны реализовать 
новый метод createIterator().
Метод createIterator() 
класса DinerMenu 
возвращает 
DinerMenuIterator, потому что именно 
такой итератор необходим для перебора Каждая конкретная массива Array.
реализация Menu отвечает за создание соответствующего конкретного итератора.
Что нам это дает?
Решение проблемы 
зависимости Waitress от 
от реализации MenuItems.
createIterator()
<<interface>>
Menu
createIterator()
hasNext()
next()
remove()
PancakeHouseMenuIterator
hasNext()
next()
remove()
DinerMenuIterator
Мы используем 
итератор для 
ArrayList из java.util. 
Этот итератор нам 
больше не нужен.
362 глава 9
Определение паттерна Итератор
Паттерн Итератор предоставляет механизм последовательного перебора элементов коллекции без раскрытия ее внутреннего представления.
Вы уже видели, как паттерн Итератор реализуется 
в самостоятельно написанных итераторах. Также 
было показано, как итераторы поддерживаются 
в некоторых классах коллекций языка Java (таких, 
как ArrayList). Пора ознакомиться с формальным 
определением паттерна:
Итак, паттерн позволяет перебирать элементы 
коллекции, не зная, как реализована коллекция. 
Мы уже рассмотрели пример с двумя реализациями меню. Однако применение итераторов в ваших 
собственных архитектурах приводит и к другим, не 
менее важным последствиям: при наличии универсального механизма перебора элементов можно 
написать полиморфный код, который работает 
с любыми коллекциями, — как метод printMenu(), 
который работает с элементами, хранящимися 
в Array, ArrayList или в любой другой коллекции, 
способной создать Iterator.
Применение паттерна Итератор имеет и другое 
важное последствие для архитектуры системы: ответственность за перебор элементов передается 
от объекта коллекции объекту итератора. Это обстоятельство не только упрощает интерфейс и реализацию коллекции, но и избавляет коллекцию от 
посторонних обязанностей (ее главной задачей является управление объектами, а не перебор).
Паттерн Итератор 
обеспечивает перебор 
элементов коллекции без 
раскрытия реализации.
Кроме того, перебор 
элементов выполняется 
объектом итератора, а не 
самой коллекцией. Это 
упрощает интерфейс 
и реализацию коллекции, 
а также способствует более 
логичному распределению 
обязанностей.
определение паттерна итератор
паттерны итератор и компоновщик
дальше   363
hasNext()
next()
remove()
<<interface>>
Iterator
hasNext()
next()
remove()
ConcreteIterator
createIterator()
<<interface>>
Aggregate
createIterator()
ConcreteAggregate
Клиент
ConcreteAggregate 
содержит коллекцию 
объектов и реализует 
метод, который 
возвращает итератор для 
этой коллекции.
Каждая 
разновидность 
ConcreteAggregate 
отвечает за 
создание экземпляра 
ConcreteIterator, 
который может 
использоваться 
для перебора своей 
коллекции объектов.
Интерфейс Iterator 
должен быть 
реализован всеми 
итераторами 
(как и входящие 
в него методы 
перебора элементов). 
В данном случае мы 
используем java.util.
Iterator. Если вы не 
хотите использовать 
интерфейс Iterator 
языка Java, ничто 
не мешает вам 
создать собственный 
интерфейс.
Наличие общего интерфейса 
удобно для клиента, поскольку 
клиент отделяется от 
реализации коллекции объектов.
Диаграмма классов паттерна Итератор очень похожа на диаграмму классов другого 
паттерна, описанного ранее. Что это за паттерн? Подсказка: создаваемый экземпляр 
выбирается субклассом.
ConcreteIterator отвечает 
за управление текущей 
позицией перебора.
Мозговой
штурм
Следующая диаграмма классов поможет лучше понять суть итератора.
Структура паттерна Итератор
364 глава 9
принцип одной обязанности
Принцип одной обязанности
Принцип проектирования
Класс должен иметь только одну 
причину для изменения. 
А если все-таки разрешить классам коллекций реализовать как управление объектами, так и методы перебора? Да, это приведет к увеличению количества методов 
коллекции, ну и что? Чем это плохо?
Чтобы понять, чем это плохо, необходимо сначала 
осознать один факт: поручая классу не только его непосредственную задачу (управление коллекцией объектов), но и дополнительные задачи (перебор), мы создаем две возможные причины для изменения. Теперь 
измениться может как внутренняя реализация коллекции, так и механизм перебора. Как видите, наш старый 
знакомый — ИЗМЕНЕНИЕ — снова оказывается в центре очередного принципа проектирования.
Мы знаем, что изменений в классах следует по возможности избегать — модификация кода обычно сопровождается массой проблем. Наличие двух причин для 
изменения повышает вероятность того, что класс изменится в будущем, а если это все же произойдет, то изменения повлияют на два аспекта архитектуры.
Что делать? Принцип указывает на то, что каждому 
классу должна быть выделена одна — и только одна! — 
обязанность.
Как это часто бывает, в реальной жизни все несколько 
сложнее: разделение обязанностей в архитектуре является одной из самых сложных задач. Наш мозг склонен 
объединять аспекты поведения даже в том случае, если 
в действительности речь идет о двух разных обязанностях. Единственный путь к ее успешному решению — 
анализ архитектуры и отслеживание возможных причин изменения классов в ходе роста системы.
Каждая обязанность 
класса является областью 
потенциальных изменений. 
Несколько обязанностей — 
несколько причин для 
изменения. 
Принцип рекомендует 
ограничить каждый класс 
одной обязанностью.
Связность — термин, 
часто используемый 
для оценки логического единства функций 
класса или модуля.
Мы говорим, что модуль или класс обладает высокой связностью, если он спроектирован для 
выполнения группы взаимосвязанных 
функций. Классы с низкой связностью проектируются на основе набора разрозненных функций.
Концепция связности является более 
общей, чем принцип одной обязанности, но эти два понятия тесно связаны. 
Классы, соответствующие принципу, 
обычно обладают высокой связностью и более просты в сопровождении, чем классы со многими обязанностями и низкой связностью.
паттерны итератор и компоновщик
дальше   365
hasNext()
next()
remove()
Iterator
hasNext()
next()
remove()
addCard()
removeCard()
shuffle()
DeckOfCards
setName()
setAddress()
setPhoneNumber()
save()
load()
Person
dial()
hangUp()
talk()
sendData()
flash()
Phone
getCount()
getState()
getLocation()
GumballMachine
add()
remove()
checkOut()
saveForLater()
ShoppingCart
login()
signup()
move()
fire()
rest()
Game
Проанализируйте следующие классы и определите, какие из них обладают множественными обязанностями.
ОСТОРОЖНО, ОПАСНАЯ ЗОНА! 
БЕРЕГИТЕСЬ НЕОБОСНОВАННЫХ 
ДОПУЩЕНИЙ!
getHighScore()
getName()
Player
Определите, какой связностью — высокой или низкой — 
обладают следующие классы.
2
login()
signup()
move()
fire()
rest()
getHighScore()
getName()
Game
move()
fire()
rest()
PlayerActions
login()
signup()
GameSession
Мозговой
штурм
Мозговой
штурм
366 глава 9
вопросы и ответы
В: В других книгах я видел классы 
итераторов с методами first(), next(), 
isDone() и currentItem(). Почему здесь 
используются другие методы?
О: Это «классические» имена методов. 
Со временем они изменились, и теперь 
в java.util.Iterator входят методы next(), 
hasNext() и даже remove().
Классические методы next() и currentItem() 
в java.util были объединены. Метод isDone() 
превратился в hasNext(), а у метода first() 
нет прямого аналога. Дело в том, что в 
Java новый итератор обычно запрашивается перед началом перебора. Впрочем, 
принципиальных различий между этими 
интерфейсами нет, а вы можете наделить 
свои итераторы новыми аспектами поведения (примером такого расширения служит 
метод remove() в java.util.Iterator).
В: Говорят, итераторы бывают «внутренними» и «внешними». Что это такое? 
И какую разновидность мы реализовали 
в своем примере?
О: Мы реализовали внешний итератор — клиент управляет перебором, вызывая метод next() для перехода к следующему элементу. Перебором элементов 
при использовании внутреннего итератора управляет сам итератор. В этом случае вы должны указать, что ему делать 
с текущим элементом в ходе перебора 
(передавая итератору ссылку на выполняемую операцию). Внутренние итераторы 
уступают внешним в гибкости, поскольку 
клиент не управляет перебором. С другой 
стороны, кто-то сочтет, что ими проще 
пользоваться.
В: Можно ли реализовать итератор, 
который перебирает элементы не только в прямом, но и в обратном направлении?
О: Конечно. В этом случае итератор 
обычно дополняется двумя новыми методами: для перехода к предыдущему 
элементу и для проверки достижения начала коллекции. Библиотека Java Collection 
Framework предоставляет другой тип интерфейса итераторов, который называется 
ListIterator. В нем стандартный интерфейс 
Iterator дополняется методом previous() 
и еще несколькими методами. Итератор 
поддерживается всеми коллекциями, реализующими интерфейс List.
В: Кто определяет порядок перебора 
в неупорядоченных коллекциях, таких 
как Hashtable?
О: Итератор не устанавливает определенный порядок перебора. Сама коллекция может быть неупорядоченной, она 
даже может содержать дубликаты. Таким 
образом, порядок перебора определяется свойствами коллекции и реализацией. 
В общем случае не следует делать никаких допущений относительно порядка перебора, если только в описании коллекции 
явно не указано обратное.
В: Вы упомянули о возможности 
написания «полиморфного кода» с использованием итератора; можно объяснить подробнее?
О: При написании метода, которому 
в параметре передается реализация 
Iterator, мы применяем полиморфный 
перебор. Иначе говоря, такой код может 
перебирать элементы любой коллекции, 
если только она поддерживает Iterator. 
При этом нас не интересует, как реализована коллекция, — мы все равно 
можем написать код для перебора ее 
элементов.
В: Если я работаю на Java, вероятно, мне стоит всегда использовать интерфейс java.util.Iterator, чтобы я мог 
использовать свои реализации итераторов с классами, поддерживающими 
итераторы Java?
О: Вероятно. Общий интерфейс Iterator 
безусловно упростит использование ваших коллекций с коллекциями Java (такими, как ArrayList и Vector).
В: Я видел в Java интерфейс 
Enumeration, он тоже реализует паттерн 
Iterator?
О: Мы уже говорили на эту тему в главе, 
посвященной паттерну Адаптер. Помните? 
Java.util.Enumeration — старая реализация 
Iterator, которая была заменена java.util.
Iterator. Интерфейс Enumeration содержит 
два метода: hasMoreElements() (соответствует hasNext()) и nextElement() (соответствует next()). Вероятно, вам стоит 
использовать интерфейс Iterator вместо 
Enumeration, так как он поддерживается 
большим количеством классов Java.
В: Расширенные циклы for в Java както связаны с итераторами?
О: Хороший вопрос! Да, это так, и чтобы 
ответить на этот вопрос, необходимо понять смысл другого интерфейса, а именно 
интерфейса Iterable языка Java. Самое время познакомиться с ним поближе.
часто Задаваемые вопросы
паттерны итератор и компоновщик
дальше   367
Знакомьтесь: интерфейс Iterable языка Java
Вы уже освоили интерфейс Iterator языка Java, но есть и другой интерфейс, о котором необходимо знать: Iterable. Интерфейс Iterable 
реализуется всеми типами коллекций в Java. И знаете что? Вы уже использовали этот интерфейс в коде, работающем с ArrayList. Интерфейс Iterable выглядит так:
iterator()
+ forEach()
+ spliterator()
<<interface>>
Iterable
add()
addAll()
clear()
contains()
containsAll()
equals()
hashCode()
isEmpty()
iterator()
remove()
removeAll()
retainAll()
size()
toArray()
<<interface>>
Collection
next()
hasNext()
+ remove()
<<interface>>
Iterator
Интерфейс Iterable 
включает метод 
iterator(), который 
возвращает итератор, 
реализующий 
интерфейс Iterator.
Все классы коллекций 
(такие, как ArrayList) 
реализуют интерфейс 
Collection, производный 
от интерфейса Iterable, 
поэтому все классы 
коллекций являются 
реализациями Iterable.
Интерфейс Iterator 
вам уже знаком; мы 
использовали его 
с итераторами Diner 
и Pancake house.
Интерфейс 
Iterable.
Если класс реализует Iterable, мы знаем, что класс реализует метод iterator(). Этот метод возвращает итератор, реализующий 
интерфейс Iterator. Интерфейс также включает метод по умолчанию forEach(), который может использоваться как еще один способ перебора коллекций. Помимо этого, Java предоставляет ряд 
синтаксических удобств для перебора в расширенных циклах for. 
Давайте посмотрим, как они работают.
Интерфейс Iterable 
также включает метод 
spliterator(), который 
предоставляет еще более 
удобные средства для 
перебора коллекций.
368 глава 9
расширенный цикл for
Расширенный цикл for в языке Java
Возьмем объект, класс которого реализует интерфейс Iterable… Почему бы не коллекцию ArrayList, 
которая использовалась для представления позиций меню Pancake House:
List<MenuItem> menuItems = new ArrayList<MenuItem>();
Содержимое ArrayList можно перебирать так, как мы это делали ранее:
Iterator iterator = menu.iterator();
while (iterator.hasNext()) {
MenuItem menuItem = iterator.next();
System.out.print(menuItem.getName() + ", ");
System.out.print(menuItem.getPrice() + " -- ");
System.out.println(menuItem.getDescription());
}
Но так как мы знаем, что ArrayList реализует Iterable, также можно воспользоваться расширенным циклом for языка Java для более компактной записи:
for (MenuItem item: menu) {
System.out.print(menuItem.getName() + ", ");
System.out.print(menuItem.getPrice() + " -- ");
System.out.println(menuItem.getDescription());
}
В этом случае можно 
расстаться с явным 
использованием 
итератора, а также 
методами hasNext() 
и next().
Так мы перебирали 
содержимое коллекций 
до сих пор: при помощи 
итератора с методами 
hasNext() и next().
Отличный вариант использования 
итераторов, который вдобавок упрощает 
код, — вызовы hasNext() и next() становятся 
лишними. А нельзя ли так же переработать 
код Waitress для использования Iterable 
и расширенного цикла for при работе 
с меню?
паттерны итератор и компоновщик
дальше   369
Не торопитесь: Array не реализует Iterable
public void printMenu(Iterable<MenuItem> iterable) {
for (MenuItem menuItem : iterable) {
// print menuItem
}
}
то при попытке передать массив lunchItems методу printMenu() вы получите ошибку компилятора:
printMenu(lunchItems);
потому что Array не реализует интерфейс Iterable, как говорилось выше.
Если сохранить оба цикла в коде Waitress, мы возвращаемся к исходной точке: Waitress снова зависит от агрегатных типов, используемых для хранения меню, и содержит повторяющийся код 
циклов: для ArrayList и для Array.
Что же делать? У проблемы есть несколько решений, но все они уводят нас в сторону от основной 
темы, как и рефакторинг кода. В конце концов, глава посвящена паттерну Iterator языка Java, а не 
интерфейсу Iterable. К счастью, если вы знаете интерфейс Iterable, то вы также знаете о его связях с интерфейсом Iterator языка Java и паттерном Итератор. Так давайте двигаться дальше: ведь 
у нас уже имеется отличная реализация, хотя в ней и не используются синтаксические удобства 
цикла for языка Java.
Будет работать только с объектом ArrayList, 
используемым для меню Pancake House.
Ошибка компиляции! Array не реализует Iterable.
breakfastItems.forEach(item -> System.out.println(item));
Реализация Iterable – в данном 
случае ArrayList с позициями 
меню Pancake House. Вызываем forEach()…
…и передаем лямбда-выражение, 
которое получает объект menuItem 
и просто выводит его.
Таким образом, этот 
код выводит каждый 
элемент коллекции.
У нас плохие новости: возможно, в Diner приняли не лучшее решение, выбрав 
Array как основу для меню. Оказывается, массив Array не является коллекцией 
Java и поэтому не реализует интерфейс Iterable. Этот факт не позволяет нам консолидировать наш код Waitress в один метод, который получает объект Iterable и 
использует как с breakfastItems (Pancake House), так и с lunchItems (Diner). Если 
вы измените метод printMenu() класса Waitress, чтобы он получал Iterable вместо 
Iterator, и используете цикл for-each вместо API Iterator: 
Для любознательных
Вероятно, вы обратили внимание на метод forEach() в меню Iterable. Этот метод 
становится основой для расширенных циклов for в Java, но он также может 
использоваться напрямую с Iterable. Вот как он работает:
370 глава 9
новое слияние 
Хорошо, что вы занялись 
паттерном Итератор, потому 
что в бюро поглощений и слияний 
Объектвиля состоялась очередная сделка... 
Мы объединяемся с кафе и будем 
поддерживать его меню.
Не вешай нос. 
Я уверен, что мы сможем 
адаптировать их меню для 
паттерна Итератор.
А мы-то думали, что 
проблем и так хватает. Что 
будем делать? 
паттерны итератор и компоновщик
дальше   371
Знакомство с классом CafeMenu
public class CafeMenu {
 Map<String, MenuItem> menuItems = new HashMap<String, MenuItem>();
 
 public CafeMenu() {
 addItem("Veggie Burger and Air Fries",
 "Veggie burger on a whole wheat bun, lettuce, tomato, and fries",
 true, 3.99);
 addItem("Soup of the day",
 "A cup of the soup of the day, with a side salad",
 false, 3.69);
 addItem("Burrito",
 "A large burrito, with whole pinto beans, salsa, guacamole",
 true, 4.29);
 }
 public void addItem(String name, String description, 
 boolean vegetarian, double price) 
 {
 MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
 menuItems.put(menuItem.getName(), menuItem);
 }
 public Map<String, MenuItem> getItems() {
 return menuItems;
 }
}
Перед вами код меню кафе. Вроде бы его интеграция в нашу инфраструктуру не вызовет особых проблем... Давайте проверим.
Класс CafeMenu не реализует 
наш интерфейс Menu, но эта 
проблема легко решается.
Меню кафе хранится в коллекции 
HashMap. Поддерживает ли эта 
коллекция Iterator? Скоро узнаем...
Элементы CafeMenu, как и элементы других 
меню, инициализируются в конструкторе.
Здесь мы создаем новый 
элемент MenuItem и добавляем 
его в хеш-таблицу menuItems.
А этот метод нам не понадобится.
Прежде чем заглядывать на следующую страницу, запишите три основные задачи, 
которые необходимо решить для интеграции кода в нашу инфраструктуру:
1. 
2. 
3. 
Ключ — название элемента меню.
Значение — объект menuItem.
Возьми в руку карандаш
372 глава 9
переработка кода
public class CafeMenu implements Menu {
 Map<String, MenuItem> menuItems = new HashMap<String, MenuItem>();
 
 public CafeMenu() {
 // Код конструктора
 }
 public void addItem(String name, String description, 
 boolean vegetarian, double price) 
 {
 MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
 menuItems.put(menuItem.getName(), menuItem);
 }
 public Map<String, MenuItem> getItems() {
 return menuItems;
 }
 
 public Iterator<MenuItem> createIterator() {
 return menuItems.values().iterator();
 }
}
Переработка кода CafeMenu
Переработаем код CafeMenu. Нам придется позаботиться о реализации интерфейса Menu, а также 
решить задачу создания Iterator для значений, хранящихся в HashMap. Помните, как мы делали то же 
самое для ArrayList? На этот раз ситуация несколько изменилась…
Класс CafeMenu реализует интерфейс Menu, 
чтобы класс Waitress мог использовать его, 
как и две другие реализации Menu.
Как и прежде, мы избавляемся от getItems(), 
чтобы не раскрывать реализацию menuItems 
клиентскому коду Waitress.
Реализация метода createIterator(). 
Обратите внимание: мы получаем 
итератор не для всей коллекции 
HashMap, а только для значений.
 public Iterator<MenuItem> createIterator() {
 return menuItems.values().iterator();
 }
Сначала получаем набор значений для 
Hashtable, который представляет собой 
коллекцию всех объектов в таблице.
К счастью, коллекция 
поддерживает 
метод iterator(), 
возвращающий объект 
типа java.util.Iterator.
Мы используем HashMap — 
стандартную структуру данных 
для хранения значений.
Код под увеличительным стеклом
Коллекция HashMap немного сложнее ArrayList, потому что в ней хранятся пары 
«ключ–значение». Тем не менее мы можем получить итератор для набора значений 
(относящихся к классу MenuItem).
Не нарушаем ли мы 
принцип минимальной 
осведомленности? Что 
можно с этим сделать?
Мозговой
штурм
паттерны итератор и компоновщик
дальше   373
public class Waitress {
 Menu pancakeHouseMenu;
 Menu dinerMenu;
 Menu cafeMenu;
 public Waitress(Menu pancakeHouseMenu, Menu dinerMenu, Menu cafeMenu) {
 this.pancakeHouseMenu = pancakeHouseMenu;
 this.dinerMenu = dinerMenu;
 this.cafeMenu = cafeMenu;
 }
 public void printMenu() {
 Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();
 Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();
 Iterator<MenuItem> cafeIterator = cafeMenu.createIterator();
 System.out.println("MENU\n----\nBREAKFAST");
 printMenu(pancakeIterator);
 System.out.println("\nLUNCH");
 printMenu(dinerIterator);
 System.out.println("\nDINNER");
 printMenu(cafeIterator);
 }
 private void printMenu(Iterator iterator) {
 while (iterator.hasNext()) {
 MenuItem menuItem = iterator.next();
 System.out.print(menuItem.getName() + ", ");
 System.out.print(menuItem.getPrice() + " -- ");
 System.out.println(menuItem.getDescription());
 }
 }
}
Поддержка CafeMenu в классе Waitress
Пришло время внести изменения в Waitress для поддержки новой реализации 
Menu. Теперь, когда Waitress поддерживает Iterator, это делается легко:
Меню кафе передается вместе 
с другими меню в конструкторе. 
Там оно сохраняется в переменной 
экземпляра.
Чтобы вывести меню, 
достаточно создать 
итератор и передать 
его printMenu(). И все!
Ничего не 
меняется.
374 глава 9
тест-драйв
File Edit Window Help Kathy&BertLikePancakes
% java DinerMenuTestDrive
MENU
----
BREAKFAST
K&B’s Pancake Breakfast, 2.99 -- Pancakes with scrambled eggs, and toast
Regular Pancake Breakfast, 2.99 -- Pancakes with fried eggs, sausage
Blueberry Pancakes, 3.49 -- Pancakes made with fresh blueberries
Waffles, 3.59 -- Waffles, with your choice of blueberries or strawberries
LUNCH
Vegetarian BLT, 2.99 -- (Fakin’) Bacon with lettuce & tomato on whole wheat
BLT, 2.99 -- Bacon with lettuce & tomato on whole wheat
Soup of the day, 3.29 -- Soup of the day, with a side of potato salad
Hotdog, 3.05 -- A hot dog, with saurkraut, relish, onions, topped with cheese
Steamed Veggies and Brown Rice, 3.99 -- Steamed vegetables over brown rice
Pasta, 3.89 -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
DINNER
Soup of the day, 3.69 -- A cup of the soup of the day, with a side salad
Burrito, 4.29 -- A large burrito, with whole pinto beans, salsa, guacamole
Veggie Burger and Air Fries, 3.99 -- Veggie burger on a whole wheat bun,
 lettuce, tomato, and fries
%
Результат тестирования; обратите внимание на новое меню кафе!
Сначала перебираем 
меню блинной...
...затем 
меню 
бистро...
...и наконец, 
новое меню 
кафе — все 
это в одном 
коде перебора.
public class MenuTestDrive {
 public static void main(String args[]) {
 PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
 DinerMenu dinerMenu = new DinerMenu();
 CafeMenu cafeMenu = new CafeMenu();
 Waitress waitress = new Waitress(pancakeHouseMenu, dinerMenu, cafeMenu);
 waitress.printMenu();
}
Вывод полного меню
Давайте обновим тестовую программу и убедимся 
в том, что все работает правильно.
Создаем CafeMenu...
...и передаем его Waitress.
Теперь тестовая программа 
выводит содержимое всех трех меню.
паттерны итератор и компоновщик
дальше   375
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
ArrayList
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Array
...ничего не зная 
о реализации 
самих меню.
ArrayList имеет 
встроенный 
итератор...
...у Array нет 
встроенного 
итератора, 
поэтому 
мы создали 
собственный.
Iterator
Мы хотели, чтобы 
официантка могла 
легко перебирать 
элементы меню... Две разные 
реализации меню 
с двумя разными 
интерфейсами 
перебора.
Iterator
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
ArrayList
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Array
Официантка получает 
итератор для каждой 
группы объектов, 
которые необходимо 
перебрать... ...для ArrayList...
...и для 
Array.
next()
next()
Теперь ей не нужно беспокоиться о том, какая 
реализация используется в каждом конкретном случае — для перебора всегда используется один и тот же интерфейс Iterator.
Что мы сделали?
Мы отделили официантку от реализации...
376 глава 9
новое меню
Iterator
next()
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
Vector
MenuItem
MenuItem
MenuItem
MenuItem
HashMap
key
key
key
key
В основном их 
интерфейсы 
различаются.
Работа с итератором отделяет 
официантку от реализации меню, 
поэтому при необходимости мы 
легко можем добавить новые меню.
Мы без труда 
добавляем новую 
реализацию 
меню, а благодаря 
наличию 
итератора 
официантка знает, 
что с ней делать.
Теперь один код может использоваться для перебора любых групп 
объектов, а подробности внутренней реализации остаются 
скрытыми от клиентского кода.
...и другие!
Создать реализацию Iterator 
для значений 
HashMap было 
несложно; нужный итератор 
возвращается 
вызовом values.
iterator().
LinkedList
MenuItem MenuItem MenuItem MenuItem
Но почти все они 
предоставляют 
возможность 
получения Iterator.
Но даже если Iterator и не поддерживается, это 
тоже нормально, потому что теперь вы знаете, 
как построить собственную реализацию.
...и упростили дальнейшие расширения
Но это еще не все!
Java предоставляет в ваше 
распоряжение многочисленные классы коллекций для 
хранения и выборки групп 
объектов (такие, как Vector 
и LinkedList).
паттерны итератор и компоновщик
дальше   377
Итераторы и коллекции
В своем примере мы использовали пару классов из библиотеки Java Collections 
Framework. Эта «библиотека» в действительности представляет собой обычный набор классов и интерфейсов, в числе которых использованный нами 
класс ArrayList и многие другие (Vector, LinkedList, Stack, PriorityQueue и т. д.). 
Каждый из этих классов реализует интерфейс java.util.Collection, содержащий 
полезные методы для работы с группами объектов.
Давайте познакомимся с этим интерфейсом хотя бы в общих чертах:
Каждый объект Collection
знает, как создать свой итератор. Вызов iterator() для 
ArrayList возвращает конкретный итератор, предназначенный для ArrayList, но при этом используемый им 
конкретный класс остается скрытым; перебор коллекции 
осуществляется через интерфейс Iterator.
Как видите, здесь есть 
немало полезного. Вы можете 
добавлять и удалять элементы 
из коллекции, даже не зная, как 
она реализована.
Наш старый знакомый — метод 
iterator(). С его помощью можно 
получить итератор для любого 
класса, реализующего интерфейс 
Collection.
Также полезны методы size() 
(получение количества элементов) 
и toArray() (преобразование 
коллекции в массив).
HashMap — один из классов 
с косвенной поддержкой 
итераторов. 
Как было показано при реализации CafeMenu, для такого 
класса можно получить Iterator, 
но только после предварительной выборки его субколлекции 
values. И это вполне логично: 
в HashMap хранятся два вида 
объектов — ключи и значения. 
Чтобы перебрать значения, необходимо сначала извлечь их из 
HashMap и только потом получить итератор.
 Будьте осторожны!
add()
addAll()
clear()
contains()
containsAll()
equals()
hashCode()
isEmpty()
iterator()
remove()
removeAll()
retainAll()
size()
toArray()
<<interface>>
Collection
iterator()
+ forEach()
+ spliterator()
<<interface>>
Iterable Не забывайте, что интерфейс 
Collection реализует 
интерфейс Iterable.
378 глава 9
Повара решили, что содержимое их меню должно чередоваться. Другими словами, в понедельник, среду, 
пятницу и воскресенье будут предлагаться одни блюда, а во вторник, четверг и субботу — другие. Код нового «чередующего» итератора для DinerMenu уже был написан, но кто-то шутки ради разрезал его на куски 
и разместил на холодильнике. Сможете ли вы собрать его заново? Некоторые фигурные скобки упали на 
пол. Они слишком малы, чтобы их подбирать, — добавьте столько скобок, сколько считаете нужным!
Магниты с кодами
import java.util.Iterator;
import java.util.Calendar;
public class AlternatingDinerMenuIterator
MenuItem[] items;
int position;
this.items = items;
position = Calendar.DAY_OF_WEEK % 2;
MenuItem menuItem = items[position];
position = position + 2;
return menuItem;
throw new UnsupportedOperationException(
 "Alternating Diner Menu Iterator does not support remove()");
public AlternatingDinerMenuIterator(MenuItem[] items)
implements Iterator<MenuItem>
public Object next() {
public boolean hasNext() {
if (position >= items.length || items[position] == null) {
 return false;
} else {
 return true;
}
public void remove() {
}
}
}
упражнение с магнитами
паттерны итератор и компоновщик
дальше   379
Классу Waitress по-прежнему приходится трижды вызывать printMenu(), по одному разу для 
каждого меню. Можете ли вы придумать способ объединения меню, чтобы было достаточно одного вызова? Или чтобы для перебора всех меню классу Waitress передавался всего 
один итератор?
 public void printMenu() {
 Iterator<MenuItem> pancakeIterator = pancakeHouseMenu.createIterator();
 Iterator<MenuItem> dinerIterator = dinerMenu.createIterator();
 Iterator<MenuItem> cafeIterator = cafeMenu.createIterator();
 System.out.println("MENU\n----\nBREAKFAST");
 printMenu(pancakeIterator);
 System.out.println("\nLUNCH");
 printMenu(dinerIterator);
 System.out.println("\nDINNER");
 printMenu(cafeIterator);
 }
Официантка, на выход!
Код Waitress был значительно усовершенствован, но следует признать, что три вызова printMenu() выглядят довольно 
уродливо.
Давайте откровенно признаем: каждый раз, когда в системе 
будет появляться новое меню, нам придется открывать код 
Waitress и добавлять новый фрагмент. Пожалуй, это является нарушением принципа открытости/закрытости.
Мы отлично справились с логической изоляцией реализации меню и инкапсуляцией перебора в итераторе. Однако мы продолжаем работать с меню как с отдельными независимыми 
объектами. Хорошо бы найти способ работать с ними как с единым целым.
Три вызова printMenu.
Три вызова createIterator().
Каждый раз, когда в системе добавляется 
или удаляется меню, этот код 
открывается для изменений.
Мозговой
штурм
380 глава 9
Похоже, идея удачная. Давайте попробуем:
Передаем коллекцию 
ArrayList с элементами 
Menu.
Перебираем 
объекты меню, 
передавая итератор 
каждого объекта 
перегруженному 
методу printMenu().
Здесь код не 
изменяется.
Выглядит неплохо. Правда, мы потеряли названия меню, 
но их можно добавить в объекты меню.
новая архитектура
public class Waitress {
 List<Menu> menus;
 
 public Waitress(ArrayList<Menu> menus) {
 this.menus = menus;
 }
 
 public void printMenu() {
 Iterator<Menu> menuIterator = menus.iterator();
 while(menuIterator.hasNext()) {
 Menu menu = menuIterator.next();
 printMenu(menu.createIterator());
 }
 }
 
 void printMenu(Iterator<Menu> iterator) {
 while (iterator.hasNext()) {
 MenuItem menuItem = iterator.next();
 System.out.print(menuItem.getName() + ", ");
 System.out.print(menuItem.getPrice() + " -- ");
 System.out.println(menuItem.getDescription());
 }
 }
} 
Не так уж это и сложно. Нужно 
только упаковать объекты Menu 
в ArrayList, а затем получить итератор 
для их перебора. Код Waitress получится 
простым и легко обработает любое 
количество меню.
паттерны итератор и компоновщик
дальше   381
Что делать? Теперь мы должны поддерживать не только 
несколько меню, но и меню внутри других меню. 
Было бы хорошо, если бы десертное меню можно было 
сделать элементом коллекции DinerMenu, но в текущей 
реализации такое решение работать не будет.
PancakeHouseMenu DinerMenu CafeMenu
1 2 3
MenuItem MenuItem MenuItem MenuItem
1 2 3 4
Меню блинной
MenuItem
MenuItem
MenuItem
MenuItem
Меню кафе
key
key
key
key
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Меню бистро
Все меню
MenuItem
MenuItem
MenuItem
MenuItem
1
2
3
4
Десертное меню
Коллекция ArrayList, 
содержащая все 
меню.
Объект Diner Menu должен содержать 
подменю, однако мы не можем присвоить 
объект меню элементу массива MenuItem 
из-за несоответствия типов. Следовательно, 
такое решение не работает.
Array
ArrayList
HashMap
А когда мы уже торжествовали победу...
Было решено добавить десертное подменю.
Чего мы хотим (примерно):
Ничего
не выйдет! Коллекцию десертного меню не удастся присвоить 
объекту MenuItem.
Придется вносить изменения!
Я слышала, что 
в бистро собираются 
создать десертное подменю, 
которое будет вложено в их 
стандартное меню. 
382 глава 9
Что нам нужно?
Пора принять ответственное решение и переработать 
реализацию, чтобы она стала достаточно общей для работы с любыми меню (а теперь и подменю). Да, вы правильно поняли — поварам придется изменить реализацию своих меню.
Дело в том, что наша архитектура достигла критического уровня сложности. Если мы не переработаем ее сейчас, она уже не сможет адаптироваться к дальнейшим 
объединениям или появлению подменю.
Итак, каким требованиям должна удовлетворять новая 
архитектура?
  Древовидная структура для поддержки меню, подменю и элементов.
  Механизм перебора элементов в каждом меню, по 
крайней мере не менее удобный, чем с использованием итераторов.
  Более гибкие средства перебора элементов, чтобы, 
например, мы могли перебрать только элементы десертного подменю или же все меню бистро вместе 
с десертным подменю.
время рефакторинга
Дальнейшее развитие кода 
требует рефакторинга. Если 
этого не сделать, мы получим 
негибкий, закостенелый код, 
который уже не сможет породить 
новую жизнь.
паттерны итератор и компоновщик
дальше   383
А как бы вы подошли к реализации новых требований к архитектуре? Подумайте, прежде чем 
перевернуть страницу.
Все меню
Десертное меню
Меню блинной
Меню бистро
Меню кафе
MenuItem
MenuItem
MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
Она состоит 
из меню...
...и элементов меню.
...подменю...
Меню, вложенные подменю 
и элементы образуют 
естественную древовидную 
структуру.
Все меню
Десертное меню
Меню блинной
Меню бистро
Меню кафе
MenuItem
MenuItem
MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
Десертное меню
MenuItem
MenuItem MenuItem
MenuItem
Как и прежде, нам 
понадобится механизм 
перебора всех узлов дерева. А также более гибкие средства 
перебора — например,
по элементам одного меню.
Мозговой
штурм
384 глава 9
Определение паттерна Компоновщик
Да, вы не ошиблись, мы собираемся привлечь очередной паттерн для решения этой проблемы. Мы 
еще не закончили с паттерном Итератор — он остается частью нашего решения. Тем не менее проблема управления меню вышла на новый уровень, 
недоступный для паттерна Итератор. Итак, мы 
сделаем шаг назад и решим ее при помощи паттерна Компоновщик.
Не будем ходить вокруг да около — начнем прямо с формального определения:
Паттерн Компоновщик объединяет объекты 
в древовидные структуры для представления 
иерархий «часть/целое». Компоновщик позволяет клиенту выполнять однородные операции 
с отдельными объектами и их совокупностями.
Рассмотрим это определение в контексте наших 
меню: паттерн дает возможность создать древовидную структуру, которая может работать с вложенными группами меню и элементами меню. Размещая 
меню и элементы в одной структуре, мы создаем 
иерархию «часть/целое». Иначе говоря, это дерево объектов, которое состоит из отдельных частей 
(меню и элементы меню), но при этом может рассматриваться как единое целое (одно большое «суперменю»).
Построив «суперменю», мы можем использовать 
этот паттерн для того, чтобы «выполнять однородные операции с отдельными объектами и их 
комбинациями». Что это означает? Если у вас есть 
древовидная структура из меню, подменю (и, возможно, подподменю) с элементами, любое меню 
представляет собой «комбинацию», так как оно может содержать другие меню и команды меню. Отдельными объектами являются только элементы 
меню — они не могут содержать другие объекты. 
Применение в архитектуре паттерна Компоновщик позволит нам написать простой код, который 
применяет одну и ту же операцию (например, вывод!) ко всей структуре меню.
Древовидная структура
Узел
Лист
Лист
Лист Элементы без дочерних 
элементов называются 
листьями.
Элементы, имеющие дочерние 
элементы, называются узлами.
Menu MenuItem
MenuItem
MenuItem
Объекты Menu — узлы, 
объекты MenuItem — 
листья.
Иерархия Menu 
и MenuItems может 
быть представлена 
древовидной 
структурой.
определение паттерна компоновщик
паттерны итератор и компоновщик
дальше   385
Паттерн Компоновщик 
позволяет создавать 
древовидные структуры, 
узлами которых являются 
как комбинации, так 
и отдельные объекты.
В такой структуре 
одни и те же операции 
могут применяться 
и к комбинациям, 
и к отдельным объектам. 
Иначе говоря, во многих 
случаях различия между 
комбинациями и отдельными 
объектами игнорируются.
Все меню
Десертное меню
Меню блинной
Меню бистро
Меню кафе
MenuItem
MenuItem
MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
Меню
Подменю
Элементы 
меню
Мы можем создавать 
деревья произвольной 
сложности.
Все меню
Десертное меню
Меню блинной
Меню бистро
Меню кафе
MenuItem
MenuItem
MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
Меню
Подменю
Элементы меню
И обрабатывать их 
как единое целое...
....или его отдельные 
части.
Все меню
Десертное меню
Меню блинной
Меню бистро
Меню кафе
MenuItem
MenuItem
MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
Меню
Подменю
Элементы 
меню
Операции могут 
применяться ко всей 
структуре.
...или частям.
print()
print()
386 глава 9
operation()
add(Component)
remove(Component)
getChild(int)
Component
add(Component)
remove(Component)
getChild(int)
operation()
Composite
Клиент
operation()
Leaf
Интерфейс Component 
определяет интерфейс 
для всех компонентов: как 
комбинаций, так и листовых узлов.
Component может 
реализовать поведение по 
умолчанию для add(), remove(), 
getChild() и других операций.
Лист (Leaf ) не имеет 
дочерних объектов.
Leaf определяет поведение 
элементов комбинации. 
Для этого он реализует 
операции, поддерживаемые 
интерфейсом Composite.
Интерфейс Composite 
определяет поведение 
компонентов, имеющих 
дочерние компоненты, 
и обеспечивает хранение 
последних.
Composite также 
реализует операции, относящиеся 
к Leaf. Некоторые 
из них могут не 
иметь смысла для 
комбинаций; в таких случаях генерируется исключение.
Клиент использует 
интерфейс Component 
для работы с объектами.
Leaf также наследует мето
ды add(), remove() и getChild(), 
-
которые могут не иметь 
смысла для листового узла. 
Мы вернемся к этой проблеме 
позднее.
В: Компоненты, комбинации, деревья? Я уже запутался.
О: Комбинация состоит из компонентов. Компоненты бывают 
двух видов: комбинации и листовые элементы. Заметили рекурсию? Комбинация содержит дочерние компоненты, которые могут быть другими комбинациями или листьями. 
При такой организации данных образуется древовидная структура (инвертированное дерево), корнем которой является комбинация, а ветвями — комбинации, завершаемые листовыми узлами.
В: А при чем здесь итераторы?
О: Напомню, что мы заново реализуем систему меню на базе 
нового решения: паттерна Компоновщик. Так что не ждите, что 
итератор как по волшебству превратится в комбинацию. Тем не 
менее эти два паттерна хорошо работают в сочетании друг с другом.
Вскоре мы рассмотрим пару возможных применений итераторов 
в реализации комбинаций.
диаграмма классов паттерна компоновщик
часто Задаваемые вопросы
паттерны итератор и компоновщик
дальше   387
getName()
getDescription()
getPrice()
isVegetarian()
print()
add(Component)
remove(Component)
getChild(int)
MenuComponent
getName()
getDescription()
getPrice()
isVegetarian()
print()
MenuItem
Waitress
getName()
getDescription()
print()
add(Component)
remove(Component)
getChild(int)
Menu
menuComponents
Проектирование меню с использованием паттерна Компоновщик
Как же нам применить паттерн Компоновщик при проектировании системы меню? Для начала необходимо определить интерфейс компонента; этот интерфейс, общий для меню и элементов меню, позволяет выполнять с ними однородные операции. Другими словами, один и тот же метод вызывается 
как для меню, так и для их элементов.
Возможно, вызов некоторых методов для меню или элементов меню не имеет смысла, но с этим мы 
разберемся позднее (притом совсем скоро). А пока в общих чертах посмотрим, как система меню укладывается в структуру паттерна Компоновщик:
MenuComponent представляет интерфейс 
объектов MenuItem и Menu. Мы используем 
абтрактный класс, потому что собираемся 
предоставить реализации по умолчанию. 
Некоторые методы 
уже знакомы вам по 
предыдущим версиям MenuItem и Menu; 
также были добавлены операции print(), 
add(), remove() 
и getChild(). Вскоре 
мы опишем их при 
реализации новых 
версий классов Menu 
и MenuItem.
MenuItem переопределяет те методы, для 
которых такое переопределение оправдан
но, и использует реализации по умолчанию 
-
из MenuComponent для остальных (как, 
например, для метода add()
компонента в MenuItem не имеет смыс
— добавление 
ла... Компоненты можно добавлять только 
-
в Menu).
Menu также переопределяет методы, 
когда это имеет смысл, — как, например, методы добавления и удаления элементов (или других меню!) из 
menuComponent. Методы getName() 
и getDescription() возвращают название 
и описание меню.
И MenuItem, и Menu 
переопределяют print(). 
Класс Waitress использует интерфейс 
MenuComponent для работы с объектами 
как Menu, так и MenuItem. 
Методы для выполнения 
управляющих операций 
с компонентами 
(MenuItem и Menu).
388 глава 9
Реализация MenuComponent
public abstract class MenuComponent {
 
 public void add(MenuComponent menuComponent) {
 throw new UnsupportedOperationException();
 }
 public void remove(MenuComponent menuComponent) {
 throw new UnsupportedOperationException();
 }
 public MenuComponent getChild(int i) {
 throw new UnsupportedOperationException();
 }
 
 public String getName() {
 throw new UnsupportedOperationException();
 }
 public String getDescription() {
 throw new UnsupportedOperationException();
 }
 public double getPrice() {
 throw new UnsupportedOperationException();
 }
 public boolean isVegetarian() {
 throw new UnsupportedOperationException();
 }
 
 public void print() {
 throw new UnsupportedOperationException();
 }
}
Начнем с абстрактного класса MenuComponent; 
напомним, что его задачей является определение 
интерфейса листьев и комбинационных узлов. Логично спросить: «Разве MenuComponent в этом 
случае не играет сразу две роли?» Да, возможно, 
и мы еще вернемся к этому вопросу. А пока мы 
определим реализацию по умолчанию для некоторых методов; если MenuItem (лист) или Menu 
(комбинация) не хотят реализовывать такие методы (например, getChild() для листового узла), они 
смогут воспользоваться стандартным поведением:
MenuComponent предоставляет 
реализации по умолчанию для 
всех методов.
Группа «комбинационных» 
методов, то есть методов для 
добавления, удаления и получения 
MenuComponent.
Группа «методов операций», 
используемых MenuItem. Как вы 
вскоре увидите при анализе кода 
Menu, некоторые из этих методов также могут использоваться в Menu.
Метод print() реализуется как 
в Menu, так и в MenuItem, но 
мы предоставляем реализацию 
по умолчанию.
Так как одни методы имеют смысл 
только для MenuItem, а другие — 
только для Menu, реализация
по умолчанию инициирует 
UnsupportedOperationException. 
Если объект MenuItem или Menu не 
поддерживает операцию, ему не нужно 
ничего делать — он просто наследует 
реализацию по умолчанию.
Все компоненты должны реализовать интерфейс MenuComponent; 
но так как листьям и узлам отводятся разные роли, не всегда 
можно определить реализацию 
по умолчанию для каждого метода, для которого она имеет смысл. 
Иногда лучшее, что можно сделать 
в реализации по умолчанию, — 
инициировать исключение времени выполнения.
реализация комбинационных меню
паттерны итератор и компоновщик
дальше   389
public class MenuItem extends MenuComponent {
 String name;
 String description;
 boolean vegetarian;
 double price;
 
 public MenuItem(String name, 
 String description, 
 boolean vegetarian, 
 double price) 
 { 
 this.name = name;
 this.description = description;
 this.vegetarian = vegetarian;
 this.price = price;
 }
 
 public String getName() {
 return name;
 }
 
 public String getDescription() {
 return description;
 }
 
 public double getPrice() {
 return price;
 }
 
 public boolean isVegetarian() {
 return vegetarian;
 }
 
 public void print() {
 System.out.print(" " + getName());
 if (isVegetarian()) {
 System.out.print("(v)");
 }
 System.out.println(", " + getPrice());
 System.out.println(" -- " + getDescription());
 }
}
Реализация MenuItem
Ну что ж, займемся классом MenuItem. Напомним, 
что это класс листового узла на диаграмме классов 
паттерна Компоновщик и он реализует поведение 
элементов комбинации.
Прежде всего класс 
должен расширять 
интерфейс 
MenuComponent.
Конструктор получает 
название, описание и т. д. 
и сохраняет ссылки на 
полученные данные. Он 
почти не отличается от 
конструктора в старой 
реализации элементов меню.
Get-методы не 
отличаются от 
предыдущей реализации.
А этот метод отличается 
от предыдущей реализации. Мы 
переопределяем метод print() класса 
MenuComponent. Для MenuItem этот 
метод выводит полное описание 
элемента меню: название, описание, цену 
и признак вегетарианского блюда.
Хорошо, что мы пошли в этом 
направлении. Надеюсь, это даст 
мне гибкость, необходимую для 
реализации меню с блинчиками, 
о котором я давно мечтал.
390 глава 9
public class Menu extends MenuComponent {
 List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();
 String name;
 String description;
 
 public Menu(String name, String description) {
 this.name = name;
 this.description = description;
 }
 public void add(MenuComponent menuComponent) {
 menuComponents.add(menuComponent);
 }
 public void remove(MenuComponent menuComponent) {
 menuComponents.remove(menuComponent);
 }
 public MenuComponent getChild(int i) {
 returnmenuComponents.get(i);
 }
 public String getName() {
 return name;
 }
 public String getDescription() {
 return description;
 }
 public void print() {
 System.out.print("\n" + getName());
 System.out.println(", " + getDescription());
 System.out.println("---------------------");
 }
}
Реализация комбинационного меню
После класса элемента меню MenuItem остается создать класс комбинационного узла, который мы 
назовем Menu. Напомним, что класс комбинации может содержать элементы MenuItem или другие 
Menu. Этот класс не реализует пару методов MenuComponent (getPrice() и isVegetarian()), потому что 
эти методы не имеют особого смысла для Menu.
Menu может иметь любое количество 
потомков типа MenuComponent; 
для их хранения будет использоваться 
внутренняя коллекция ArrayList.
Отличается от нашей старой 
реализации: с каждым меню 
связывается название и описание.
Включение в Menu объектов MenuItem или других 
объектов Menu. Так как и 
MenuItem, и Menus расширяют MenuComponent, хватает 
одного метода.
Также поддерживаются операции удаления и получения 
MenuComponent.
Get-методы для получения названия и описания.
Обратите внимание: мы не переопределяем getPrice() или isVegetarian(), потому что 
эти методы не имеют смысла для Menu. При 
попытке вызвать их для Menu будет выдано 
исключение UnsupportedOperationException.
При выводе объекта Menu 
выводится его название 
и описание.
Menu расширяет MenuComponent 
(как и MenuItem).
реализация нового класса меню
паттерны итератор и компоновщик
дальше   391
Смотрите! Мы используем 
итератор для перебора всех 
компонентов объекта Menu...
Ими могут быть другие объекты 
Menu или объекты MenuItem.
Отличное замечание! Поскольку меню является комбинацией и содержит как объекты MenuItem, так и другие объекты Menu, метод 
print() должен выводить все его содержимое. А если он этого не делает, нам придется перебирать всю комбинацию и выводить каждый элемент самостоятельно. Такой подход противоречит самой 
цели создания комбинационных структур.
Как вы вскоре убедитесь, правильно реализовать print() несложно, 
потому что мы можем положиться на способность каждого компонента вывести себя. Решение получается элегантным и рекурсивным. Смотрите сами:
Нужно лишь изменить метод print(), 
чтобы он выводил не только информацию 
о меню, но и все компоненты: другие меню 
и элементы меню.
ВНИМАНИЕ: если в процессе перебора мы встретим другой 
объект меню, его метод print() начнет новый перебор, и т. д.
Исправление метода print()
public class Menu extends MenuComponent {
 List<MenuComponent> menuComponents = new ArrayList<MenuComponent>();
 String name;
 String description;
 
 // Код конструктора
 // Другие методы
 public void print() {
System.out.print("\n" + getName());
System.out.println(", " + getDescription());
System.out.println("---------------------");
 
for (MenuComponent menuComponent : menuComponents) {
 menuComponent.print();
}
 }
}
Так как и Menu, и MenuItem 
реализуют метод print(), мы 
просто вызываем print(), а все 
остальное они сделают сами.
Минутку, я не понял реализацию 
print(). Вроде как к комбинациям должны 
применяться те же операции, что и к листьям. 
Применив эту реализацию print() к комбинации, 
я получу только название и описание меню, а не 
содержимое КОМБИНАЦИИ.
392 глава 9
Готовимся к тестированию...
Пора переходить к тестированию, но сначала необходимо обновить класс Waitress — в конце концов, 
он является основным клиентом нашего кода!
Все меню
Десертное меню
Меню блинной
Меню бистро
Меню кафе
MenuItem
MenuItem
MenuItem
MenuItem
Комбинация
public class Waitress {
 MenuComponent allMenus;
 public Waitress(MenuComponent allMenus) {
 this.allMenus = allMenus;
 }
 public void printMenu() {
 allMenus.print();
 }
}
Да! Код Waitress несложен. 
Мы просто передаем компонент 
меню верхнего уровня — тот, 
который содержит остальные меню. 
Мы назвали его allMenus.
А чтобы вывести всю иерархию 
меню — все меню и все их 
элементы, — достаточно 
вызвать метод print() для меню 
верхнего уровня.
И последнее, о чем стоит сказать до написания тестовой программы. Давайте посмотрим, как будет 
выглядеть комбинация меню во время выполнения:
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
MenuItem MenuItem
MenuItem
Меню верхнего 
уровня содержит 
все подменю и все 
элементы.
Каждое меню содержит элементы...
...или элементы
и другие меню.
Комбинация
Комбинация
Лист
Каждый объект 
Menu и MenuItem 
реализует интерфейс 
MenuComponent.
Лист
Лист
Лист
тестирование комбинационного меню
паттерны итератор и компоновщик
дальше   393
Теперь можно и тестировать...
Осталось написать тестовую программу. В отличие от предыдущей версии, все меню будут созданы 
непосредственно в ней. Мы могли бы потребовать у каждого повара его новое меню, но сначала протестируем все вместе. Код:
public class MenuTestDrive {
 public static void main(String args[]) {
 MenuComponent pancakeHouseMenu = 
 new Menu("PANCAKE HOUSE MENU", "Breakfast");
 MenuComponent dinerMenu = 
 new Menu("DINER MENU", "Lunch");
 MenuComponent cafeMenu = 
 new Menu("CAFE MENU", "Dinner");
 MenuComponent dessertMenu = 
 new Menu("DESSERT MENU", "Dessert of course!");
 
 MenuComponent allMenus = new Menu("ALL MENUS", "All menus combined");
 
 allMenus.add(pancakeHouseMenu);
 allMenus.add(dinerMenu);
 allMenus.add(cafeMenu);
 
 // добавление других элементов
 dinerMenu.add(new MenuItem(
 "Pasta",
 "Spaghetti with Marinara Sauce, and a slice of sourdough bread",
 true, 
 3.89));
 
 dinerMenu.add(dessertMenu);
 
 dessertMenu.add(new MenuItem(
 "Apple Pie",
 "Apple pie with a flakey crust, topped with vanilla icecream",
 true,
 1.59));
 
 // добавление других элементов
 
 Waitress waitress = new Waitress(allMenus);
 
 waitress.printMenu();
 }
}
Сначала создаем все 
объекты меню.
Также нам понадобится 
меню верхнего уровня — 
назовем его allMenus.
Для включения каждого меню в allMenus 
используется комбинационный метод add().
В меню также включается другое 
меню. Для dinerMenu важно только 
то, что все хранящиеся в нем 
объекты являются MenuComponent.
Создаем элемент в десертном меню...
Сконструированная иерархия 
меню передается классу Waitress. 
И как вы уже видели, вывести 
содержимое меню в этой версии 
проще простого.
Затем в меню добавляются остальные 
элементы. Здесь приведен только один 
пример; за остальными обращайтесь 
к полному исходному коду.
394 глава 9
File Edit Window Help GreenEggs&Spam
% java MenuTestDrive
ALL MENUS, All menus combined
---------------------
PANCAKE HOUSE MENU, Breakfast
---------------------
 K&B’s Pancake Breakfast(v), 2.99
 -- Pancakes with scrambled eggs, and toast
 Regular Pancake Breakfast, 2.99
 -- Pancakes with fried eggs, sausage
 Blueberry Pancakes(v), 3.49
 -- Pancakes made with fresh blueberries, and blueberry syrup
 Waffles(v), 3.59
 -- Waffles, with your choice of blueberries or strawberries
DINER MENU, Lunch
---------------------
 Vegetarian BLT(v), 2.99
 -- (Fakin’) Bacon with lettuce & tomato on whole wheat
 BLT, 2.99
 -- Bacon with lettuce & tomato on whole wheat
 Soup of the day, 3.29
 -- A bowl of the soup of the day, with a side of potato salad
 Hotdog, 3.05
 -- A hot dog, with saurkraut, relish, onions, topped with cheese
 Steamed Veggies and Brown Rice(v), 3.99
 -- Steamed vegetables over brown rice
 Pasta(v), 3.89
 -- Spaghetti with Marinara Sauce, and a slice of sourdough bread
DESSERT MENU, Dessert of course!
---------------------
 Apple Pie(v), 1.59
 -- Apple pie with a flakey crust, topped with vanilla icecream
 Cheesecake(v), 1.99
 -- Creamy New York cheesecake, with a chocolate graham crust
 Sorbet(v), 1.89
 -- A scoop of raspberry and a scoop of lime
CAFE MENU, Dinner
---------------------
 Veggie Burger and Air Fries(v), 3.99
 -- Veggie burger on a whole wheat bun, lettuce, tomato, and fries
 Soup of the day, 3.69
 -- A cup of the soup of the day, with a side salad
 Burrito(v), 4.29
 -- A large burrito, with whole pinto beans, salsa, guacamole
%
Все содержимое меню... И чтобы 
вывести его, мы просто вызвали 
print() для меню верхнего уровня.
Новое десертное 
меню выводится 
в числе других 
компонентов меню 
бистро.
Готовимся к тестовому запуску...
ВНИМАНИЕ: приведены результаты для полной 
версии исходного кода.
еще один тест
паттерны итератор и компоновщик
дальше   395
В этом замечании есть доля истины. Можно сказать, что паттерн Компоновщик нарушает принцип одной обязанности 
ради прозрачности. Что такое «прозрачность»? Благодаря тому, 
что мы включили в интерфейс Component операции управления как дочерними узлами, так и листьями, клиент выполняет 
одинаковые операции с комбинациями и листовыми узлами. Таким образом, вид узла становится прозрачным для клиента. Однако при этом приходится частично жертвовать безопасностью, 
потому что клиент может попытаться выполнить с элементом 
неподходящую или бессмысленную операцию (например, попытаться добавить меню в листовой элемент). Речь идет о сознательном архитектурном решении; мы также могли пойти по 
другому пути и разделить обязанности на интерфейсы. Это повысило бы безопасность архитектуры (любые неподходящие 
операции с элементами будут обнаруживаться на стадии компиляции), но тогда код утратит прозрачность, в нем придется использовать условные конструкции с оператором instanceof.
Итак, перед нами классический случай компромиссного решения. Руководствуйтесь архитектурными принципами, но всегда обращайте внимание на то, какое влияние они оказывают 
на нашу архитектуру. Иногда приходится намеренно выбирать 
решения, которые на первый взгляд противоречат принципам. 
В других случаях оценка зависит от точки зрения. Например, 
присутствие в листовых узлах операций управления дочерними узлами (add(), remove() и getChild()) выглядит противоестественно, но лист можно рассматривать как узел с нулем дочерних узлов.
В чем дело? Сначала 
вы говорите «Один класс, одна 
обязанность», а теперь даете нам 
паттерн с двумя обязанностями. Паттерн 
Компоновщик управляет иерархией 
и выполняет операции, относящиеся к Menu.
396 глава 9
HeadFirst: Сегодня у нас в гостях паттерн Компоновщик. Почему бы вам не рассказать немного 
о себе?
Компоновщик: Да, конечно... Я — паттерн, используемый при работе с коллекциями объектов, 
связанных отношениями «часть–целое», когда вы 
хотите выполнять однородные операции с такими объектами.
HeadFirst: А здесь подробнее, пожалуйста... Что 
вы подразумеваете под отношениями «часть–целое»?
Компоновщик: Представьте графический интерфейс. В нем используются многочисленные компоненты верхнего уровня (Frame, Panel и т. д.), 
содержащие другие компоненты: меню, текстовые панели, полосы прокрутки и кнопки. Таким 
образом интерфейс делится на части, но в нашем 
представлении он обычно воспринимается как 
единое целое. Вы приказываете компоненту верхнего уровня перерисовать себя и рассчитываете 
на то, что он правильно прорисует все свои части. 
Компоненты, содержащие другие компоненты, 
называются комбинационными (или составными) 
объектами, а компоненты, не содержащие других 
компонентов, — листовыми объектами.
HeadFirst: А что подразумевается под однородностью операций? Наличие общих методов, которые могут вызываться для комбинаций и для 
листьев?
Компоновщик: Точно. Я приказываю комбинационному или листовому объекту отобразить себя 
на экране, и он делает то, что от него требуется. 
Комбинационный объект для этого приказывает 
всем своим компонентам отобразить себя.
HeadFirst: Из этого следует, что все объекты обладают одинаковым интерфейсом. А если объекты комбинации решают разные задачи?
Компоновщик: Чтобы комбинация была прозрачной с точки зрения клиента, все ее объекты 
должны реализовать единый интерфейс; в противном случае клиенту придется беспокоиться 
о том, какой интерфейс реализует каждый объект, что противоречит основному предназначению паттерна. Разумеется, отсюда следует, что 
вызовы некоторых методов для некоторых объектов не имеют смысла. 
HeadFirst: И что делать в таких случаях?
Компоновщик: Есть пара возможных решений: 
иногда можно не делать ничего, вернуть null или 
false — что лучше подойдет для вашего приложения. В других случаях выбирается более активный 
путь — метод инициирует исключение. Конечно, 
клиенту придется проделать дополнительную работу и убедиться в том, что при вызове метода не 
произошло ничего непредвиденного.
HeadFirst: Если клиент не знает, с каким объектом он имеет дело, то как он без проверки типа 
определит, какие методы для него можно вызывать?
Компоновщик: При некоторой изобретательности можно структурировать методы так, что 
реализация по умолчанию будет делать что-то, 
имеющее смысл. Например, вызов getChild() для 
интервью с паттерном компоновщик
Интервью недели: 
Паттерн Компоновщик о проблемах реализации
Паттерны
	 для всех
паттерны итератор и компоновщик
дальше   397
комбинации имеет смысл. Но он имеет смысл и 
для листа, если рассматривать последний как объект без дочерних компонентов. 
HeadFirst: Ага... умно. Но некоторых клиентов настолько беспокоит эта проблема, что они требуют определения разных интерфейсов для разных 
объектов, чтобы избежать вызова бессмысленных методов. Можно ли это назвать паттерном 
Компоновщик? 
Компоновщик: Да. Эта версия паттерна Компоновщик намного безопаснее, но в ней клиент 
должен проверить тип каждого объекта перед вызовом метода, чтобы выполнить правильное преобразование.
HeadFirst: Расскажите нам подробнее о структуре комбинаций и листовых объектов.
Компоновщик: Обычно создается древовидная 
структура — некое подобие иерархии. Корнем дерева является комбинация верхнего уровня, а ее 
потомки являются либо комбинациями, либо листовыми узлами.
HeadFirst: Дочерние узлы содержат информацию о своих родителях?
Компоновщик: Да, компонент может хранить 
указатель на родительский узел для упрощения 
перебора. А если у вас имеется ссылка на дочерний узел, подлежащий удалению, для выполнения 
операции необходимо перейти к родителю. Наличие ссылки упрощает такой переход.
HeadFirst: Есть ли еще что-то, о чем необходимо 
помнить при реализации паттерна Компоновщик?
Компоновщик: Да, есть. Например, порядок 
дочерних компонентов. Если дочерние компоненты комбинации должны храниться в определенном порядке, то понадобится более сложная 
схема добавления и удаления, а также перемещения по иерархии.
HeadFirst: Верно, это я как-то не учел.
Компоновщик: А кэширование?
HeadFirst: Кэширование?
Компоновщик: Да. Если перемещение по комбинационной структуре обходится слишком дорого (например, из-за ее сложности), полезно 
реализовать кэширование комбинационных узлов. Например, если вы постоянно перебираете 
комбинацию с ее дочерними узлами для вычисления некоторого значения, стоит реализовать механизм кэширования для временного хранения 
результата, чтобы избежать лишних вычислений.
HeadFirst: Да, при реализации паттерна Компоновщик приходится учитывать больше обстоятельств, чем видно на первый взгляд. Прежде чем 
завершать наше интервью, позвольте задать еще 
один вопрос: что вы считаете своим главным преимуществом?
Компоновщик: Могу с уверенностью сказать, что 
я упрощаю жизнь своим клиентам. Им не приходится беспокоиться о том, работают ли они с комбинационным объектом или с листом, а значит, 
не придется использовать конструкции if, чтобы 
убедиться в том, что они вызывают правильные 
методы для правильных объектов. Часто для выполнения операции со всей структурой достаточно вызова одного метода.
HeadFirst: Да, это важное преимущество. Несомненно, вы — весьма полезный паттерн для управления коллекциями. Однако наше время подходит к концу... Спасибо всем, кто был с нами. До 
встречи на следующем интервью из серии «Паттерны для всех».
ну и задачка
398 глава 9
Соедините каждый паттерн с его описанием:
Паттерн Описание
Стратегия
Адаптер
Итератор
Фасад
Компоновщик
Наблюдатель
Клиент выполняет одинаковые 
операции с коллекциями и отдельными объектами
Предоставляет механизм перебора коллекций без раскрытия 
внутренней реализации
Упрощает интерфейс группы 
классов
Изменяет интерфейс одного 
или нескольких классов
Оповещает группу объектов 
об изменениях состояния
Инкапсулирует взаимозаменяемые варианты поведения 
и выбирает один из них посредством делегирования
Кто и что делает?
паттерны итератор и компоновщик
дальше   399
Паттерны
Стратегия — определяет семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет 
модифицировать алг
Новые инструменты
Два новых инструмента — два полезных способа 
работы с коллекциями объектов.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Observer — defines a one-to-many 
dependency between objects so that 
when one object changes state, all its 
dependents are notified and 
updated automatically
Decorator — Attach additional 
responsibilities to an object 
dynamically. Decorators provide a 
flexible alternative to subclassing for 
extending functionality.
Abstract Factory — Provide an 
interface for creating families of 
related or depedent objects without 
specifying their concrete classes.
Factory Method — Define an 
interface for creating an object, but 
let subclasses decide which class to 
instantiate. Factory Method lets a 
class defer instantiation 
to the subclasses.
Singleton — Ensure a class 
only has one instance 
and provide a global 
point of access to it.
Command — 
Encapsulates a 
request as an object, 
thereby letting you 
parameterize clients 
with different requests, 
queue or log requests, 
and support undoable 
operations.
  Итератор предоставляет доступ 
к элементам коллекции без раскрытия ее внутренней структуры.
  Итератор обеспечивает перебор элементов коллекции и его 
инкапсуляцию в отдельном объекте.
  При использовании итераторов 
коллекция избавляется от одной 
обязанности (поддержки операций перебора данных).
  Итератор предоставляет общий 
интерфейс перебора элементов коллекции, что позволяет 
применять полиморфизм в коде, 
использующем элементы коллекции.
  Интерфейс Iterable предоставляет средства для получения 
итератора и обеспечивает 
использование расширенного 
цикла for.
  Каждому классу следует по возможности назначать только одну 
обязанность.
  Паттерн Компоновщик предоставляет структуру для хранения 
как отдельных объектов, так 
и комбинаций.
  Паттерн Компоновщик позволяет 
клиенту выполнять однородные 
операции с комбинациями и отдельными объектами.
  В реализации паттерна Компоновщик приходится искать 
баланс между прозрачностью, 
безопасностью и вашими потребностями.
Еще один важный 
принцип, относящийся 
к изменениям 
в архитектуре.
Facade — Encapsulates a request as an object, 
thereby letting you 
parameterize clients 
with different requests, 
queue or log requests, 
and support undoable 
operations.
Еще одна глава 
«два в одном».
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты 
для расширения, но закрыты
для изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Взаимодействуйте только 
с «друзьями».
Не вызывайте нас — мы сами 
вас вызовем.
Класс должен иметь только 
одну причину для изменений.
Принципы
КЛЮЧЕВЫЕ 
МОМЕНТЫ
Фасад — предоставляет 
унифицированный интерфейс 
к группе интерфейсов подсистемы. Фасад определяет 
высокоуровневый интерфейс, 
упрощающий работу с подсистемой.
Шаблонный Метод — 
определяет "скелет» алгоритма в методе, оставляя определение реализации некоторых шагов 
субклассам. Субклассы могут 
переопределять некоторые части алгоритма без изменения его 
структуры.
Итератор предоставляет механизм последовательного 
перебора элементов коллекции без 
раскрытия ее внутреннего представления.
Компоновщик объединяет объекты в древовидные структуры для 
представления иерархий «часть–
целое». 
400 глава 9
ответы к упражнениям
? A. Мы программируем для конкретных реализаций PancakeHouseMenu и DinerMenu, а не для 
интерфейсов.
? B. Официантка не реализует Java 
Waitress API, а следовательно, не 
соответствует стандарту.
? C. Если мы решим перейти 
с DinerMenu на другое меню с реализацией на базе Hashtable, нам 
придется изменять большой объем кода.
? D. Официантка должна знать, как 
в каждом объекте меню организована внутренняя коллекция элементов, а это нарушает инкапсуляцию.
? E. В реализации присутствует дублирование кода: метод printMenu() 
содержит два разных цикла для 
перебора двух разновидностей 
меню. А при появлении третьего 
меню понадобится еще один цикл.
? F. Реализация не использует язык 
MXML (Menu XML), что снижает 
ее универсальность.
Какие из следующих утверждений относятся к нашей реализации 
printMenu()? 
1. 
2. 
3. 
Реализовать интерфейс Menu.
Избавиться от getItems().
Добавить метод createIterator() и возвращать итератор 
для перебора значений из HashMap.
А как бы вы подошли к реализации новых требований к архитектуре? 
Подумайте, прежде чем перевернуть страницу.
Возьми в руку карандаш
 Решение
Возьми в руку карандаш
 Решение
паттерны итератор и компоновщик
дальше   401
Обратите внимание: 
эта реализация Iterator 
не поддерживает 
remove().
Восстановленный итератор для DinerMenu 
с чередованием элементов
import java.util.Iterator;
import java.util.Calendar;
public class AlternatingDinerMenuIterator
MenuItem[] items;
int position;
this.items = items;
position = Calendar.DAY_OF_WEEK % 2;
MenuItem menuItem = items[position];
position = position + 2;
return menuItem;
throw new UnsupportedOperationException(
 "Alternating Diner Menu Iterator does not support remove()");
public AlternatingDinerMenuIterator(MenuItem[] items)
implements Iterator<MenuItem>
public MenuItem next() {
public boolean hasNext() {
if (position >= items.length || items[position] == null) {
 return false;
} else {
 return true;
}
public void remove() {
}
}
}
}
}
} }
Магниты с кодами. Решение
402 глава 9
решение упражнений
Соедините каждый паттерн с его описанием:
Паттерн Описание
Стратегия
Адаптер
Итератор
Фасад
Компоновщик
Наблюдатель
Клиент выполняет одинаковые 
операции с коллекциями и отдельными объектами
Предоставляет механизм перебора коллекций без раскрытия 
внутренней реализации
Упрощает интерфейс группы 
классов
Изменяет интерфейс одного 
или нескольких классов
Оповещает группу объектов 
об изменениях состояния
Инкапсулирует взаимозаменяемые варианты поведения и выбирает один из них посредством 
делегирования
Кто и что делает?
решение
Малоизвестный факт: паттерны Стратегия и Состояние — близнецы, разлученные при рождении. Можно было бы ожидать, что их жизненные пути будут 
похожими, но паттерну Стратегия удалось построить невероятно успешный бизнес с 
взаимозаменяемыми алгоритмами, тогда как паттерн Состояние выбрал, пожалуй, более благородный путь – он помогает объектам управлять своим поведением за счет изменения своего внутреннего состояния. Но какими бы разными ни были их пути, в их 
внутренней реализации используются практически одинаковые архитектуры. Разве такое 
возможно? Как вы увидите, Стратегия и Состояние используются для совершенно разных целей. Сначала мы присмотримся к паттерну Состояние и разберемся в его сути, 
а в оставшейся части главы будем изучать отношения между этими паттернами.
10 Паттерн Состояние
Состояние дел
Я-то думала, что в Объектвиле 
меня ждет легкая жизнь — но за 
каждым углом меня поджидает 
очередное требование о внесении 
изменений! Я на грани нервного срыва! 
Возможно, мне все же стоило 
посещать клуб любителей паттернов 
у Бетти. Я в ужасном состоянии!
404 глава 10
Автоматы по продаже жевательной резинки стали 
высокотехнологичными устройствами. Да, все верно — основные производители обнаружили, что размещение процессоров в машинах позволяет поднять 
продажи, отслеживать запасы в сети и с большей точностью анализировать предпочтения покупателей.
Но производители автоматов хорошо разбираются 
в жевательной резинке, а не в программировании, 
поэтому они обратились к вам за помощью:
Техника на грани фантастики
Mighty Gumball, Inc.
Машина с жевательной 
резинкой не бывает 
полупустой
Как нам кажется, контроллер автомата должен 
работать примерно так. Надеемся, вы реализуете 
эту схему на Java! Возможно, в будущем в нее будет 
добавлено новое поведение; постарайтесь сделать 
архитектуру гибкой и простой в сопровождении!
 — Инженеры Mighty Gumball
Нет
шариков
Есть
монетка
Нет
монетки
Шарик
продан
бросить
монетку
вернуть 
монетку
дернуть
за рычаг
Во всяком случае 
они так говорят, 
хотя, скорее всего, 
им просто надоела 
техника прошлого 
века и они хотят 
сделать свою работу более интересной.
выдать 
шарик
шарики = 0
шарики > 0
техника на грани фантастики
паттерн состояние
далее   405
Разговор в офисе
Посмотрим 
на диаграмму 
и попытаемся понять, 
чего хочет заказчик...
Джуди: Похоже на диаграмму состояний.
Джо: Верно, каждый кружок — это состояние...
Джуди: ...а стрелка — переход.
Фрэнк: Эй, не торопитесь — я слишком давно изучал диаграммы 
состояния. Можете в двух словах напомнить, что это такое?
Джуди: Конечно, Фрэнк. Посмотри на кружки: это состояния. 
Вероятно, «Нет монетки» — исходное состояние автомата, потому 
что он ждет, пока в него бросят монетку. Каждое состояние представляет собой некую конфигурацию автомата, а переход в другое 
состояние происходит в результате некой операции.
Джо: Точно. Чтобы перейти в другое состояние, нужно что-то сделать — скажем, бросить в автомат 
монетку. Видишь стрелку от кружка «Нет монетки» к кружку «Есть монетка»?
Фрэнк: Вижу...
Джо: Если автомат находится в состоянии «Нет монетки» и ты бросишь в него монетку, то он перейдет в состояние «Есть монетка». Происходит переход состояния.
Фрэнк: Ага, понятно! А если автомат находится в состоянии «Есть монетка», я могу либо дернуть за 
рычаг для перехода в состояние «Шарик продан», либо нажать кнопку возврата и вернуться в состояние «Нет монетки».
Джуди: Точно!
Фрэнк: Вроде бы ничего страшного. Четыре состояния, да и действий, похоже, тоже четыре: «бросить монетку», «вернуть монетку», «дернуть за рычаг» и «выдать шарик». Но... потом мы проверяем количество шариков в состоянии «Шарик продан» и переходим либо в состояние «Нет шариков», либо 
в состояние «Нет монетки». Значит, всего пять переходов между состояниями.
Джуди: Проверка количества шариков также подразумевает, что мы должны где-то хранить текущее 
количество шариков. Каждый выданный шарик может оказаться последним; для такого случая и предусмотрен переход в состояние «Нет шариков».
Джо: И не забудьте, что пользователь может сделать что-нибудь бессмысленное: попытаться вернуть 
монетку, когда ее нет, или бросить сразу две монетки.
Фрэнк: Да, я об этом не подумал; придется учесть такую возможность.
Джо: Для каждого возможного действия необходимо проверить, в каком состоянии находится автомат, и выполнить соответствующую операцию. Давайте-ка запрограммируем эту диаграмму состояний...
Фрэнк Джуди Джо
406 глава 10
Краткий курс конечных автоматов
бросить
монетку
вернуть 
монетку
дернуть за рычаг
Действия образуют 
интерфейс автомата — 
набор операций, которые 
с ним можно выполнить.
Как преобразовать диаграмму состояний в программный код? Далее приводится краткое описание процесса реализации конечных автоматов:
1 Соберите все состояния:
Шарик
продан
 Нет 
монетки
Есть
монетка
Нет
шариков
Все возможные состояния — 
их четыре.
Создайте переменную экземпляра для хранения текущего состояния, определите 
значение для каждого возможного состояния:
2
final static int SOLD_OUT = 0;
final static int NO_QUARTER = 1;
final static int HAS_QUARTER = 2;
final static int SOLD = 3;
int state = SOLD_OUT;
Каждое состояние представлено 
целым числом...
...а это переменная экземпляра для хранения 
текущего состояния. Мы присваиваем ей 
исходное значение SOLD_OUT, потому что 
только что распакованный и включенный 
автомат пуст.
3 Собираем все действия, которые могут выполняться в системе:
Согласно диаграмме, выполнение 
любого из этих действий приводит 
к изменению состояния.
выдать
«Выдать» — внутреннее действие, 
которое автомат выполняет 
самостоятельно.
краткий курс конечных автоматов
паттерн состояние
далее   407
Теперь мы создадим класс, который моделирует конечный автомат. Для каждого 
действия создается метод, который использует условные конструкции для выбора 
поведения, соответствующего каждому состоянию. Например, для действия «бросить монетку» пишется метод следующего вида:
4
 public void insertQuarter() {
 if (state == HAS_QUARTER) {
 System.out.println("You can't insert another quarter");
 } else if (state == NO_QUARTER) {
 state = HAS_QUARTER;
 System.out.println("You inserted a quarter");
 } else if (state == SOLD_OUT) {
 System.out.println("You can't insert a quarter, the machine is sold out");
 } else if (state == SOLD) {
 System.out.println("Please wait, we're already giving you a gumball");
 }
}
Условная 
конструкция 
проверяет все 
возможные 
состояния...
...с возможностью перехода в другое состояние, 
как показано на диаграмме.
После краткого обзора можно заняться реализацией автомата!
...и выдает для каждого возможного 
состояния соответствующее поведение...
Стандартный способ моделирования состояния: в объекте 
создается переменная экземпляра, 
в которой хранятся возможные коды 
состояния, а условные конструкции 
в методах обрабатывают разные 
состояния.
408 глава 10
public class GumballMachine {
 final static int SOLD_OUT = 0;
 final static int NO_QUARTER = 1;
 final static int HAS_QUARTER = 2;
 final static int SOLD = 3;
 int state = SOLD_OUT;
 int count = 0;
 
 public GumballMachine(int count) {
 this.count = count;
 if (count > 0) {
 state = NO_QUARTER;
 }
 }
 
 
 
 public void insertQuarter() {
 if (state == HAS_QUARTER) {
 System.out.println("You can’t insert another quarter");
 } else if (state == NO_QUARTER) {
 state = HAS_QUARTER;
 System.out.println("You inserted a quarter");
 } else if (state == SOLD_OUT) {
 System.out.println("You can’t insert a quarter, the machine is sold out");
 } else if (state == SOLD) {
 System.out.println("Please wait, we’re already giving you a gumball");
 }
 }
 
Программирование
Четыре состояния соответствуют 
состояниям на диаграмме.
Переменная экземпляра, в которой 
будет храниться текущее 
состояние. Инициализируется 
значением SOLD_OUT.
Во второй переменной хранится 
количество шариков в автомате.
Конструктор получает исходное количество шариков. Если оно отлично от нуля, 
то автомат переходит в состояние 
NO_QUARTER, ожидая, пока кто-нибудь 
бросит монетку; в противном случае автомат остается в состоянии SOLD_OUT.
Начинаем 
реализовывать 
действия в виде 
методов...
Когда в автомат 
бросают монетку, 
если...
...в автомате уже есть 
монетка, мы сообщаем об 
этом покупателю; в противном случае автомат 
принимает монетку и переходит в состояние 
HAS_QUARTER.
А если все шарики 
распроданы, автомат 
отклоняет монетку.
Итак, пришло время реализовать логику автомата для продажи жевательной 
резинки. Мы уже выяснили, что нам понадобится переменная экземпляра для 
хранения текущего состояния. Что касается действий, необходимо реализовать 
действия «бросить монетку», «вернуть монетку», «дернуть за рычаг» и «выдать 
шарик»; также следует реализовать состояние «Нет шариков».
Если шарик был куплен, 
следует подождать 
завершения операции, прежде 
чем бросать другую монетку.
реализация торгового автомата
паттерн состояние
далее   409
 public void ejectQuarter() {
 if (state == HAS_QUARTER) {
 System.out.println("Quarter returned");
 state = NO_QUARTER;
 } else if (state == NO_QUARTER) {
 System.out.println("You haven’t inserted a quarter");
 } else if (state == SOLD) {
 System.out.println("Sorry, you already turned the crank");
 } else if (state == SOLD_OUT) {
 System.out.println("You can’t eject, you haven’t inserted a quarter yet");
 }
 }
 public void turnCrank() {
 if (state == SOLD) {
 System.out.println("Turning twice doesn’t get you another gumball!");
 } else if (state == NO_QUARTER) {
 System.out.println("You turned but there’s no quarter");
 } else if (state == SOLD_OUT) {
 System.out.println("You turned, but there are no gumballs");
 } else if (state == HAS_QUARTER) {
 System.out.println("You turned...");
 state = SOLD;
 dispense();
 }
 }
 public void dispense() {
 if (state == SOLD) {
 System.out.println("A gumball comes rolling out the slot");
 count = count — 1;
 if (count == 0) {
 System.out.println("Oops, out of gumballs!");
 state = SOLD_OUT;
 } else {
 state = NO_QUARTER;
 }
 } else if (state == NO_QUARTER) {
 System.out.println("You need to pay first");
 } else if (state == SOLD_OUT) {
 System.out.println("No gumball dispensed");
 } else if (state == HAS_QUARTER) {
 System.out.println("No gumball dispensed");
 }
 }
 // Другие методы: toString(), refill() и т.д.
}
Если покупатель пытается 
вернуть монетку... Если монетка есть, автомат 
возвращает ее и переходит 
в состояние NO_QUARTER.
Шарик уже 
куплен, возврат 
невозможен!
Если монетки нет, 
то вернуть ее 
невозможно.
Покупатель пытается дернуть за рычаг...
Выдача 
невозможна — 
в автомате нет 
шариков.
Сначала нужно 
бросить монетку.
Покупатель получает 
шарик. Переходим в состояние SOLD и вызываем метод dispense().
Кто-то пытается обмануть автомат.
Если шарики кончились, возврат невозможен — автомат не принимает монетки!
Вызывается для выдачи 
шарика.
Если шарик был последним, 
автомат переходит 
в состояние SOLD_OUT, 
а если нет — возвращается 
к состоянию «Нет монетки».
Автомат в состоянии 
SOLD, выдать покупку!
Все это не должно 
происходить, но если 
все же произойдет, 
автомат выдаст ошибку, 
а не шарик.
410 глава 10
Внутреннее тестирование
Похоже, мы создали надежную архитектуру на базе хорошо продуманной методологии, не правда ли? 
Давайте проведем небольшое внутреннее тестирование, прежде чем передавать код заказчику для оснащения реальных торговых автоматов. Наша тестовая программа:
public class GumballMachineTestDrive {
 public static void main(String[] args) {
 GumballMachine gumballMachine = new GumballMachine(5);
 System.out.println(gumballMachine);
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 System.out.println(gumballMachine);
 gumballMachine.insertQuarter();
 gumballMachine.ejectQuarter();
 gumballMachine.turnCrank();
 System.out.println(gumballMachine);
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 gumballMachine.ejectQuarter();
 System.out.println(gumballMachine);
 gumballMachine.insertQuarter();
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 System.out.println(gumballMachine);
 }
}
тестирование автомата
Загружаем пять 
шариков.
Выводим состояние автомата.
Бросаем монетку...
Дергаем за рычаг; автомат должен 
выдать шарик.
Снова выводим состояние.
Бросаем монетку...
Требуем ее обратно. Дергаем за рычаг; автомат не должен
выдать шарик.
И снова выводим состояние автомата.
Бросаем монетку...
Дергаем за рычаг; автомат должен 
выдать шарик.
Бросаем монетку...
Дергаем за рычаг; автомат должен
выдать шарик.
Требуем вернуть монетку, 
которую не бросали.
Снова выводим состояние автомата.
Бросаем ДВЕ монетки...
Дергаем за рычаг; должны
получить шарик.
Даем возрастающую нагрузку...
И в последний раз выводим состояние автомата.
паттерн состояние
далее   411
%java GumballMachineTestDrive
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 5 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
A gumball comes rolling out the slot
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 4 gumballs
Machine is waiting for quarter
You inserted a quarter
Quarter returned
You turned but there’s no quarter
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 4 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
A gumball comes rolling out the slot
You inserted a quarter
You turned...
A gumball comes rolling out the slot
You haven’t inserted a quarter
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 2 gumballs
Machine is waiting for quarter
You inserted a quarter
You can’t insert another quarter
You turned...
A gumball comes rolling out the slot
You inserted a quarter
You turned...
A gumball comes rolling out the slot
Oops, out of gumballs!
You can’t insert a quarter, the machine is sold out
You turned, but there are no gumballs
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 0 gumballs
Machine is sold out
File Edit Window Help mightygumball.com
Дергаем за рычаг; автомат не должен
выдать шарик.
412 глава 10
Кто бы сомневался... запрос на изменение!
Фирма Mighty Gumball, Inc. установила ваш код на своих новейших автоматах, и специалисты по качеству испытывают его на прочность. Пока, 
по их мнению, все выглядит замечательно.
Настолько замечательно, что заказчик решил выйти на новый уровень...
Be a Winner!
One in Ten 
get a FREE 
GUMBALL
По нашему мнению, 
превращение покупки в игру 
значительно повысит объем 
продаж. Такие наклейки 
появятся на каждом автомате. 
Мы так рады, что перевели 
свои автоматы на Java, — ведь 
это будет просто, верно?
Директор 
Mighty 
Gumball, Inc.
игра для покупателей
Шарики
Тебе повезет!
Один шарик
из десяти
БЕСПЛАТНО!
В 10% случаев покупатель, дернувший 
за рычаг, получает 
два шарика вместо 
одного.
паттерн состояние
далее   413
Нарисуйте диаграмму состояний для автомата с поддержкой призовой игры «1 из 10». С 10%-й вероятностью при продаже автомат 
выдает два шарика вместо одного. Прежде чем двигаться дальше, 
сверьте свой ответ с нашим (приведен в конце главы).
Mighty Gumball, Inc.
Машина с жевательной 
резинкой не бывает 
полупустой
Нарисуйте диаграмму состояний
на бланке Mighty Gumball.
Головоломка
414 глава 10
public void insertQuarter() {
 // Бросить монетку
}
public void ejectQuarter() {
 // Вернуть монетку
}
public void turnCrank() {
 // Дернуть рычаг
}
public void dispense() {
 // Выдать шарик
}
Печальное СОСТОЯНИЕ дел...
То, что программное обеспечение автомата написано на базе хорошо продуманной методологии, еще 
не значит, что оно будет легко расширяться. Стоит оглянуться на свой код и подумать, что необходимо сделать для его изменения...
final static int SOLD_OUT = 0;
final static int NO_QUARTER = 1;
final static int HAS_QUARTER = 2;
final static int SOLD = 3;
Для начала необходимо определить 
новое состояние WINNER. Само по себе 
это не так плохо...
...но затем в каждый метод придется 
включить новое условие для обработки 
состояния WINNER; иначе говоря, 
придется изменить большой объем 
кода.
Особенно много хлопот будет с методом 
turnCrank(): придется добавить код 
для проверки выигрыша, а потом 
переходить либо в состояние WINNER, 
либо в состояние SOLD.
? A. Код не соответствует принципу 
открытости/закрытости.
? B. Такой стиль программирования 
характерен для FORTRAN.
? C. Архитектуру трудно назвать объектно-ориентированной.
? D. Переходы между состояниями не 
очевидны: они «прячутся» в множестве условных конструкций.
? E. Переменные аспекты этой архитектуры не инкапсулированы.
? F. Дальнейшие изменения с большой 
вероятностью приведут к ошибкам 
в готовом коде.
Какие из следующих утверждений относятся к нашей реализации?
(Выберите все подходящие утверждения.)
начинаются проблемы
Возьми в руку карандаш
паттерн состояние
далее   415
Фрэнк: Ты права! Нужно заняться рефакторингом, чтобы упростить 
сопровождение и изменение кода.
Джуди: Необходимо по возможности локализовать поведение каждого состояния, чтобы внесение изменений в одном состоянии не 
угрожало нарушением работоспособности другого кода.
Фрэнк: Верно, принцип «инкапсулируйте то, что изменяется».
Джуди: Вот именно.
Фрэнк: А если выделить поведение каждого состояния в отдельный 
класс, то каждое состояние будет просто реализовывать свои действия.
Джуди: Точно. А автомат будет просто делегировать выполнение 
операций объекту, представляющему текущее состояние.
Фрэнк: Ага, «отдавайте предпочтение композиции перед наследованием»... Снова принципы в деле.
Джуди: Я не уверена на сто процентов, что это решение сработает, 
но по крайней мере это на что-то похоже.
Фрэнк: Упростит ли оно добавление новых состояний?
Джуди: Пожалуй... Код все равно придется менять, но изменения 
будут значительно менее масштабными, потому что для добавления 
нового состояния нам придется добавить новый класс. И возможно, 
переделать пару-тройку переходов.
Фрэнк: Идея мне нравится. Беремся за дело!
Так не пойдет. Первая версия была 
хороша, но она не выдержит испытания 
временем, когда заказчик будет требовать 
реализации все нового поведения. Ошибки 
только испортят нашу репутацию. 
416 глава 10
Новая архитектура
1
2
3
Определяем интерфейс State, содержащий метод для 
каждого возможного действия.
Реализуем класс State для каждого состояния автомата. 
Эти классы определяют поведение автомата, находящегося в соответствующем состоянии.
Наконец, мы избавляемся от всего лишнего кода и вместо 
этого делегируем работу классу State.
Появился новый план: вместо сопровождения и модификации готового кода мы переработаем его, инкапсулируем объекты состояния в отдельных классах, а затем при выполнении действия делегируем 
операции объекту текущего состояния.
Такой подход соответствует основным принципам проектирования, так что полученная в конечном 
счете архитектура будет более простой в сопровождении. Основная последовательность действий:
Как вы вскоре убедитесь, мы не просто следуем принципам проектирования, 
а реализуем паттерн Состояние. Но формальное определение этого паттерна 
будет приведено после того, как мы переработаем наш код...
новая архитектура состояний
Сейчас 
мы инкапсулируем 
все поведение состояния 
в одном классе. Инкапсуляция 
способствует локализации 
поведения, а также упрощает его 
понимание и модификацию.
паттерн состояние
далее   417
Определение интерфейса State и классов
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
<<interface>> State
HasQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
NoQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
SoldOutState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
public class GumballMachine {
 final static int SOLD_OUT = 0;
 final static int NO_QUARTER = 1;
 final static int HAS_QUARTER = 2;
 final static int SOLD = 3;
 int state = SOLD_OUT;
 int count = 0;
...для каждого состояния 
создается отдельный 
класс.
Интерфейс всех состояний. Методы непосредственно 
соответствуют действиям, которые могут 
выполняться с автоматом (и являются аналогами 
методов из предыдущей версии).
Начнем с создания интерфейса State, реализуемого всеми классами состояний:
Чтобы понять, какие состояния нам 
понадобятся, обратимся к предыдущей версии кода...
Затем каждое состояние архитектуры 
инкапсулируется в классе, реализующем 
интерфейс State.
SoldState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
WinnerState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
И не забудьте о новом состоянии, которое тоже должно реализовать интерфейс 
State. Мы вернемся к нему после переработки первой версии кода. 
418 глава 10
Реализация состояний начинается с определения поведения классов при выполнении каждого действия. Заполните следующую диаграмму описаниями 
поведения каждого класса; мы уже заполнили некоторые описания за вас.
определение состояний
Возьми в руку карандаш
Перейти в состояние HasQuarterState.
«Вы не бросили монетку».
«Подождите выдачи шарика».
«В автомате нет шариков».
Перейти в состояние SoldState.
NoQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
SoldOutState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
SoldState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
HasQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
Выдать шарик. Проверить количество шариков;
если > 0, перейти в NoQuarterState, в противном 
случае перейти в SoldOutState.
WinnerState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
Заполните все описания, даже те, которые будут реализованы позже.
паттерн состояние
далее   419
Реализация классов состояний
public class NoQuarterState implements State {
 GumballMachine gumballMachine;
 public NoQuarterState(GumballMachine gumballMachine) {
 this.gumballMachine = gumballMachine;
 }
 public void insertQuarter() {
 System.out.println("You inserted a quarter");
 gumballMachine.setState(gumballMachine.getHasQuarterState());
 }
 public void ejectQuarter() {
 System.out.println("You haven’t inserted a quarter");
 }
 public void turnCrank() {
 System.out.println("You turned, but there’s no quarter");
 }
 public void dispense() {
 System.out.println("You need to pay first");
 } 
}
Мы определились с желаемым поведением; осталось реализовать его в программном коде. Итоговый 
код принципиально не отличается от написанного ранее кода конечного автомата, но на этот раз он 
разбит на классы.
Начнем с состояния NoQuarterState:
Класс должен реализовать интерфейс State. Конструктору передается ссылка 
на объект автомата, которая 
просто сохраняется в переменной 
экземпляра.
Если в автомат брошена 
монетка, вывести сообщение 
и перейти в состояние 
HasQuarterState.
Чтобы вернуть монетку, нужно ее сначала бросить!
Нет монетки — нет 
шарика.
Мы реализуем варианты 
поведения для текущего 
состояния. В некоторых случаях 
поведение подразумевает переход 
автомата в новое состояние.
Шарик выдается только 
за монетку.
Скоро вы поймете,
что здесь происходит...
420 глава 10
public class GumballMachine {
 State soldOutState;
 State noQuarterState;
 State hasQuarterState;
 State soldState;
 State state = soldOutState;
 int count = 0;
public class GumballMachine {
 final static int SOLD_OUT = 0;
 final static int NO_QUARTER = 1;
 final static int HAS_QUARTER = 2;
 final static int SOLD = 3;
 int state = SOLD_OUT;
 int count = 0;
Код автомата переводится на использование новых классов вместо 
статических целочисленных кодов. 
Две версии кода в целом похожи, 
просто в одной используются целые 
числа, а в другой объекты...
Прежде чем завершать рассмотрение классов состояния, мы переработаем класс автомата 
GumballMachine. Это поможет лучше понять суть взаимодействия компонентов новой архитектуры. Начнем с переменных экземпляров, относящихся к реализации состояния, а затем перейдем от целочисленных кодов к объектам состояния:
Переработка класса GumballMachine
Старый код
Новый код
Все объекты State создаются 
и инициализируются в конструкторе. Теперь содержит объект State вместо int.
объекты состояния
паттерн состояние
далее   421
public class GumballMachine {
 State soldOutState;
 State noQuarterState;
 State hasQuarterState;
 State soldState;
 State state;
 int count = 0;
 public GumballMachine(int numberGumballs) {
 soldOutState = new SoldOutState(this);
 noQuarterState = new NoQuarterState(this);
 hasQuarterState = new HasQuarterState(this);
 soldState = new SoldState(this);
 this.count = numberGumballs;
 if (numberGumballs > 0) {
 state = noQuarterState;
 } else {
 state = soldOutState; 
 }
 }
 public void insertQuarter() {
 state.insertQuarter();
 }
 public void ejectQuarter() {
 state.ejectQuarter();
 }
 public void turnCrank() {
 state.turnCrank();
 state.dispense();
 }
 void setState(State state) {
 this.state = state;
 }
 void releaseBall() {
 System.out.println("A gumball comes rolling out the slot...");
 if (count != 0) {
 count = count — 1;
 }
 }
 
 // Другие методы, включая get-методы для всех состояний...
}
 
А теперь полный код класса GumballMachine...
Все возможные состояния...
...и переменная экземпляра для хранения State.
В переменной count хранится количество 
шариков — изначально автомат пуст.
Конструктор получает исходное количество шариков и сохраняет его в переменной.
Он также создает экземпляры 
State для всех состояний.
Если количество шариков >0, 
устанавливается состояние NoQuarterState; 
в противном случае начинаем в состоянии 
SoldOutState.
Действия реализуются ОЧЕНЬ 
ПРОСТО: операция делегируется 
объекту текущего состояния.
Для метода dispense() в классе GumballMachine метод действия не нужен, потому что это внутреннее действие; пользователь не может напрямую 
потребовать, чтобы автомат выдал шарик. Однако метод dispense() для объекта State вызывается 
из метода turnCrank().
Вспомогательный метод releaseBall() отпускает шарик и уменьшает значение 
переменной count.
Этот метод позволяет другим объектам 
(в частности, нашим объектам State) 
перевести автомат в другое состояние.
Такие методы, как getNoQuarterState(), для получения объекта состояния 
или такие, как getCount(), для получения количества шариков.
422 глава 10
public class HasQuarterState implements State {
 GumballMachine gumballMachine;
 public HasQuarterState(GumballMachine gumballMachine) {
 this.gumballMachine = gumballMachine;
 }
 
 public void insertQuarter() {
 System.out.println("You can’t insert another quarter");
 }
 public void ejectQuarter() {
 System.out.println("Quarter returned");
 gumballMachine.setState(gumballMachine.getNoQuarterState());
 }
 public void turnCrank() {
 System.out.println("You turned...");
 gumballMachine.setState(gumballMachine.getSoldState());
 }
 public void dispense() {
 System.out.println("No gumball dispensed");
 }
}
Реализация других состояний
К этому моменту вы уже примерно представляете, как организовано взаимодействие автомата и состояний. Давайте реализуем классы состояний HasQuarterState и SoldState...
Некорректное действие для этого состояния.
Другое некорректное 
действие для этого 
состояния.
Вернуть монетку 
и перейти в состояние NoQuarterState.
Когда покупатель 
дергает за рычаг, 
автомат переводится 
в состояние SoldState 
(вызовом метода 
setState() с объектом 
SoldState). Для 
получения объекта 
SoldState используется 
метод getSoldState() 
(один из get-методов, 
определенных для всех 
состояний).
При создании экземпляра 
состояния ему передается 
ссылка на GumballMachine. 
Она используется для перевода автомата в другое состояние.
реализация других состояний
паттерн состояние
далее   423
public class SoldState implements State {
 //Конструктор и переменные экземпляров
 public void insertQuarter() {
 System.out.println("Please wait, we’re already giving you a gumball");
 }
 public void ejectQuarter() {
 System.out.println("Sorry, you already turned the crank");
 }
 public void turnCrank() {
 System.out.println("Turning twice doesn’t get you another gumball!");
 }
 
 public void dispense() {
 gumballMachine.releaseBall();
 if (gumballMachine.getCount() > 0) {
 gumballMachine.setState(gumballMachine.getNoQuarterState());
 } else {
 System.out.println("Oops, out of gumballs!");
 gumballMachine.setState(gumballMachine.getSoldOutState());
 }
 }
}
Теперь займемся классом SoldState...
Некорректные действия 
для этого состояния.
Здесь начинается 
настоящая работа...
Находимся в состоянии SoldState,
то есть покупка оплачена. Сначала 
приказываем автомату выдать шарик.
Затем проверяем количество 
шариков и в зависимости от результата переходим в состояние 
NoQuarterState или SoldOutState.
Присмотритесь к реализации GumballMachine. При некорректном повороте рычага (скажем, 
если покупатель не бросил монетку) автомат все равно может выдать шарик, хотя это и не 
обязательно. Как решить эту проблему?
Мозговой
штурм
424 глава 10
Остался всего один нереализованный класс состояния: SoldOutState. Почему 
бы вам не реализовать его? Тщательно продумайте поведение автомата в каждой ситуации. Проверьте ответ, прежде чем двигаться дальше... 
public class SoldOutState implements State {
 GumballMachine gumballMachine;
 public SoldOutState(GumballMachine gumballMachine) {
 }
 public void insertQuarter() {
 }
 public void ejectQuarter() {
 }
 public void turnCrank() {
 }
 public void dispense() {
 }
}
ваша очередь реализовывать состояние
Возьми в руку карандаш
паттерн состояние
далее   425
Прежде всего мы создали реализацию торгового автомата, которая на структурном уровне отличается 
от первой версии, но при этом сохранила прежнюю функциональность. Преимущества структурного 
изменения реализации:
Чуть подробнее о функциональном аспекте того, что мы сделали:
Что мы сделали к настоящему моменту...
Состояния GumballMachine
  Локализация поведения каждого состояния в отдельном классе.
  Исключение многочисленных конструкций if, усложнявших сопровождение кода.
  Каждое состояние закрыто для изменения, однако сам автомат открыт для расширения 
посредством добавления новых классов состояний (чем мы вскоре займемся).
  Создание кодовой базы и структуры классов, приближенной к диаграмме переходов автомата, 
а следовательно, более простой для чтения и понимания.
SoldOut
NoQuarter
HasQuarter
Sold
GumballMachine
текущее состояние
В классе GumballMachine 
хранится экземпляр 
каждого класса состояния.
Текущее состояние автомата 
всегда представлено одним из 
этих экземпляров.
426 глава 10
SoldOut
NoQuarter
HasQuarter
Sold
GumballMachine
Состояния GumballMachine
текущее состояние
turnCrank()
SoldOut
NoQuarter
GumballMachine
HasQuarter
Sold
Состояния GumballMachine
текущее состояние
Действия делегируются 
объекту текущего состояния.
В данном случае метод 
turnCrank() вызывается 
в состоянии HasQuarter, 
поэтому автомат переходит 
в состояние Sold.
...после чего автомат 
переходит в состояние 
SoldOut или NoQuarter 
в зависимости от 
количества оставшихся 
шариков.
Автомат входит 
в состояние Sold 
и выдает шарик...
turnCrank()
Шарики 
остались.
Шариков 
больше нет.
ПЕРЕХОД В СОСТОЯНИЕ SOLD
dispense()
переходы между состояниями
паттерн состояние
далее   427
SoldOut
SoldOut
NoQuarter
HasQuarter
Sold
GumballMachine
Состояния GumballMachine
NoQuarter
HasQuarter
Sold
GumballMachine
Состояния GumballMachine
SoldOut
NoQuarter
HasQuarter
Sold
GumballMachine
GumballMachine
Состояния GumballMachine
SoldOut
NoQuarter
HasQuarter
Sold
Состояния GumballMachine
1 2
3 4
За сценой.
Самостоятельное путешествие
Нарисуйте диаграмму работы автомата, начиная с состояния NoQuarter. 
Укажите на диаграмме действия и результаты работы автомата. В этом 
упражнении следует считать, что количество шариков в автомате достаточно велико.
Возьми в руку карандаш
428 глава 10
Определение паттерна Состояние
Паттерн Состояние управляет изменением поведения объекта при изменении его внутреннего состояния. Внешне 
это выглядит так, словно объект меняет свой класс.
request()
Context
Да, мы успешно реализовали паттерн Состояние! А теперь давайте разберемся с теоретической стороной дела:
Первая часть описания выглядит вполне разумно, не так ли? Поскольку паттерн инкапсулирует состояние в отдельных классах и делегирует операции объекту, представляющему текущее состояние, поведение изменяется вместе с внутренним состоянием. Так, если автомат из нашего примера находится 
в состоянии NoQuarterState и в него бросают монетку, его поведение (автомат принимает монетку) 
будет отличаться от поведения в состоянии HasQuarterState (автомат отвергает монетку).
Но что со второй частью определения? Что значит «словно объект меняет свой класс»? Представьте 
происходящее с точки зрения клиента: если используемый объект полностью изменяет свое поведение, для клиента это равносильно переходу на работу с объектом другого класса. Конечно, на практике 
изменение класса имитируется простым переключением на другой объект состояния, задействованный в композиции.
Рассмотрим диаграмму классов паттерна Состояние:
state.handle()
handle()
State
handle()
ConcreteStateA
handle()
ConcreteStateB
Набор конкретных 
состояний.
Context — класс с несколькими 
внутренними состояниями. В нашем 
примере это класс GumballMachine.
Действия с Context 
делегируются объектам 
состояний для обработки.
Общий интерфейс всех конкретных 
состояний. Все состояния реализуют 
один интерфейс, а следовательно, 
являются взаимозаменяемыми.
Классы конкретных состояний обрабатывают 
запросы от Context. Каждый класс предоставляет 
собственную реализацию запроса. Таким образом, 
при переходе объекта Context в другое состояние 
изменяется и его поведение.
определение паттерна состояние
паттерн состояние
далее   429
А вы наблюдательны! Да, диаграммы классов практически совпадают, но эти два паттерна различаются своей целью.
В паттерне Состояние набор вариантов поведения инкапсулируется в объектах состояния; в любой момент времени контекст 
делегирует выполнение действий одному из этих объектов. Со 
временем текущее состояние переключается на другие объекты в соответствии с изменениями внутреннего состояния контекста, так что поведение контекста также изменяется со временем. При этом клиент обычно знает об объектах состояния 
очень мало (или вообще ничего не знает).
В паттерне Стратегия клиент обычно определяет объект стратегии, связываемый с контекстом. Хотя паттерн обеспечивает 
необходимую гибкость для изменения объекта стратегии во 
время выполнения, часто имеется объект стратегии, наиболее 
подходящий для объекта контекста. Например, в главе 1 некоторые утки инициализировались «типичным» поведением при 
полете, а для других (резиновых уток и приманок) выбиралось 
поведение, при котором они оставались на земле.
В общем случае паттерн Стратегия может рассматриваться как 
гибкая альтернатива субклассированию: если поведение класса определяется наследованием, класс жестко привязывается 
к этому поведению, даже если позднее его потребуется изменить. Паттерн Стратегия позволяет изменить поведение посредством компоновки с другим объектом.
Паттерн Состояние может рассматриваться как замена многочисленных условных конструкций в коде контекста: если поведение инкапсулировано в объектах состояния, для изменения 
поведения контекста достаточно выбрать другой объект состояния.
Один момент! 
Но эта диаграмма классов 
ПОЛНОСТЬЮ совпадает 
с диаграммой паттерна 
Стратегия!
430 глава 10
В: В классе GumballMachine выбор следующего 
состояния определяется объектами конкретных состояний. Всегда ли это так? 
О: Нет, не всегда. Также следующее состояние может выбираться классом контекста на основании диаграммы переходов.
В общем случае, если переходы между состояниями 
статичны, их рекомендуется размещать в контексте; 
если же переходы имеют динамическую природу, их 
лучше разместить в самом классе состояния (так, переход в состояние NoQuarter или SoldOut в нашем примере зависел от количества шариков, определяемого 
во время выполнения).
Недостаток определения переходов в классах состояний заключается в том, что оно создает зависимости между классами состояний. В своей реализации 
GumballMachine мы попытались свести к минимуму 
такие зависимости за счет использования get-методов 
вместо жесткого кодирования конкретных классов состояний.
Обратите внимание: принимаемое решение определяет, 
какие классы будут закрыты для изменений (класс контекста или классы состояний) в ходе эволюции системы.
В: Взаимодействует ли клиент с состояниями?
О: Нет. Состояния используются контекстом для 
представления его внутреннего состояния и поведения, поэтому все запросы к состояниям поступают от 
контекста. Клиент не может непосредственно изменить 
состояние контекста. Контекст обычно сам управляет 
своим состоянием, а попытки клиента изменить состояние контекста без участия последнего обычно нежелательны.
В: Если в приложении используется несколько 
экземпляров контекста, могут ли они совместно использовать объекты состояния?
О: Да, вполне. Более того, это обычная ситуация. 
Единственное требование заключается в том, что объекты состояния не могут обладать собственным внутренним состоянием; в противном случае для каждого 
контекста необходимо создать отдельный экземпляр.
Обычно в таких ситуациях каждое состояние присваивается статической переменной. Если состояние должно использовать методы или переменные контекста, 
то ссылка на контекст передается в каждом методе 
handler().
В: Похоже, использование паттерна Состояние 
всегда увеличивает количество классов в архитектуре. Посмотрите, сколько новых классов пришлось 
создать во второй версии GumballMachine! 
О: Верно, инкапсуляция поведения в отдельных 
классах состояний всегда увеличивает количество 
классов в архитектуре. Это стандартная цена, которую приходится платить за гибкость. Если только вы 
не пишете «одноразовую» реализацию с очень коротким сроком жизни, увеличьте количество классов, 
и скорее всего, вы не пожалеете об этом в долгосрочной перспективе. Причем учтите, что во многих 
случаях важно количество классов, с которыми имеет 
дело клиент, а лишние классы всегда можно скрыть 
от клиента (скажем, объявив их с пакетным уровнем 
видимости).
В: На диаграмме классов паттерна класс State обозначен как абстрактный. Но ведь в реализации нашего автомата используется интерфейс?
О: Да. Так как у нас нет общей функциональности 
для размещения в абстрактном классе, мы выбрали 
интерфейс. В своей реализации вы можете использовать абстрактный класс. В частности, это позволит вам 
позднее добавить методы в абстрактный класс без нарушения работоспособности конкретных реализаций 
состояния.
паттерн состояние в вопросах и ответах
часто Задаваемые вопросы
паттерн состояние
далее   431
Реализация игры «1 из 10»
Однако работа еще не закончена — нам нужно реализовать игру. Впрочем, в архитектуре 
на базе паттерна Состояние это делается очень просто. Сначала в класс GumballMachine 
добавляется новое состояние:
public class GumballMachine {
 State soldOutState;
 State noQuarterState;
 State hasQuarterState;
 State soldState;
 State winnerState;
 State state = soldOutState;
 int count = 0;
 // Методы
}
Добавляем переменную 
для состояния WinnerState 
и инициализируем 
ее в конструкторе.
Реализация класса WinnerState очень похожа на реализацию SoldState:
public class WinnerState implements State {
 // Переменные экземпляров и конструктор
 // Сообщение об ошибке для insertQuarter
 // Сообщение об ошибке для ejectQuarter
 // Сообщение об ошибке для turnCrank
 public void dispense() {
 gumballMachine.releaseBall();
 if (gumballMachine.getCount() == 0) {
 gumballMachine.setState(gumballMachine.getSoldOutState());
 } else {
 gumballMachine.releaseBall();
 System.out.println("YOU’RE A WINNER! You got two gumballs for your quarter");
 if (gumballMachine.getCount() > 0) {
 gumballMachine.setState(gumballMachine.getNoQuarterState());
 } else {
 System.out.println("Oops, out of gumballs!");
 gumballMachine.setState(gumballMachine.getSoldOutState());
 }
 }
 }
}
Выдаем два шарика, после чего 
переходим либо в состояние 
NoQuarterState, либо в состояние 
SoldOutState.
Как в SoldState.
Если аппарат 
может выдать 
два шарика, мы 
сообщаем пользователю, что ему 
повезло.
Не забудьте добавить get-метод 
для состояния WinnerState.
Если в автомате есть второй шарик, 
освобождаем его.
432 глава 10
public class HasQuarterState implements State {
 Random randomWinner = new Random(System.currentTimeMillis());
 GumballMachine gumballMachine;
 public HasQuarterState(GumballMachine gumballMachine) {
 this.gumballMachine = gumballMachine;
 }
 
 public void insertQuarter() {
 System.out.println("You can’t insert another quarter");
 }
 public void ejectQuarter() {
 System.out.println("Quarter returned");
 gumballMachine.setState(gumballMachine.getNoQuarterState());
 }
 public void turnCrank() {
 System.out.println("You turned...");
 int winner = randomWinner.nextInt(10);
 if ((winner == 0) && (gumballMachine.getCount() > 1)) {
 gumballMachine.setState(gumballMachine.getWinnerState());
 } else {
 gumballMachine.setState(gumballMachine.getSoldState());
 }
 }
 public void dispense() {
 System.out.println("No gumball dispensed");
 }
}
Добавляем генератор случайных чисел 
с 10%-й вероят­ностью выигрыша...
Завершение реализации игры
Осталось внести последние изменения: реализовать призовую игру 
и добавить переход в состояние WinnerState. Оба изменения вносятся 
в состояние HasQuarterState, так как именно в этом состоянии покупатель дергает за рычаг.
...проверяем, 
повезло ли 
покупателю.
Получилось на удивление просто! Мы включили в GumballMachine новое состояние, а затем реализовали его. В дальнейшем осталось лишь реализовать проверку 
выигрыша и переход в правильное состояние. Похоже, новая стратегия программирования себя оправдала...
Если покупателю повезло и в 
автомате остался второй шарик, 
переходим в состояние WinnerState; 
в противном случае переходим 
в состояние SoldState (как делалось 
ранее).
реализация игры 1 из 10
паттерн состояние
далее   433
Демоверсия для начальства
public class GumballMachineTestDrive {
 public static void main(String[] args) {
 GumballMachine gumballMachine = new GumballMachine(5);
 System.out.println(gumballMachine);
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 System.out.println(gumballMachine);
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 gumballMachine.insertQuarter();
 gumballMachine.turnCrank();
 System.out.println(gumballMachine);
 }
}
На демонстрацию нового кода зашел исполнительный директор фирмы-заказчика. Будем надеяться, 
что мы ничего не напутали с состояниями! Демоверсия должна быть короткой (всем известно, что 
руководство Mighty Gumball не любит подолгу задерживаться на одной теме), но при этом достаточно 
длинной, чтобы пользователь выиграл хотя бы один раз. 
Тестовый код почти не изменился; мы только 
немного сократили его.
Снова начинаем с пяти шариков.
Чтобы проверить, как работает призовая игра, мы 
постоянно бросаем монетки 
и дергаем за рычаг. И каждый раз выводим состояние 
автомата...
Все программисты ждут 
результатов тестирования!!!
434 глава 10
File Edit Window Help Whenisagumballajawbreaker?
%java GumballMachineTestDrive
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 5 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
A gumball comes rolling out the slot...
A gumball comes rolling out the slot...
YOU’RE A WINNER! You get two gumballs for your quarter
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 3 gumballs
Machine is waiting for quarter
You inserted a quarter
You turned...
A gumball comes rolling out the slot...
You inserted a quarter
You turned...
A gumball comes rolling out the slot...
A gumball comes rolling out the slot...
YOU’RE A WINNER! You get two gumballs for your quarter
Oops, out of gumballs!
Mighty Gumball, Inc.
Java-enabled Standing Gumball Model #2004
Inventory: 0 gumballs
Machine is sold out
%
Что это, везение? 
В демоверсии мы выиграли не один, а целых два раза!
В: Зачем создавать отдельное состояние WinnerState? Почему бы не выдать два шарика в состоянии SoldState?
О: Отличный вопрос. Состояния SoldState и WinnerState почти полностью идентичны, только WinnerState выдает два 
шарика вместо одного. Конечно, код выдачи двух шариков можно разместить и в SoldState. Недостаток такого решения 
заключается в том, что класс начинает представлять сразу ДВА состояния. Таким образом, за устранение дублирования 
приходится платить ясностью кода. Также стоит вспомнить о принципе, представленном в предыдущей главе: принципе 
единственной обязанности. Включая обязанности WinnerState в SoldState, вы наделяете SoldState ДВУМЯ обязанностями. 
А что произойдет, если рекламная акция завершится? Или изменится приз? Таким образом, речь идет о компромиссном 
решении, принятом на архитектурном уровне.
тестирование автомата
часто Задаваемые вопросы
Да! Здорово!
паттерн состояние
далее   435
Проверка разумности
Да, директору Mighty Gumball проверка разумности определенно не 
помешает, но сейчас мы говорим не об этом. Давайте припомним некоторые аспекты GumballMachine, которые не мешало бы доработать 
перед выдачей окончательной версии:
  Состояния SoldState и WinnerState содержат большой 
объем дублирующегося кода. Как избавиться от дублирования? Можно сделать State абстрактным классом 
и встроить в эти методы некое поведение по умолчанию; 
в конце концов, сообщения об ошибках не должны быть 
видны клиенту. Таким образом, обобщенное поведение 
обработки ошибок может наследоваться от абстрактного 
суперкласса.
  Метод dispense() вызывается всегда, даже если покупатель дернул за рычаг, не бросив монетку. Хотя автомат 
выдает шарик только в правильном состоянии, эта проблема легко решается возвращением логического флага 
из метода turnCrank() или обработкой исключений. Как 
вы думаете, какое решение лучше?
  Вся информация о переходах между состояниями хранится в классах состояний. Какие проблемы могут из-за этого возникнуть? Не переместить ли эту логику в Gumball 
Machine? Какими достоинствами и недостатками будет 
обладать такое решение?
  Если вы планируете создавать большое количество объектов GumballMachine, возможно, экземпляры состояний стоит переместить в статические переменные для 
совместного использования. Какие изменения придется 
внести в GumballMachine и классы состояний?
Я все-таки торговый автомат, а не компьютер!
Браво! Отличная работа. Наши 
продажи уже взлетели до небес. 
И знаете, мы также выпускаем 
автоматы для продажи содовой... 
Я подумал, что на них тоже можно 
установить рукоятку от «однорукого 
бандита» и переделать под игру. Зачем 
останавливаться на полпути?
436 глава 10
Воссоединение паттернов Стратегия 
и Состояние
Стратегия Состояние
Здорово, брат. Слыхал, про меня написали в главе 1?
Да, мне уже рассказывали.
А я тут просто помогал Шаблонному Методу закончить его главу. Как дела, чем занимаешься?
Да как обычно — помогаю классам проявлять разное поведение в зависимости от состояния. Право, не знаю... Мне всегда кажется, что ты 
просто копируешь то, что делаю я, но описываешь другими словами. Только подумай: я помогаю объектам внедрять разные варианты поведения или алгоритмы посредством композиции 
и делегирования. По сути, ты делаешь то же самое. Признаю, наши задачи определенно имеют немало общего, но мои намерения полностью отличаются от твоих. И мои клиенты учатся применять композицию и делегирование совершенно 
иным способом.
Да ну? Это как? Что-то я тебя не пойму. Если потратишь немного времени на размышления о чем-то, кроме себя самого, то поймешь. Подумай, как ты работаешь: есть класс, экземпляр 
которого ты создаешь; ты обычно передаешь ему 
объект стратегии, реализующий некоторое поведение. Помнишь, в главе 1 мы реализовали разные варианты кряканья? Настоящие утки крякали, а резиновые пищали. Да, это была классная работа... И ты наверняка 
видишь, что это более мощный механизм, чем 
наследование поведения?
Да, конечно. А теперь подумай, как работаю я; 
ничего похожего.
Извини, придется объяснить подробнее.
беседа у камина: состояние и стратегия
Беседа у камина
паттерн состояние
далее   437
Стратегия Состояние
При создании объектов контекста я могу задать 
их исходное состояние, но со временем они могут сами изменять свое состояние.
Что тут такого? Я тоже могу изменять поведение 
во время выполнения; для этого и нужна композиция!
Можешь, конечно, но моя работа построена на 
дискретных состояниях; мои объекты контекста изменяют состояние со временем в соответствии с четко определенными переходами. 
Иначе говоря, изменение поведения встроено 
в мою схему — я так работаю!
Признаю, я не заставляю свои объекты иметь 
четко определенный набор переходов между состояниями. Обычно я предпочитаю управлять 
тем, какую стратегию используют мои объекты.
Послушай, мы уже договорились, что у нас 
много общего в структуре, но задачи, решаемые с нашей помощью, заметно различаются. 
В мире найдется работа для нас обоих.
Да-да, мечтай, братец. Ты изображаешь из себя 
крутой паттерн вроде меня, но не забудь: меня 
описали в главе 1, а тебе нашлось место только 
в главе 10. Я хочу сказать — сколько людей дочитает книгу до этого места?
Шутишь? Это крутая книга для крутых читателей. Конечно, они дочитают до главы 10!
Узнаю своего брата. Мечтает, как всегда...
438 глава 10
Чуть не забыли!
Mighty Gumball, Inc.
Машина с жевательной 
резинкой не бывает 
полупустой
Шарик 
продан
Нет
монетки
Есть
монетка
Нет
шариков
Мы забыли включить в исходную спецификацию один переход... 
автомат, в котором кончились шарики, необходимо както заправить! Перед вами новая диаграмма. Сможете 
ли вы реализовать ее для нас? Вы так хорошо справились 
с программированием автомата, что, без сомнения, 
сможете моментально реализовать новую функцию!
 — Инженеры Mighty Gumball
бросить монетку
вернуть монетку дернуть за рычаг
выдать 
шарик
шарики = 0
шарики > 0
заполнить
упражнение по заправке
паттерн состояние
далее   439
Напишите метод refill() для заправки автомата. Метод получает один аргумент 
(количество шариков, загружаемых в автомат), обновляет переменную  — 
счетчик шариков и инициализирует текущее состояние автомата.
Вы отлично справились! У меня 
еще несколько идей, которые 
произведут революцию в сфере 
торговли жвачкой. Я хочу доверить 
вам их реализацию. Только тс-с-с, 
никому ни слова! Я все расскажу 
в следующей главе.
Возьми в руку карандаш
440 глава 10
Соедините каждый паттерн с его описанием:
Паттерн Описание
Состояние
Стратегия
Шаблонный Метод
Инкапсулирует взаимозаменяемые 
варианты поведения и выбирает 
один из них посредством делегирования
Субклассы выбирают реализацию шагов алгоритма
Инкапсулирует поведение, 
связанное с состоянием, с делегированием поведения объекту 
текущего состояния
кто и что делает?
Кто и что делает?
паттерн состояние
далее   441
Новые инструменты
Подошла к концу очередная глава. Известных вам 
паттернов вполне достаточно для того, чтобы 
с легкостью пройти любое собеседование при 
приеме на работу!
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Стратегия — определяет семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет модифицировать алгоритмы 
независимо от их использования на стороне клиента.
Паттерны
Наблюдатель — defines a 
one-to-many dependency 
between objects so that 
when one object changes 
state, all its dependents are 
notified and updated 
automatically
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a flexible 
alternative to subclassing for 
extending functionality.
Абстрактная Фабрика — Provide an interface for 
creating families of related 
or depedent objects without 
specifying their concrete 
classes.
Фабричный метод — 
Define an interface for 
creating an object, but let 
subclasses decide which class 
to instantiate. Factory 
Method lets a class 
defer instantiation to 
the subclasses.
Одиночка — гарантирует, 
что класс имеет только 
один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.
Command — Encapsulates a 
request as an object, thereby 
letting you parameterize 
clients with different requests, 
queue or log requests, and support undoable 
operations.
  Паттерн Состояние позволяет 
объекту иметь много разных вариантов поведения в зависимости от 
его внутреннего состояния.
  В отличие от процедурных конечных автоматов, состояние в этом 
паттерне представляется полноценным классом.
  Поведение контекста реализуется 
делегированием выполняемых 
операций текущему объекту 
состояния, с которым он связан 
посредством композиции.
  Инкапсуляция состояния в классе 
локализует его возможные изменения.
  Паттерны Состояние и Стратегия 
имеют похожие диаграммы классов, но решают разные задачи.
  Паттерн Стратегия обычно 
определяет в классе контекста 
поведение алгоритма.
  Паттерн Состояние изменяет поведение контекста в соответствии 
с изменениями его состояния.
  Переходами между состояниями 
могут управлять как классы состояний, так и классы контекстов.
  Применение паттерна Состояние 
обычно увеличивает количество 
классов в архитектуре.
  Классы состояний могут совместно использоваться несколькими 
экземплярами контекстов.
Адаптер — Encapsulates a 
request as an object, thereby 
letting you parameterize 
clients with different requests, 
queue or log requests, and support undoable 
operations.
В этой главе нет 
новых принципов — 
пользуйтесь случаем, 
чтобы покрепче 
запомнить старые.
Фасад — Encapsulates a 
request as an object, thereby 
letting you parameterize 
clients with different requests, 
queue or log requests, and 
support undoable 
operations.
Новый паттерн. 
Если вы управляете состоянием 
класса, паттерн 
предоставляет 
механизм инкапсуляции этого 
состояния.
Состояние — управляет изменением поведения объекта 
при изменении его внутреннего состояния. Внешне это 
выглядит так, словно объект 
меняет свой класс.
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты 
для расширения, но закрыты для 
изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Взаимодействуйте только 
с «друзьями».
Не вызывайте нас — мы вас 
сами вызовем.
Класс должен иметь только 
одну причину для изменений.
Принципы
КЛЮЧЕВЫЕ 
МОМЕНТЫ
442 глава 10
Ответы к упражнениям
Нет
шариков
Есть
монетка
Нет
монетки
бросить монетку
вернуть монетку дернуть за рычаг,
не повезло
Приз
дернуть за рычаг, 
повезло!
Mighty Gumball, Inc.
Машина с жевательной 
резинкой не бывает 
полупустой
Шарик
продан выдать
шарик
шарики = 0
шарики > 0
шарики = 0
шарики > 0
выдать 2 
шарика
ответы к упражнениям
паттерн состояние
далее   443
? A. Код не соответствует принципу 
открытости/закрытости.
? B. Такой стиль программирования 
характерен для FORTRAN.
? C. Архитектуру трудно назвать объектно-ориентированной.
? D. Переходы между состояниями не 
очевидны; они «прячутся» в множестве условных конструкций.
? E. Переменные аспекты этой архитектуры не инкапсулированы.
? F. Дальнейшие изменения с большой 
вероятностью приведут к ошибкам 
в готовом коде.
Какие из следующих утверждений относятся к нашей реализации? 
(Выберите все подходящие утверждения.)
Остался всего один нереализованный класс состояния: SoldOutState. Почему бы вам 
не реализовать его? Тщательно продумайте поведение автомата в каждой ситуации. 
Наше решение выглядит так:
В состоянии SoldOutState 
никакие действия 
невозможны, пока 
кто-то не заправит 
автомат шариками.
Возьми в руку карандаш
 Решение
Возьми в руку карандаш
 Решение
public class SoldOutState implements State {
 GumballMachine gumballMachine;
 public SoldOutState(GumballMachine gumballMachine) {
 this.gumballMachine = gumballMachine;
 }
 public void insertQuarter() {
 System.out.println("You can't insert a quarter, the machine is sold out");
 }
 public void ejectQuarter() {
 System.out.println("You can't eject, you haven't inserted a quarter yet");
 }
 public void turnCrank() {
 System.out.println("You turned, but there are no gumballs");
 }
 public void dispense() {
 System.out.println("No gumball dispensed");
 }
}
444 глава 10
Реализация состояний начинается с определения поведения классов при выполнении 
каждого действия. Заполните следующую диаграмму описаниями поведения каждого 
из классов; мы уже заполнили некоторые описания за вас.
Перейти в состояние HasQuarterState.
«Вы не бросили монетку».
«Подождать выдачи шарика».
«Вы уже дернули за рычаг».
«Даже если дернуть дважды, шарик все равно только один».
«Все шарики проданы».
«Вы еще не бросили монетку».
«Нельзя бросить вторую монетку».
«В автомате нет шариков».
Перейти в состояние SoldState.
Вернуть монетку и перейти в состояние NoQuarterState.
«Вы дернули за рычаг, но не бросили монетку».
NoQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
SoldOutState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
SoldState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
HasQuarterState
insertQuarter()
ejectQuarter()
turnCrank()
dispense()
«Нужно сначала заплатить».
«Шарик не выдан».
Выдать шарик. Проверить количество шариков; если > 0, 
перейти в NoQuarterState, в противном случае перейти 
в SoldOutState.
«Шарик не выдан».
«Подождите, шарик уже был выдан».
«Вы уже дернули за рычаг».
«Даже если дернуть дважды, шарик все равно только один».
WinnerState
insertQuarter()
ejectQuarter()
turnCrank()
Выдать два шарика. Проверить количество шариков; dispense()
если > 0, перейти в NoQuarterState, в противном случае 
перейти в SoldOutState.
ответы к упражнениям
Возьми в руку карандаш
 Решение
паттерн состояние
далее   445
SoldOut
GumballMachine
GumballMachine
Sold
GumballMachine
Sold
HasQuarter
NoQuarter
SoldOut
HasQuarter
NoQuarter
SoldOut
Sold
HasQuarter
NoQuarter
GumballMachine
Sold
HasQuarter
NoQuarter
SoldOut
Состояния автомата
Состояние автомата
Состояния автомата
Состояния автомата
1 2
3 4
текущее состояние
текущее состояние
текущее состояние
текущее состояние
За сценой.
Самостоятельное путешествие
insertQuarter()
insertQuarter()
делегирует 
текущему 
состоянию
turnCrank()
turnCrank()
делегирует
переходы в состояние 
HasQuarter
действие 
автомата
действие 
автомата
переходы 
в состояние 
Sold
dispense()
Чтобы выдать шарик, 
автомат вызывает 
внутренний метод 
dispense()...
...после чего переходит 
в состояние NoQuarter.
446 глава 10
Соедините каждый паттерн с его описанием:
Паттерн Описание
Состояние
Стратегия
Шаблонный Метод
Инкапсулирует взаимозаменяемые варианты поведения и выбирает один из них посредством 
делегирования
Субклассы выбирают реализацию шагов алгоритма
Инкапсулирует поведение, 
связанное с классами, с делегированием поведения объекту 
текущего состояния
Для заполнения автомата мы добавим в интерфейс State метод refill(), который должен быть 
реализован каждым классом, реализующим State. В любом состоянии, кроме SoldOutState, метод не делает ничего. В состоянии SoldOutState refill() переходит в состояние NoQuarterState. 
Мы также добавим в GumballMachine метод refill(), который увеличивает счетчик шариков, 
а затем вызывает метод refill() текущего состояния.
ответы к упражнениям
Возьми в руку карандаш
 Решение
public void refill() {
 gumballMachine.setState(gumballMachine.getNoQuarterState());
}
void refill(int count) {
 this.count += count;
 System.out.println("The gumball machine was just refilled; it's new count is: " + this.count);
 state.refill();
}
Этот метод добавляется 
в SoldOutState.
А этот метод добавляется 
в GumballMachine.
Кто и что делает?
решение
Когда-нибудь разыгрывали сценку «хороший полицейский, плохой полицейский»? Вы «хороший полицейский», вы общаетесь со всеми 
любезно и по-дружески, но не хотите, чтобы все обращались к вам по каждому 
пустяку. Поэтому вы обзаводитесь «плохим полицейским», который управляет 
доступом к вам. Именно этим и занимаются заместители: они управляют доступом. Как вы вскоре увидите, существует множество способов взаимодействия 
заместителей с обслуживаемыми объектами. Иногда заместители пересылают 
по интернету целые вызовы методов, а иногда просто терпеливо стоят на месте, 
изображая временно отсутствующие объекты. 
Управление
 доступом к объектам
11 Паттерн Заместитель
С таким заместителем 
я смогу отнимать у своих 
друзей втрое больше 
карманных денег!
448 глава 11
Вроде бы задача не из сложных. Если помните, 
в коде автомата уже имеются методы для получения количества шариков (getCount()) и текущего 
состояния автомата (getState()).
Остается лишь построить отчет и отослать его директору. И вероятно, для каждого автомата стоит 
добавить поле с описанием его местонахождения, 
чтобы было понятно, к какому автомату относится 
отчет.
Можно браться за программирование. Моментальное исполнение задачи произведет впечатление на заказчика.
Еще не забыли 
директора Mighty 
Gumball?
для чего это нужно
Привет, коллеги, мне нужно 
улучшить систему мониторинга 
наших автоматов. Как мне 
получить отчет о наличии шариков 
и состоянии автомата?
паттерн заместитель
дальше   449
public class GumballMonitor {
 GumballMachine machine;
 public GumballMonitor(GumballMachine machine) {
 this.machine = machine;
 }
 public void report() {
 System.out.println("Gumball Machine: " + machine.getLocation());
 System.out.println("Current inventory: " + machine.getCount() + " gumballs");
 System.out.println("Current state: " + machine.getState());
 }
}
Программирование монитора
Новый класс GumballMonitor получает местонахождение автомата, 
количество оставшихся шариков и текущее состояние и выводит данные в виде небольшого аккуратного отчета:
Конструктор получает объект 
автомата и сохраняет его в переменной экземпляра machine.
Метод report() выводит отчет с
мацией о местонахождении, количестве 
инфоршариков и состоянии машины.
Начнем с добавления поля местонахождения в класс 
GumballMachine:
public class GumballMachine {
 // Другие переменные
 String location;
 public GumballMachine(String location, int count) {
 // Код конструктора
 this.location = location;
 }
 public String getLocation() {
 return location;
 }
 // Другие методы
}
Обычная переменная типа String.
Местонахождение передается конструктору и сохраняется в переменной экземпляра.
Также добавляем get-метод 
для получения строки 
местонахождения.
450 глава 11
public class GumballMachineTestDrive {
 public static void main(String[] args) {
 int count = 0;
 if (args.length < 2) {
 System.out.println("GumballMachine <name> <inventory>");
 System.exit(1);
 }
 count = Integer.parseInt(args[1]);
 GumballMachine gumballMachine = new GumballMachine(args[0], count);
 GumballMonitor monitor = new GumballMonitor(gumballMachine);
 // Остальной код
 monitor.report();
 }
}
Тестирование монитора
Задача решена за считаные минуты. Заказчик будет поражен нашим мастерством разработки.
Теперь необходимо создать экземпляр GumballMonitor и указать автомат для наблюдения:
Передаем параметры 
конструктору...
Создание монитора с указанием 
автомата, для которого строится 
отчет.
А вот и результат!
Чтобы получить отчет 
для автомата, вызываем 
метод report().
Местонахождение и исходное количество шариков передаются в командной строке.
File Edit Window Help FlyingFish
%java GumballMachineTestDrive Seattle 112
Gumball Machine: Seattle
Current Inventory: 112 gumballs
Current State: waiting for quarter
локальный монитор
Классный отчет... Но, видимо, 
я недостаточно ясно объяснил 
задачу. Данные об автоматах должны 
передаваться ПО СЕТИ! Все коммуникации 
уже проложены. Не забывайте, что мы 
живем в эпоху интернета!
паттерн заместитель
дальше   451
Фрэнк
Джим
Джо
Фрэнк: Удаленный кто?
Джо: Удаленный заместитель. Подумайте: код монитора уже написан, верно? Мы передаем объекту 
GumballMonitor ссылку на автомат, а он выдает нам отчет. Проблема в том, что монитор работает 
в одной JVM-машине с объектом автомата, а заказчик хочет сидеть за столом и получать данные об автоматах в удаленном режиме! А если мы оставим класс GumballMonitor в прежнем виде, но передадим 
ему заместитель удаленного объекта?
Фрэнк: Что-то я не до конца понял.
Джим: Я тоже.
Джо: Начнем с начала... Заместитель — суррогат настоящего объекта. В данном случае заместитель ведет себя как объект GumballMachine, а «за кулисами» взаимодействует по Сети с настоящим удаленным объектом GumballMachine.
Джим: То есть наш код остается без изменений, а монитору мы передаем ссылку на заместителя 
GumballMachine...
Фрэнк: И этот заместитель прикидывается настоящим объектом, а на самом деле он просто взаимодействует с ним по Сети.
Джо: Да, примерно так.
Фрэнк: Однако сказать легче, чем сделать.
Джо: Возможно, но вряд ли у нас возникнут сложности. Нужно позаботиться о том, чтобы автомат 
работал как сетевая служба и принимал запросы по сети; также необходимо реализовать для монитора 
механизм получения ссылки на объект-заместитель. К счастью, в Java уже имеются отличные встроенные средства для решения подобных задач. Но сначала давайте еще немного поговорим об удаленных 
заместителях...
Это нам 
урок: сначала собрать 
требования, а потом садиться 
за программирование. Надеюсь, 
нам не придется начинать все 
заново...
Спокойно, ребята, 
паттерны не подведут. Все, 
что нам нужно, — это удаленный 
заместитель, который решит все 
наши проблемы.
452 глава 11
Удаленный заместитель действует как локальный представитель удаленного объекта. Что такое «удаленный объект»? Это объект, находящийся в куче другой виртуальной машины Java (или в более общем 
значении — удаленный объект, выполняемый в другом адресном пространстве). Что такое «локальный представитель»? Это объект, вызовы локальных методов которого перенаправляются удаленному 
объекту.
Роль «удаленного заместителя»
Клиентский объект работает так, словно он вызывает методы 
удаленного объекта. Но в действительности он вызывает 
методы объекта-заместителя, существующего в локальной 
куче, который берет на себя все низкоуровневые подробности 
сетевых взаимодействий.
GumballMachine
Удаленная куча
GumballMonitor
Локальная куча
Proxy
Клиентский объект 
GumballMonitor полагает, что он взаимодействует с настоящим объектом 
GumballMachine. На 
самом деле он взаимодействует с заместителем, который, 
в свою очередь, общается с Настоящим 
Объектом по Сети.
Заместитель выдает 
себя за удаленный объект, 
но он лишь подменяет 
«оригинал».
«Настоящий» Объект содержит метод, который выполняет фактическую работу.
Компьютер заказчика.
Торговый автомат 
с JVM.
Как в старой версии, 
но взаимодействует 
с заместителем.
удаленный заместитель
Клиентский объект – объект, 
использующий посредника (в нашем 
случае GumballMonitor).
паттерн заместитель
дальше   453
Прежде чем двигаться дальше, подумайте, как бы вы спроектировали систему вызова 
удаленных методов (RMI). Как упростить задачу для разработчика, чтобы ему пришлось 
писать по возможности небольшой объем кода? Как обеспечить органичную интеграцию 
удаленных вызовов?
Должны ли удаленные вызовы быть полностью прозрачными для клиента? Какие проблемы могут возникнуть при таком подходе?
2
Мозговой
штурм
Мозговой
штурм
Весьма элегантное решение. Мы пишем 
код, который получает вызов метода, каким-то 
образом передает его по сети и вызывает такой 
же метод удаленного объекта. Когда обработка вызова 
будет завершена, результат снова передается по сети 
клиенту. Но мне кажется, что написать такой код 
будет очень сложно.
Спокойно, 
нам не придется писать его 
самим — по сути, этот код встроен 
в функциональность удаленного вызова 
Java. Мы должны лишь переделать 
свой код, чтобы в нем использовался 
механизм RMI.
454 глава 11
Включение удаленного заместителя в код мониторинга GumballMachine
На бумаге все смотрится хорошо, но как создать заместитель, который умеет вызывать 
методы объекта из другого экземпляра JVM?
Хмм... Ведь мы же не можем получить ссылку на объект из другой кучи, верно? Иначе 
говоря, нельзя использовать конструкции вида
 Duck d = <объект из другой кучи>
Объект, на который ссылается переменная d, должен находиться в пространстве той 
же кучи, что и код, выполняющий команду. Как подойти к решению этой задачи? На помощь приходит механизм Java RMI (Remote Method Invocation). Он позволяет получать 
доступ к объектам в удаленных JVM и вызывать их методы.
Сейчас самое время освежить в памяти тему RMI по вашему любимому учебнику Java. 
Также можно почитать краткий курс RMI на нескольких ближайших страницах, где 
мы кратко представим основные принципы RMI, прежде чем добавлять поддержку посредников в код GumballMachine.
В любом случае план выглядит так:
RMI-тур
Если вы еще не работали 
с RMI, краткое описание на 
нескольких страницах введет 
вас в курс дела. А если 
работали — хотя бы бегло 
пролистайте их и вспомните 
основные моменты. Если 
вы предпочитаете читать 
дальше, имея самое общее 
представление об удаленном 
посреднике, это тоже 
нормально — отклонение 
от темы можно пропустить.
1
2
3
Сначала мы познакомимся с механизмом 
RMI в общих чертах. Даже если вы уже разбираетесь в этой теме, будет полезно освежить информацию в памяти.
Затем код GumballMachine будет преобразован в удаленную службу с набором методов, 
вызываемых по Сети.
После этого мы создадим заместитель, который взаимодействует с удаленным объектом GumballMachine средствами RMI, 
и построим новый вариант системы сбора 
данных, чтобы заказчик мог наблюдать за 
любым количеством торговых автоматов.
введение в RMI
паттерн заместитель
дальше   455
Допустим, вы проектируете систему, в которой обращенные к локальному объекту вызовы 
перенаправляются удаленному объекту. Как бы вы подошли к ее проектированию? Вероятно, 
будет создана пара вспомогательных объектов, которые будут выполнять обмен данными за 
вас. Эти вспомогательные объекты позволят клиенту действовать так, словно он вызывает метод не удаленного, а локального объекта (что, собственно, и происходит), а локальный объект 
перенаправляет запрос реальному поставщику сервиса.
Иначе говоря, клиентский объект считает, что он вызывает метод удаленной службы, потому 
что вспомогательный объект (далее для краткости — помощник) изображает объект сетевой 
службы, то есть «притворяется», что у него есть метод, который хочет вызывать клиент.
Однако клиентский помощник не является удаленной службой. Он предоставляет метод, но 
не содержит фактической логики, необходимой клиенту. Вместо этого помощник связывается 
с сервером, передает информацию о вызове (имя метода, аргументы и т. д.) и ждет ответа от 
сервера.
На стороне сервера другой помощник получает запрос от клиентского объекта (через сокет), 
распаковывает информацию о вызове и вызывает реальный метод реального объекта службы. 
Таким образом, для объекта службы вызов является локальным. Он поступает от помощника 
на стороне сервера, а не от удаленного клиента.
Серверный помощник получает возвращаемое значение от службы, упаковывает его и передает обратно (через выходной поток сокета) клиентскому помощнику. Последний распаковывает информацию и возвращает значение клиентскому объекту.
Давайте посмотрим, как это происходит, чтобы стало понятнее.
Как работает архитектура
RMI-тур
Объект службы
Куча на стороне сервера
Клиентский объе
кт
Куча на стороне клиента
Клиентский помощник
Серверный помощник
Клиентский объект 
полагает, что он 
взаимодействует 
с сетевой службой. 
С его точки зрения 
клиентский помощник выполняет всю 
настоящую работу.
Клиентский помощник выдает себя за объект службы, 
но он лишь подменяет 
«оригинал».
Серверный помощник получает 
запрос от клиентского помощни
ка, распаковывает его и
-
вызывает 
метод «настоящей» службы.
«Настоящий» объект службы содержит 
метод, который выполняет фактическую 
работу.
Рассмотрим следующую 
архитектуру…
Заместитель
RMI: краткий курс
456 глава 11
Объект службы
Куча на стороне сервера
Клиентский объе
кт
Куча на стороне клиента
Клиентский пом
ощник
Серверный помощник
Как происходит вызов метода
1 Клиентский объект вызывает метод doBigThing() клиентского помощника.
Объект службы
Куча на стороне сервера
Клиентский объект
Куча на стороне клиента
Клиентский пом
ощник
Серверный помо
щник
2 Клиентский помощник упаковывает информацию о вызове (аргументы, имя метода и т. д.) 
и передает ее по сети серверному помощнику.
doBigThing()
doBigThing()
«клиент хочет вызвать метод»
Объект службы
Куча на стороне сервера
Клиентский объект
Куча на стороне клиента
Клиентский пом
ощник
Серверный помощни
к
3 Серверный помощник распаковывает полученную информацию, определяет, какой метод 
(и какого объекта) следует вызвать, и вызывает настоящий метод настоящего объекта службы.
doBigThing() doBigThing() Напоминаем: это объект с ФАКТИЧЕСКОЙ 
логикой метода! Тот, 
который выполняет 
реальную работу!
вызов удаленного метода
«клиент хочет вызвать метод»
паттерн заместитель
дальше   457
Объект службы
Куча на стороне сервера
Клиентский объе
кт
Куча на стороне клиента
Серверный помощн
ик
4 Вызванный метод объекта службы возвращает результат серверному помощнику.
Объект службы
Куча на стороне сервера
Клиентский объект
Куча на стороне клиента
Клиентский помо
щни
к
Серверный пом
ощник
5 Серверный помощник упаковывает информацию, полученную в результате вызова, 
и возвращает ее по сети вспомогательному объекту на стороне клиента.
упакованный результат
Объект службы
Куча на стороне сервера
Клиентский объе
кт
Клиентский помощник
Серверный пом
ощник
6 Клиентский помощник распаковывает данные и возвращает их клиентскому объекту. Все 
происходящее полностью прозрачно с точки зрения клиентского объекта.
результат
результат
RMI-тур
Куча на стороне клиента
Клиентский помощник
458 глава 11
Итак, вы примерно представляете, как вызываются удаленные методы; теперь остается понять, 
как использовать RMI. 
RMI генерирует помощников на стороне клиента и сервера — вплоть до создания клиентского 
помощника с таким же набором методов, как у 
удаленной службы. При этом вам не приходится 
писать код передачи данных по Сети или ввода 
данных самостоятельно. Вы просто вызываете 
удаленные методы точно так же, как вызываете 
обычные методы объектов, выполняемых в локальной JVM клиента. 
RMI также предоставляет всю инфраструктуру, 
обеспечивающую функционирование этого механизма (включая сервис поиска и обращения 
к удаленным объектам).
Между вызовами RMI и обычными (локальными) вызовами существует одно важное различие. 
Хотя с точки зрения клиента вызов метода ничем не отличается от локального, клиентский 
помощник передает вызов метода по Сети. В передаче данных задействована передача данных 
по Сети и операции ввода/вывода. А что мы 
о них знаем?
Они небезопасны! Они могут завершиться неудачей! Они могут генерировать исключения. 
В результате клиент должен быть готов к неожиданностям. Через пару страниц вы увидите, в чем 
именно заключается подготовка.
Java RMI: общая картина
Объект службы
Клиентский объектКлиентский помощник
Серверный помощ
н
и
к
Куча на стороне 
сервера
Заглушка RMI Скелет RMI
В терминологии RMI клиентский помощник называется «заглушкой» 
(stub), а серверный помощник — «скелетом» (skeleton).
Заместитель в нашей схеме!
А теперь давайте рассмотрим все действия, которые необходимы 
для превращения объекта в службу, принимающую удаленные вызовы (а также для выполнения удаленных вызовов на стороне клиента).
Пристегните ремни. Процесс состоит из нескольких шагов, но беспокоиться не о чем.
RMI: общая картина
Новые версии Java 
не требуют явного 
создания скелета — 
какие-то компоненты на стороне 
сервера обеспечивают необходимое 
поведение.
Куча на стороне 
клиента
RMI-тур
паттерн заместитель
дальше   459
RMI-тур
Создание удаленной службы
MyService.java
public interface 
MyRemote extends 
Remote { }
MyServiceImpl.java
public MyRemoteImpl 
extends 
UnicastRemoteObject 
implements 
MyRemote { }
Далее приводится краткий обзор пяти шагов построения удаленной службы — другими словами, шагов, необходимых для того, чтобы взять обычный объект и наделить его способностью обслуживать 
вызовы удаленных клиентов. Позднее мы сделаем это с классом GumballMachine, а пока рассмотрим 
общую последовательность действий (подробные объяснения будут приведены позднее).
Создание интерфейса удаленного доступа.
Интерфейс удаленного доступа определяет 
методы, вызываемые клиентом в удаленном 
режиме. Именно он будет указываться клиентом в качестве типа вашей службы. Реализуется как заглушкой, так и самой службой!
Интерфейс определяет 
удаленные методы, которые будут вызываться 
клиентами.
Создание реализации интерфейса удаленного доступа. Речь идет о классе, выполняющем настоящую работу. Он определяет 
фактическую реализацию методов, определенных в интерфейсе удаленного доступа, 
и это его методы вызываются клиентом.
«Настоящая» служба; класс с методами, выполняющими фактическую работу. Реализует интерфейс удаленного доступа.
File Edit Window Help Drink
%rmiregistry
File Edit Window Help BeMerry
%java MyServiceImpl
Запуск rmiregistry. Клиент обращается к реестру RMI (rmiregistry) для получения заместителя (клиентской заглушки/объекта-помощника).
Запуск удаленной службы. Наконец, необходимо запустить объект удаленной службы. 
Класс реализации службы создает экземпляр 
службы и регистрирует его в реестре RMI. 
Зарегистрированная служба становится доступной для клиентов.
Запускается 
в отдельном 
терминале.
Шаг 1
Шаг 2
Шаг 3
Шаг 4
Заглушка и Скелет динамически генерируются за вас.
Заглушка
Скелет
460 глава 11
Шаг 1: создание интерфейса удаленного 
доступа
1 Расширение java.rmi.Remote
Интерфейс Remote не содержит методов. Тем не менее он имеет особый смысл для RMI, 
поэтому это правило необходимо выполнить. Обратите внимание на термин «расширение» — один интерфейс может расширять другой интерфейс.
public interface MyRemote extends Remote {
2 Объявление возможного исключения RemoteException
Интерфейс удаленного доступа используется клиентом в качестве типа службы. Иначе 
говоря, клиент вызывает методы чего-то, реализующего интерфейс удаленного доступа. Конечно, этим «чем-то» является заглушка, а при выполнении передачи данных по 
Сети и операций ввода/вывода возможны разные неприятности. Клиент должен подтвердить этот риск, обрабатывая или объявляя исключения удаленного доступа. Если 
методы интерфейса объявляют исключения, то эти исключения должны обрабатываться или объявляться всем кодом, вызывающим методы для ссылок интерфейсного типа.
import java.rmi.*;
public interface MyRemote extends Remote {
 public String sayHello() throws RemoteException;
}
3 Аргументы и возвращаемые значения должны быть примитивами или Serializable
Аргументы и возвращаемые значения удаленного метода должны быть либо примитивными типами, либо Serializable. И это логично: аргументы удаленного метода необходимо упаковать и передать по Сети, а это делается посредством сериализации. То же 
происходит и с возвращаемыми значениями. При использовании примитивов, String и 
большинства типов API (включая массивы и коллекции) все будет нормально. Если вы 
передаете пользовательские типы, проследите за тем, чтобы ваши классы реализовали 
интерфейс Serializable.
public String sayHello() throws RemoteException;
Означает, что интерфейс 
будет использоваться для 
поддержки удаленных вызовов.
Вызовы удаленных 
методов считаются «рискованными». Объявление 
RemoteException в каждом методе обращает 
внимание клиента на 
то, что вызов может 
не сработать.
Возвращаемое значение будет передаваться по каналу связи от сервера 
к клиенту, поэтому оно должно поддерживать сериализацию.
Интерфейс удаленного доступа в java.rmi
создание интерфейса удаленного доступа
паттерн заместитель
дальше   461
Шаг 2: создание реализации интерфейса 
удаленного доступа
2 Расширение UnicastRemoteObject
Для работы в качестве удаленной службы ваш объект должен обладать некоторой стандартной 
функциональностью. Для включения этой функциональности проще всего расширить класс 
UnicastRemoteObject (из пакета java.rmi.server), чтобы этот (супер)класс выполнил всю работу 
за вас.
public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
 private static final long serialVersionUID = 1L;
3 Определение конструктора без аргументов, объявляющего RemoteException
У нового суперкласса UnicastRemoteObject имеется одна проблема — его конструктор может 
инициировать исключение RemoteException. Единственное решение заключается в объявлении конструктора вашей удаленной реализации, чтобы у вас появилось место для объявления 
RemoteException. Вспомните, что при создании экземпляра класса всегда вызывается конструктор его суперкласса. И если конструктор суперкласса инициирует исключение, у вас нет другой 
возможности, кроме объявления исключения в своем конструкторе.
public MyRemoteImpl() throws RemoteException { }
4 Регистрация службы в реестре RMI
Чтобы созданная служба стала доступной для удаленных клиентов, следует создать ее экземпляр 
и поместить его в реестр RMI (который должен работать в системе; в противном случае выполнение этой строки кода завершится неудачей). При регистрации объекта реализации система 
RMI помещает в реестр заглушку, потому что клиент взаимодействует именно с ней. Регистрация 
службы осуществляется статическим методом rebind() класса java.rmi.Naming.
try {
 MyRemote service = new MyRemoteImpl();
 Naming.rebind("RemoteHello", service);
} catch(Exception ex) {...} 
1 Реализация интерфейса удаленного доступа
Служба должна реализовать интерфейс удаленного доступа — интерфейс, методы которого будут 
вызываться клиентом.
public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
 public String sayHello() {
 return "Server says, ‘Hey’";
 }
 // Код класса
}
Компилятор проследит за тем, чтобы 
вы реализовали все методы интерфейса. 
В данном случае метод только один.
Размещать код в конструкторе 
не нужно. Это всего лишь способ 
объявить, что конструктор суперкласса инициирует исключение.
Присвойте своей службе имя (чтобы 
клиенты могли искать ее в реестре) 
и зарегистрируйте ее в реестре RMI. 
Система RMI помещает в реестр 
информацию о заглушке.
RMI-тур
UnicastRemoteObject реализует интерфейс Serializable, 
поэтому понадобится поле serialVersionUID.
462 глава 11
Шаг 3: запуск rmiregistry
Шаг 4: запуск службы
1 Откройте другой терминал и запустите службу
Запуск может осуществляться из метода main() 
в классе реализации или из отдельного стартового класса. В этом простом примере код запуска 
размещается в классе реализации — в методе main, 
который создает экземпляр объекта и регистрирует его в реестре RMI.
File Edit Window Help Huh?
%java MyRemoteImpl
запуск службы
1 Откройте терминал и запустите rmiregistry 
Не забудьте выполнить команду из каталога, имеющего доступ к вашим классам. Проще всего сделать это из каталога classes.
File Edit Window Help Huh?
%rmiregistry
часто Задаваемые вопросы
В: А почему вы показываете заглушки и скелеты на диаграммах для кода RMI? Я думал, что они 
уже давно остались в прошлом.
О: Вы правы. Для заготовок исполнительная среда RMI может передавать клиентские вызовы удаленной службе напрямую, используя отражение, а заглушки генерируются динамически с использованием динамических посредников (о которых вы узнаете чуть позднее в этой главе). Заглушка удаленного объекта представляет собой экземпляр java.lang.reflect.Proxy, который автоматически генерируется 
для обработки всех подробностей доставки локальных вызовов клиента к удаленному объекту. Но мы 
решили показать как заглушку, так и скелет, потому что на концептуальном уровне полезно понимать, 
что «за кулисами» есть нечто, обеспечивающее взаимодействия между клиентской заглушкой и удаленной службой.
RMI-тур
паттерн заместитель
дальше   463
Полный код серверной части
import java.rmi.*;
import java.rmi.server.*;
public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
 private static final long serialVersionUID = 1L; 
 public String sayHello() {
 return "Server says, ‘Hey’";
 }
 public MyRemoteImpl() throws RemoteException { }
 public static void main (String[] args) {
 try {
 MyRemote service = new MyRemoteImpl();
 Naming.rebind("RemoteHello", service);
 } catch(Exception ex) {
 ex.printStackTrace();
 }
 }
}
import java.rmi.*;
public interface MyRemote extends Remote {
 public String sayHello() throws RemoteException;
}
RemoteException и интерфейс Remote 
находятся в пакете java.rmi.
Интерфейс ДОЛЖЕН расширять java.rmi.Remote.
Все удаленные методы должны 
объявлять RemoteException.
UnicastRemoteObject находится в пакете 
java.rmi.server.
Посмотрим, как выглядит код на стороне сервера.
Интерфейс удаленного доступа:
Удаленная служба (реализация):
Расширение UnicastRemoteObject — простейший способ создания объекта с поддержкой 
удаленного доступа.
Вы ОБЯЗАНЫ реализовать интерфейс удаленного доступа! 
Конечно, все методы интерфейса должны быть реализованы, 
но объявлять RemoteException 
НЕ ОБЯЗАТЕЛЬНО.
Конструктор суперкласса (UnicastRemoteObject) объявляет исключение, поэтому вы должны определить конструктор как признак вызова небезопасного 
кода (конструктора суперкласса).
Создайте удаленный объект и зарегистрируйте его в реестре RMI статическим вызовом Naming.rebind(). Регистрируемое имя 
будет использоваться клиентами
для поиска объекта в реестре.
RMI-тур
464 глава 11
MyRemote service = 
 (MyRemote) Naming.lookup("rmi://127.0.0.1/RemoteHello");
Клиент всегда указывает 
в качестве типа службы тип 
интерфейса удаленного доступа. 
Ему вообще не обязательно знать 
фактическое имя класса удаленной 
службы.
Необходимо преобразование 
к типу интерфейса, поскольку 
по запросу возвращается 
тип Object.
lookup() — статический 
метод класса Naming.
Имя или IP-адрес хоста, 
на котором работает служба 
(127.0.0.1 соответствует 
localhost).
Имя, под которым была 
зарегистрирована служба.
А вот как работает 
эта схема...
как получить объект заглушки
Код под увеличительным стеклом
Здесь-то и приходит на помощь реестр RMI. 
Да, вы правы; клиент должен получить объект заглушки (нашего посредника), потому что 
именно к нему клиент будет обращаться за вызовами методов. Для этого клиент выполняет 
«поиск» (вроде поиска по телефонному справочнику) и, по сути, говорит: «Вот имя, я хочу 
получить заглушку для этого имени». 
Как клиент получает объект 
заглушки?
RMI-тур
паттерн заместитель
дальше   465
Объект службы
Клиентский объ
ект
Заглушка
Скелет
Сервер Клиент
Заглушка
Реестр RMI (на сервере)
1 Клиент обращается с запросом к реестру RMI
2 Реестр RMI возвращает объект заглушки
(как возвращаемое значение метода lookup), а RMI 
автоматически десериализует его. 
3 Клиент вызывает метод заглушки,
словно метод НАСТОЯЩЕЙ службы.
1
2
3
Naming.lookup("rmi://127.0.0.1/RemoteHello");
lookup( )
получение 
заглушки
sayHello( )
Как работает эта схема...
RMI-тур
Удаленная
служба Hello
466 глава 11
КОНЕЦ
ТУРА
import java.rmi.*;
public class MyRemoteClient {
 public static void main (String[] args) {
 new MyRemoteClient().go();
 }
 public void go() {
 try {
 MyRemote service = (MyRemote) Naming.lookup("rmi://127.0.0.1/RemoteHello");
 String s = service.sayHello(); 
 System.out.println(s);
 } catch(Exception ex) {
 ex.printStackTrace();
 }
 }
}
Полный клиентский код
Класс Naming (для поиска в реестре 
RMI) находится в пакете java.rmi.
Возвращается из реестра в виде 
типа Object — не забудьте 
выполнить преобразование.
IP=адрес или имя 
хоста...
...и имя, использованное 
для идентификации 
службы.
Выглядит как обычный 
вызов метода! (Кроме 
подтверждения возможности 
RemoteException).
код клиента
Типичные ошибки, 
которые совершаются 
программистами при 
работе с RMI:
1. Программа rmiregistry не запускается перед 
запуском удаленной службы (в момент регистрации службы вызовом Naming.rebind() 
программа rmiregistry должна работать 
в системе!).
2. Типы аргументов и возвращаемых значений 
не сериализуются (вы не узнаете об этом 
до момента выполнения; такие ошибки 
компилятором не обнаруживаются).
 Будьте осторожны!
Ниже приведен полный клиентский код.
RMI-тур
паттерн заместитель
дальше   467
GumballMachine
GumballMonitor
GumballStub
GumballSkeleton
Код Monitor использует заместитель для 
взаимодействия с удаленными автоматами.
Заглушка — 
заместитель для 
удаленного объекта 
GumballMachine.
Скелет принимает удаленные вызовы 
и делает все необходимое на стороне 
сервера.
GumballMachine —
удаленная служба 
в нашей схеме; объект предоставляет 
интерфейс удаленного 
доступа для использования клиентами.
Возвращаемся к удаленному заместителю GumballMachine
Итак, после знакомства с основами RMI мы располагаем всем необходимым для реализации удаленного заместителя GumballMachine. Давайте 
посмотрим, как удаленный сбор данных о торговых автоматах вписывается в уже известную нам инфраструктуру:
Компьютер
заказчика
Торговый автомат с JVM.
Куча на стороне 
сервера
Куча на стороне 
клиента
Остановитесь и подумайте, как адаптировать код автомата для работы с удаленным посредником. Отметьте, что потребуется изменить и чем новая версия будет 
отличаться от старой.
Мозговой
штурм
468 глава 11
интерфейс удаленного доступа
Преобразование GumballMachine в удаленную службу
Преобразование кода начинается со включения обслуживания удаленных запросов от клиентов 
в классе GumballMachine. Иначе говоря, класс GumballMachine превращается в сетевую службу. 
Для этого необходимо следующее:
1. Создать интерфейс удаленного доступа для GumballMachine. Интерфейс
предоставляет набор методов, вызываемых в удаленном режиме. 
2. Убедиться в том, что все возвращаемые типы интерфейса сериализуемы.
3. Реализовать интерфейс в конкретном классе.
Начнем с интерфейса удаленного доступа:
import java.rmi.*;
public interface GumballMachineRemote extends Remote {
 public int getCount() throws RemoteException;
 public String getLocation() throws RemoteException;
 public State getState() throws RemoteException;
}
Интерфейс удаленного 
доступа
Не забудьте импортировать 
java.rmi.* 
Методы, которые будут 
поддерживаться службой. Каждый 
метод может инициировать 
RemoteException.
Все возвращаемые 
типы должны быть 
примитивными или 
Serializable...
Один из возвращаемых типов не поддерживает Serializable: это класс State. Исправляем...
import java.io.*;
 
public interface State extends Serializable {
 public void insertQuarter();
 public void ejectQuarter();
 public void turnCrank();
 public void dispense();
}
Serializable находится
в пакете java.io.
Просто расширяем интерфейс 
Serializable interface (который не 
содержит методов) — и теперь 
объект State во всех субклассах 
может передаваться по Сети.
паттерн заместитель
дальше   469
Осталось решить еще одну проблему с сериализацией. Как вы, вероятно, помните, каждый объект 
State хранит ссылку на объект GumballMachine для вызова методов и изменения его состояния. Мы 
не хотим, чтобы вместе с объектом State сериализовался и передавался весь объект GumballMachine. 
Проблема решается просто:
public class NoQuarterState implements State {
 private static final long serialVersionUID = 2L;
 transient GumballMachine gumballMachine;
 // Другие методы
}
В каждой реализации State переменная экземпляра GumballMachine 
помечается ключевым словом 
transient. Оно сообщает JVM, 
что это поле не сериализуется.
Класс GumballMachine уже реализован, но мы должны обеспечить его работу в режиме службы и обработку запросов, поступающих по Сети. Для этого класс GumballMachine должет сделать все необходимое для реализации интерфейса GumballMachineRemote. 
Как было показано ранее, это достаточно просто, нужно лишь добавить пару полей...
import java.rmi.*;
import java.rmi.server.*;
public class GumballMachine
 extends UnicastRemoteObject implements GumballMachineRemote 
{
 private static final long serialVersionUID = 2L;
 // Переменные
 public GumballMachine(String location, int numberGumballs) throws RemoteException {
 // Код
 }
 public int getCount() {
 return count;
 }
 public State getState() {
 return state;
 }
 public String getLocation() {
 return location;
 }
 
 // Другие методы
}
Необходимо импортировать пакеты rmi. Класс GumballMachine 
будет субклассировать 
UnicastRemoteObject; это 
позволяет ему работать 
в режиме удаленной службы. GumballMachine также должен 
реализовать интерфейс 
удаленного доступа...
...и конструктор должен 
объявить исключение, 
потому что оно 
объявлено в суперклассе. А здесь ничего 
не изменяется!
470 глава 11
регистрация в реестре RMI
public class GumballMachineTestDrive {
 public static void main(String[] args) {
 GumballMachineRemote gumballMachine = null;
 int count;
 if (args.length < 2) {
 System.out.println("GumballMachine <name> <inventory>");
 System.exit(1);
 }
 try {
 count = Integer.parseInt(args[1]);
 gumballMachine = new GumballMachine(args[0], count);
 Naming.rebind("//" + args[0] + "/gumballmachine", gumballMachine);
 } catch (Exception e) {
 e.printStackTrace();
 }
 }
}
File Edit Window Help Huh?
% rmiregistry
Регистрация в реестре RMI...
Код службы готов. Теперь нужно запустить его, чтобы он мог принимать запросы. 
Служба регистрируется в реестре RMI, чтобы клиенты могли получить доступ к ней.
В тестовую программу включается небольшой фрагмент кода:
Создание экземпляра заключено 
в блок try/catch, потому что конструктор может инициировать 
исключения.
Также добавляем вызов Naming.rebind, который публикует заглушку GumballMachine под 
именем gumballmachine.
Остается выполнить пару команд...
File Edit Window Help Huh?
% java GumballMachineTestDrive seattle.mightygumball.com 100
Сначала выполняется 
эта команда.
Затем выполняется 
эта команда.
Запуск службы 
реестра RMI.
Служба GumballMachine запущена 
и зарегистрирована в реестре RMI.
Замените именем 
своего компьютера.
паттерн заместитель
дальше   471
А теперь клиент GumballMonitor...
Еще не забыли класс GumballMonitor? Мы хотели использовать его для работы по Сети, но по возможности обойтись 
без переписывания кода. Именно это мы сейчас и сделаем, 
хотя несколько изменений внести все же придется.
import java.rmi.*;
public class GumballMonitor {
 GumballMachineRemote machine;
 public GumballMonitor(GumballMachineRemote machine) {
 this.machine = machine;
 }
 public void report() {
 try {
 System.out.println("Gumball Machine: " + machine.getLocation());
 System.out.println("Current inventory: " + machine.getCount() + " gumballs");
 System.out.println("Current state: " + machine.getState());
 } catch (RemoteException e) {
 e.printStackTrace();
 }
 }
} Также необходимо перехватывать все исключения, возможные при вызове методов, которые фактически выполняются по Сети.
В дальнейшем мы будем работать 
с реализацией интерфейса удаленного 
доступа, а не с конкретным классом 
GumballMachine.
Необходимо импортировать пакет RMI, потому что 
ниже используется класс RemoteException...
Джо был прав; 
наша схема отлично 
работает!
472 глава 11
тест-драйв монитора
Тестовая программа для монитора
Теперь у нас есть все необходимые компоненты. Осталось 
написать тестовый код, чтобы заказчик мог получить данные от нескольких торговых автоматов:
import java.rmi.*;
public class GumballMonitorTestDrive {
 public static void main(String[] args) {
 String[] location = {"rmi://santafe.mightygumball.com/gumballmachine",
 "rmi://boulder.mightygumball.com/gumballmachine",
 "rmi://seattle.mightygumball.com/gumballmachine"}; 
 GumballMonitor[] monitor = new GumballMonitor[location.length];
 for (int i=0;i < location.length; i++) {
 try {
 GumballMachineRemote machine = 
 (GumballMachineRemote) Naming.lookup(location[i]);
 monitor[i] = new GumballMonitor(machine);
 System.out.println(monitor[i]);
 } catch (Exception e) {
 e.printStackTrace();
 }
 }
 for(int i=0; i < monitor.length; i++) {
 monitor[i].report();
 }
 }
}
Местонахождения всех 
автоматов, которые мы 
собираемся отслеживать.
Тестовая программа, которую 
будет запускать заказчик!
Создаем массив 
местонахождений,
по одному для каждого 
автомата.
Перебираем автоматы
и для каждого выводим отчет.
Теперь нужно получить 
заместитель для каждого 
автомата.
Также создаем 
массив мониторов.
паттерн заместитель
дальше   473
На каждом компьютере запустите rmiregistry в фоновом режиме 
или в отдельном терминальном 
окне...
 try {
 GumballMachineRemote machine = 
 (GumballMachineRemote) Naming.lookup(location[i]);
 monitor[i] = new GumballMonitor(machine);
 } catch (Exception e) {
 e.printStackTrace();
 }
Напоминаем: Naming.
lookup() — статический метод из пакета RMI, который 
ищет службу в реестре RMI 
по заданному местонахождению и имени.
Получив заместитель для удаленного 
автомата, мы создаем новый объект 
GumballMonitor и передаем ему 
отслеживаемый автомат.
Новая демонстрация для заказчика...
...затем запустите тестовую программу 
с указанием местонахождения и исходного 
количества шариков.
% rmiregistry &
% java GumballMachineTestDrive santafe.mightygumball.com 100
File Edit Window Help Huh?
File Edit Window Help Huh?
% rmiregistry &
% java GumballMachineTestDrive boulder.mightygumball.com 100
File Edit Window Help Huh?
% rmiregistry &
% java GumballMachineTestDrive seattle.mightygumball.com 250
популярный автомат!
Что ж, соберем все вместе и построим новую демонстрацию. Для начала следует позаботиться о том, 
чтобы новый код работал на нескольких автоматах:
Код под увеличительным стеклом
Возвращает заместитель для удаленного объекта 
GumballMachine (или инициирует исключение, если найти 
объект не удается).
474 глава 11
тест-драйв монитора
А теперь вручим монитор заказчику. Будем надеяться, 
что на этот раз результат его устроит:
File Edit Window Help GumballsAndBeyond
% java GumballMonitorTestDrive
Gumball Machine: santafe.mightygumball.com
Current inventory: 99 gumballs
Current state: waiting for quarter
Gumball Machine: boulder.mightygumball.com
Current inventory: 44 gumballs
Current state: waiting for turn of crank
Gumball Machine: seattle.mightygumball.com
Current inventory: 187 gumballs
Current state: waiting for quarter
%
Монитор перебирает 
удаленные автоматы 
и вызывает их методы 
getLocation(), getCount() 
и getState().
Потрясающе; это 
произведет революцию 
в моем бизнесе и сметет 
конкурентов!
В результате вызова методов заместителя 
вызываются удаленные методы, возвращающие 
String, целое число и объект State. Так как мы 
используем заместитель, GumballMonitor не знает, 
что вызовы выполняются в удаленном режиме, — 
впрочем, для него это несущественно (разве что 
ему приходится побеспокоиться о возможных 
исключениях удаленного доступа).
паттерн заместитель
дальше   475
Все отлично работает! Но я 
хочу быть уверен в том, что 
я правильно понимаю, как
это происходит...
Компьютер
заказчика
Торговый автомат с JVM
GumballMachine
GumballMonitor
Заместитель/за
глушка
Скелет
seattle
Заместитель/заглушка
1
3
lookup( "seattle")
получение 
посредника
getState( )
2
Тип GumballMachineRemote
1 Заказчик запускает монитор, который сначала получает заместителей 
для удаленных автоматов, а затем вызывает для каждого из них 
getState() (вместе с getCount() и getLocation()).
Реестр RMI (на автомате)
За сценой
476 глава 11
за сценой
GumballMachine
GumballMonitor
Заместитель/заглу
шка
Скелет
getState( )
2 Вызов метода getState() заместителя передается удаленной службе. 
Скелет получает запрос и передает его объекту GumballMachine.
getState()
3 Скелет получает от GumballMachine объект State, сериализует его 
и передает по сети заместителю. Заместитель десериализует объект 
и возвращает его монитору в виде объекта.
GumballMachine
GumballMonitor
Заместитель/заглушка
Скелет
Объект 
State Сериализованное 
состояние
Монитор не изменился, если не считать 
того, что он теперь знает о возможных исключениях удаленного доступа. 
Кроме того, он использует интерфейс 
GumballMachineRemote вместо конкретной реализации.
Класс GumballMachine тоже реализует 
другой интерфейс и может инициировать 
исключение удаленного доступа из конструктора, но в остальном код не изменился.
Также добавился небольшой фрагмент кода для регистрации 
и поиска заглушек по реестру RMI. Но если вы пишете код, 
который должен работать по интернету, механизм поиска 
понадобится в любом случае.
Объект 
State
паттерн заместитель
дальше   477
Мы рассмотрели пример того, как паттерн Заместитель предоставляет суррогатный объект для другого объекта. Но как 
насчет заместителя, управляющего доступом? Звучит немного 
странно... В нашем примере с торговыми автоматами заместитель должен обеспечить доступ к удаленному объекту, потому 
что клиент (монитор) не умеет взаимодействовать с удаленным объектом. Таким образом, удаленный заместитель берет на себя управление доступом, чтобы избавить клиента от 
низкоуровневых подробностей сетевых взаимодействий. Как 
упоминалось ранее, существует несколько разновидностей 
паттерна Заместитель, и все они обычно тем или иным образом связаны с тем, как именно организуется «управление доступом». Мы подробно рассмотрим эту тему позднее, а пока 
упомянем лишь несколько вариантов управления доступом 
в заместителях:
? Удаленный заместитель управляет доступом к удаленному 
объекту.
? Виртуальный заместитель управляет доступом к ресурсу, 
создание которого требует больших затрат ресурсов.
? Защитный заместитель контролирует доступ к ресурсу 
в соответствии с системой привилегий.
Теперь, когда вы представляете общую суть паттерна, перейдем 
к диаграмме классов...
Определение паттерна Заместитель
Паттерн Заместитель предоставляет суррогатный объект, управляющий доступом к другому 
объекту.
Позади осталась изрядная часть этой главы; как видите, объяснение схемы с удаленным заместителем требует довольно много места. Но несмотря на это, определение и диаграмма классов паттерна Заместитель относительно просты. У паттерна существует несколько разновидностей, 
мы поговорим о них позже. А пока давайте более подробно разберем 
общий паттерн.
Определение паттерна Заместитель:
Используйте паттерн 
Заместитель для 
создания объекта, 
управляющего 
доступом к другому 
объекту — удаленному, 
защищенному, 
требующему слишком 
больших затрат при 
создании и т. д.
478 глава 11
диаграмма классов
И Proxy, и RealSubject реализуют 
интерфейс Subject. Это 
позволяет любому клиенту 
работать с заместителем Proxy 
точно так же, как с реальным 
объектом RealSubject.
RealSubject — объект, 
выполняющий 
фактическую работу; 
заместитель управляет 
доступом к нему.
Proxy хранит ссылку на 
Subject, чтобы передавать 
запросы Subject по мере 
надобности.
<<interface>>
Subject
request()
RealSubject
request()
Proxy subject
request()
Заместитель часто 
создает экземпляры или 
управляет созданием 
RealSubject.
Основные блоки этой диаграммы:
Subject — интерфейс для взаимодействия с RealSubject и Proxy. Так как он 
реализует тот же интерфейс, что и RealSubject, реализация общего интерфейса позволяет использовать Proxy вместо RealSubject во всех операциях.
RealSubject — объект, выполняющий фактическую работу. Proxy представляет этот объект и управляет доступом к нему.
Заместитель Proxy хранит ссылку на RealSubject. В некоторых случаях 
Proxy отвечает за создание и уничтожение RealSubject. Клиенты взаимодействуют с RealSubject через Proxy. Так как Proxy и RealSubject реализуют 
общий интерфейс (Subject), Proxy может использоваться повсюду вместо 
RealSubject. Proxy также управляет доступом к RealSubject; это может быть 
полезно, если объект RealSubject работает на удаленном компьютере, если 
создание его экземпляров связано с большими затратами или если доступ 
к нему должен быть тем или иным образом защищен.
Итак, теперь вы имеете некоторое представление об этом паттерне, и мы 
можем рассмотреть другие варианты его использования помимо уже известного нам удаленного заместителя...
паттерн заместитель
дальше   479
Знакомьтесь: Виртуальный Заместитель
К настоящему моменту мы рассмотрели определение паттерна Заместитель и одно из его конкретных 
воплощений: Удаленный Заместитель. Переходим к другой разновидности: Виртуальный Заместитель. 
Паттерн Заместитель существует во многих формах, но все они строятся на приблизительно похожей 
архитектуре опосредованного доступа. Почему паттерн имеет столько разновидностей? Потому что 
он может применяться во множестве разных ситуаций. Давайте рассмотрим Виртуальный Заместитель и сравним его с Удаленным Заместителем:
RealSubject
Клиент
Proxy
Удаленный Заместитель request( )
В этой разновидности заместитель выполняет функции 
локального представителя 
объекта, находящегося в другой 
виртуальной машине Java. Вызов 
метода заместителя передается 
по Сети, метод вызывается на 
удаленном компьютере, результат возвращается заместителю, 
а затем и клиенту.
RealSubject
Клиент
Proxy
Виртуальный Заместитель
Виртуальный Заместитель 
представляет объект, создание 
которого сопряжено с большими затратами. Создание объекта часто откладывается до 
момента его непосредственного 
использования; Виртуальный 
Заместитель также выполняет 
функции суррогатного представителя объекта до и во время 
его создания. В дальнейшем заместитель делегирует запросы 
непосредственно RealSubject.
Хорошо знакомая диаграмма...
Большой «затратный»
объект.
Заместитель создает 
RealSubject тогда,
когда это необходимо.
request( )
request( )
Заместитель может обработать запрос 
или — если объект RealSubject уже был создан — делегировать вызовы RealSubject.
480 глава 11
виртуальный заместитель
Во время загрузки 
заместитель выводит 
сообщение.
Когда обложка альбома 
будет полностью загружена, 
заместитель выводит 
графическое изображение.
Пользователь выбирает 
обложку альбома.
Отображение обложек альбомов 
Допустим, вы пишете приложение для вывода обложек ваших любимых музыкальных альбомов. 
Меню с названиями альбомов загружается из интернета (например, с сайта Amazon.com). При 
программировании с использованием Swing можно создать объект Icon и указать, что изображение должно загружаться по Сети. Однако в зависимости от загруженности и пропускной способности канала загрузка может занять некоторое время; желательно, чтобы приложение отображало 
какую-то информацию в ходе ожидания. Кроме того, загрузка не должна парализовать работу всего приложения. После завершения загрузки сообщение исчезает, а на экране появляется обложка.
Для решения задачи проще всего воспользоваться виртуальным заместителем. Виртуальный заместитель заменяет объект Icon, управляя процессом фоновой загрузки, и до момента ее завершения выводит временное сообщение. Когда изображение будет загружено, заместитель передает 
управление Icon.
паттерн заместитель
дальше   481
Проектирование Виртуального Заместителя для обложек альбомов
<<interface>>
Icon
getIconWidth()
getIconHeight()
paintIcon()
ImageProxy
getIconWidth()
getIconHeight()
paintIcon()
getIconWidth()
getIconHeight()
paintIcon()
ImageIcon
javax.swing.ImageIcon —
класс для вывода графического изображения.
Заместитель сначала выводит 
сообщение, а затем после 
завершения загрузки передает 
управление ImageIcon.
Интерфейс Swing 
Icon, используемый 
для вывода графических 
изображений 
в приложениях.
Прежде чем писать код для программы просмотра обложек альбомов, рассмотрим диаграмму классов. Как видите, она мало отличается от диаграммы классов Удаленного Заместителя, но в данном случае заместитель используется для замещения объекта, создание 
которого занимает относительно много времени (так как данные передаются по Сети).
ImageProxy создает ImageIcon и начинает загрузку данных 
с сетевого URL-адреса.
Во время передачи графических данных ImageProxy выводит сообщение «Loading album cover, please wait...».
Когда изображение будет полностью загружено, ImageProxy 
делегирует ImageIcon все вызовы методов, включая 
paintIcon(), getWidth() и getHeight().
Когда пользователь запросит новое изображение, мы создаем новый заместитель, и весь процесс повторяется заново.
Класс ImageProxy будет работать так:
1
2
3
4
482 глава 11
ImageProxy
Класс ImageProxy
Конструктору передается URL-адрес 
изображения — того, которое должно 
отображаться после загрузки!
В переменной imageIcon хранится 
НАСТОЯЩИЙ объект Icon, который должен отображаться после 
загрузки.
До завершения загрузки 
возвращаются значения длины 
и ширины по умолчанию; затем 
управление передается imageIcon.
Здесь происходит самое интересное. Изображение прорисовывается на экране (вызов делегируется 
imageIcon). Но если объект ImageIcon 
еще не создан, мы создаем его. Происходящее более подробно рассматривается на следующей странице...
<<interface>>
Icon
getIconWidth()
getIconHeight()
paintIcon()
Класс ImageProxy 
реализует интерфейс Icon.
imageIcon используется 
разными потоками, поэтому 
кроме объявления переменной 
с модификатором volatile (для 
защиты операций чтения) мы 
используем синхронизированный 
метод записи (для защиты 
операций записи).
class ImageProxy implements Icon {
 volatile ImageIcon imageIcon;
 final URL imageURL;
 Thread retrievalThread;
 boolean retrieving = false;
 
 public ImageProxy(URL url) { imageURL = url; }
 public int getIconWidth() {
 if (imageIcon != null) {
 return imageIcon.getIconWidth();
 } else {
 return 800;
 }
 }
 public int getIconHeight() {
 if (imageIcon != null) {
 return imageIcon.getIconHeight();
 } else {
 return 600;
 }
 }
 synchronized void setImageIcon(ImageIcon imageIcon) {
 this.imageIcon = imageIcon;
 }
 
 public void paintIcon(final Component c, Graphics g, int x, int y) {
 if (imageIcon != null) {
 imageIcon.paintIcon(c, g, x, y);
 } else {
 g.drawString("Loading album cover, please wait...", x+300, y+190);
 if (!retrieving) {
 retrieving = true;
 retrievalThread = new Thread(new Runnable() {
 public void run() {
 try {
 setImageIcon(new ImageIcon(imageURL, "Album Cover"));
 c.repaint();
 } catch (Exception e) {
 e.printStackTrace();
 }
 }
 });
 retrievalThread.start();
 }
 }
 }
}
паттерн заместитель
дальше   483
.
Метод вызывается тогда, когда требуется 
перерисовать изображение на экране.
Если объект уже существует, 
то требование о перерисовке 
передается ему.
В противном 
случае выводится сообщение 
о загрузке.
Здесь загружается НАСТОЯЩЕЕ 
изображение. Следует учесть, что 
загрузка осуществляется синхронно: 
конструктор ImageIcon не возвращает управление до завершения загрузки. 
Соответственно, операции обновления 
экрана и вывода сообщения приходится 
осуществлять асинхронно. Подробнее 
на следующей странице...
Код под увеличительным стеклом
 public void paintIcon(final Component c, Graphics g, int x, int y) {
 if (imageIcon != null) {
 imageIcon.paintIcon(c, g, x, y);
 } else {
 g.drawString("Loading album cover, please wait...", x+300, y+190);
 if (!retrieving) {
 retrieving = true;
 retrievalThread = new Thread(new Runnable() {
 public void run() {
 try {
 setImageIcon(new ImageIcon(imageURL, "Album Cover"));
 c.repaint();
 } catch (Exception e) {
 e.printStackTrace();
 }
 }
 });
 retrievalThread.start();
 }
 }
 }
484 глава 11
код под микроскопом
В отдельном потоке 
создается экземпляр 
объекта Icon. Его конструктор не возвра
щает управление до 
-
завершения загрузки 
данных.
Если загрузка изображения
еще не началась...
Чтобы загрузка не парализовала 
пользовательский интерфейс 
программы, она будет 
выполняться в отдельном потоке.
После завершения загрузки 
оповещаем Swing о необходимости перерисовки.
Таким образом, при следующей перерисовке экрана после создания 
экземпляра ImageIcon метод paintIcon выведет изображение,
а не текстовое сообщение.
...можно начать загрузку (на 
всякий случай поясним, что 
paint вызывается только одним 
программным потоком, поэтому 
наша схема является потоковобезопасной).
Код под микроскопом
 
 if (!retrieving) {
 retrieving = true;
 retrievalThread = new Thread(new Runnable() {
 public void run() {
 try {
 setImageIcon(new ImageIcon(imageURL, "Album Cover"));
 c.repaint();
 } catch (Exception e) {
 e.printStackTrace();
 }
 }
 });
 retrievalThread.start();
 }
паттерн заместитель
дальше   485
Похоже, класс ImageProxy обладает двумя состояниями, причем нужное состояние выбирается при помощи условной конструкции. Можете ли вы предложить другой паттерн для упрощения этого кода? Как 
бы вы переработали ImageProxy в контексте этого паттерна?
Два состояния
Два состояния
Два состояния
Головоломка
class ImageProxy implements Icon {
 // Переменные экземпляра и конструктор
 
 public int getIconWidth() {
 if (imageIcon != null) {
 return imageIcon.getIconWidth();
 } else {
 return 800;
 }
 }
 public int getIconHeight() {
 if (imageIcon != null) {
 return imageIcon.getIconHeight();
 } else {
 return 600;
 }
 }
 
 public void paintIcon(final Component c, Graphics g, int x, int y) {
 if (imageIcon != null) {
 imageIcon.paintIcon(c, g, x, y);
 } else {
 g.drawString("Loading album cover, please wait...", x+300, y+190);
 // ...
 } 
 }
}
486 глава 11
тест-драйв
public class ImageProxyTestDrive {
 ImageComponent imageComponent;
 public static void main (String[] args) throws Exception {
 ImageProxyTestDrive testDrive = new ImageProxyTestDrive();
 }
 public ImageProxyTestDrive() throws Exception{
 
 // Создание панели и меню
 Icon icon = new ImageProxy(initialURL);
 imageComponent = new ImageComponent(icon);
 frame.getContentPane().add(imageComponent);
 }
}
Тестирование программы просмотра обложек
Создаем заместитель и связываем его с исходным URL-адресом. 
Каждый раз, когда вы выбираете один из пунктов меню Album, 
вы получаете новый объект 
ImageProxy.
Готово 
к употреблению
Пора заняться тестированием виртуального заместителя. Новый класс ImageProxyTestDrive создает окно с панелью, настраивает меню и создает заместитель. Мы не будем описывать код во всех подробностях, но вы всегда можете 
загрузить полную версию программы и рассмотреть ее самостоятельно — или 
же обратиться к полному листингу виртуального заместителя в конце главы.
Затем заместитель 
упаковывается в компонент для добавления 
к объектам панели. Добавляем заместитель к объектам панели, 
на которой должно выводиться изображение.
А теперь запустим тестовую программу:
Примерный вид окна 
ImageProxyTestDrive.
Попробуйте самостоятельно...
Использовать меню для загрузки разных обложек альбомов. 
Проследите за тем, как заместитель выводит сообщение 
о загрузке до получения всех данных.
Изменить размеры окна во время вывода сообщения. 
Обратите внимание на то, что данные загружаются без 
блокировки окна Swing.
Добавить свои любимые альбомы в ImageProxyTestDrive.
1
2
3
File Edit Window Help JustSomeOfTheCDsThatGotUsThroughThisBook
% java ImageProxyTestDrive
А здесь приводится небольшой фрагмент тестовой программы:
паттерн заместитель
дальше   487
ImageIcon
запрос 
изображения
Что мы сделали?
ImageIcon
ImageProxy
загрузка 
изображения
Мы создали класс заместителя ImageProxy. При вызове метода 
paintIcon() класс ImageProxy создает программный поток для загрузки 
изображения и создания ImageIcon.
paintIcon()
ImageProxy порождает поток для создания экземпляра 
ImageIcon, который начинает 
загрузку графических данных.
выводит сообщение о загрузке
После получения всех данных создание 
экземпляра ImageIcon завершается.
После создания ImageIcon при следующем вызове 
paintIcon() заместитель передает управление ImageIcon.
Image
ImageIcon
Proxy
paintIcon()
вывод изображения
paintIcon()
1
2
3
Сервер
в интернете
За сценой
488 глава 11
вопросы и ответы
В: Удаленный Заместитель и Виртуальный Заместитель имеют мало общего; вы уверены, что это ОДИН паттерн?
О: На практике встречается множество 
разновидностей паттерна Заместитель; их 
отличительной чертой является перехват 
методов реального объекта, вызываемых клиентом. Введение промежуточного 
уровня позволяет решать многие задачи: 
перенаправлять запросы удаленным объектам, предоставлять суррогаты для высокозатратных объектов на время их создания и т. д. Впрочем, это лишь начало; 
существует множество вариаций на тему 
паттерна Заместитель. Некоторые из них 
будут описаны в конце главы.
В: Мне кажется, что класс ImageProxy 
скорее использует паттерн Декоратор: 
один объект фактически упаковывается 
в другой, а вызовы методов делегируются ImageIcon. Может, я чего-то не замечаю?
О: Паттерны Заместитель и Декоратор 
иногда похожи друг на друга, но их цели 
принципиально различаются: Декоратор 
добавляет в класс новое поведение, а 
Заместитель управляет доступом к нему. 
Конечно, вы можете спросить: «Разве вывод сообщения не является расширением 
поведения?» Да, в каком-то смысле это 
так; но важнее здесь то, что ImageProxy 
управляет доступом к ImageIcon. Каким 
образом? Заместитель отделяет клиента 
от ImageIcon. Если бы не это разделение, 
то обновление всего интерфейса происходило только после полной загрузки изображения. Заместитель управляет доступом к ImageIcon и до завершения создания 
объекта предоставляет временную замену 
экранного представления. Когда объект 
будет готов, заместитель открывает доступ к нему.
В: Как заставить клиентов использовать заместитель вместо реального 
объекта?
О: Хороший вопрос. Один из стандартных приемов — создание фабрики, 
которая создает и возвращает реальный 
объект. В этом случае реальный объект 
можно упаковать в заместитель перед возвращением. Клиент даже не подозревает, 
что вместо реального объекта он использует заместитель.
В: В примере ImageProxy мы всегда 
создаем новый объект ImageIcon, даже 
если изображение уже было загружено 
ранее. Нельзя ли реализовать механизм 
кэширования данных, полученных в результате прошлых запросов? 
О: Вы говорите о специализированной 
форме виртуальных заместителей, так 
называемом кэширующем заместителе. 
Кэширующий заместитель поддерживает 
кэш ранее созданных объектов и при поступлении запроса по возможности возвращает кэшированный объект.
Мы рассмотрим эту и некоторые другие 
разновидности паттерна Заместитель 
в конце главы.
В: Между паттернами Декоратор и Заместитель существует несомненное 
сходство, но как насчет паттерна Адаптер? 
О: Паттерны Заместитель и Адаптер 
перехватывают запросы, предназначенные для других объектов. Однако при этом 
Адаптер изменяет интерфейс адаптируемых объектов, а Заместитель реализует 
тот же интерфейс.
Существует еще одно сходство, связанное с формой Защитного Заместителя. 
Защитный Заместитель может разрешить 
или запретить клиенту доступ к некоторым 
методам объекта в зависимости от роли 
клиента.
Таким образом, Защитный Заместитель 
может ограничивать интерфейс с точки 
зрения клиента; в этом отношении он напоминает некоторые адаптеры. Эта форма паттерна будет рассмотрена далее.
часто Задаваемые вопросы
паттерн заместитель
дальше   489
Привет, Декоратор. Полагаю, ты здесь потому, 
что люди нас иногда путают?
Да, нас действительно путают, в основном из-за 
того, что ты прикидываешься самостоятельным 
паттерном, а на самом деле ты всего лишь переодетый Декоратор. Нехорошо красть чужие 
идеи.
Я краду твои идеи? Брось. Я управляю доступом 
к объектам, а ты их просто декорируешь. Моя 
работа настолько важнее твоей, что это даже не 
смешно.
Будь по-твоему... Но я все равно не понимаю, почему ты думаешь, что я краду твои идеи. Я занимаюсь исключительно представлением объектов, 
а не их декорированием.
Можешь называть это «представлением», какая 
разница... Сам подумай: твой Виртуальный Заместитель — обычный механизм добавления поведения на время загрузки большого затратного 
объекта, а Удаленный Заместитель — избавление 
клиентов от низкоуровневого взаимодействия с 
удаленными объектами. Все завязано на поведении, как я и сказал.
Мне кажется, ты чего-то не понимаешь. Я заменяю свои объекты, а не расширяю их поведение. 
Клиент использует меня как суррогат настоящего объекта, потому что я предотвращаю несанкционированный доступ, скрываю тот факт, что 
объект работает на удаленном компьютере. Мои 
цели не имеют с твоими ничего общего!
Заместитель и Декоратор 
переходят на личности
Заместитель Декоратор
«Просто» декорирую? Ты думаешь, что это так 
легко и несерьезно? Так я скажу тебе, приятель, 
я расширяю поведение. Самое важное в объектах — 
то, что они делают!
Называй как хочешь. Я реализую тот же интерфейс, что и упакованные во мне объекты. Ты 
тоже.
Беседа у камина
490 глава 11
беседа у камина
Допустим, но удаленный заместитель — особый 
случай. Еще примеры найдутся? Что-то сомневаюсь.
Возьмем удаленный заместитель... Где тут упаковка? Я представляю объект, находящийся 
на другом компьютере, и управляю доступом 
к нему! А ты на такое способен?
Ах вот как?
Заместитель Декоратор
Давай-ка разберемся. Упакованные объекты? 
Иногда мы неформально говорим, что заместитель упаковывает свой объект, но это неточное 
выражение. Да ну? Почему же?
Хорошо, вспомни пример с обложками альбомов. Когда клиент впервые использует меня как 
заместитель, представляемый объект еще не существует!
Да, и после этого разговора я убежден, что ты — 
упрощенный заместитель! Упрощенный заместитель? Хотел бы я видеть, 
как ты рекурсивно упакуешь объект на десяток 
уровней и при этом останешься в здравом уме.
Ага, а теперь ты скажешь, что создание объектов — это тоже твоя заслуга.
Не думал, что декораторы настолько тупы! Ну 
конечно, я иногда создаю объекты — откуда они 
иначе возьмутся у виртуального заместителя! 
Хорошо, ты только что указал на важное различие между нами: декоратор только наводит 
внешний блеск, но ничего не создает.
Заместитель почти никогда не используется 
для многоуровневой упаковки. Если что-то приходится упаковывать на десять уровней, лучше 
пересмотреть архитектуру приложения.
Да, это на тебя похоже: прикидываться, будто 
ты что-то значишь, хотя на самом деле ты только 
изображаешь другой объект. Мне жаль тебя.
паттерн заместитель
дальше   491
Создание защитного заместителя средствами Java API
Поддержка заместителей в языке Java находится в пакете java.lang.reflect. При использовании этого пакета Java позволяет динамически создать класс заместителя, 
который реализует один или несколько интерфейсов и перенаправляет вызовы 
методов заданному вами классу. Так как класс заместителя строится во время выполнения, такие заместители называются динамическими.
Мы воспользуемся механизмом динамических заместителей Java для создания нашей собственной реализации (защитного заместителя). Но сначала мы рассмотрим диаграмму классов, объясняющую суть 
динамических заместителей. Как это часто бывает в реальном мире, она слегка отличается от классического определения паттерна:
<<interface>>
Subject
request()
RealSubject
request()
Proxy
request()
<<interface>>
InvocationHandler
invoke()
InvocationHandler
Теперь заместитель 
состоит из двух 
классов.
Заместитель генерируется 
на уровне Java и реализует 
весь интерфейс Subject. Вы предоставляете класс InvocationHandler, 
которому передаются все вызовы методов 
Proxy. InvocationHandler управляет 
доступом к методам RealSubject.
Так как Java строит класс Proxy за вас, вы должны как-то указать классу Proxy, что он должен делать. 
Этот код невозможно разместить в классе Proxy, как это делалось ранее, потому что мы не определяем реализацию этого класса. Если код не может находиться в классе Proxy, то где его место? В классе 
InvocationHandler. Задачей этого класса является обработка всех вызовов методов заместителя. Считайте, что Proxy после получения вызова метода обращается к InvocationHandler за выполнением фактической работы.
Давайте последовательно рассмотрим процесс использования динамического посредника...
invoke()
492 глава 11
служба знакомств
Знакомства для гиков
В каждом городе должна быть своя служба знакомств, верно? Вам поручено реализовать такую службу в Объектвиле. Включив специальный 
рейтинг, при помощи которого участники оценивают уровень гиковской 
крутизны друг друга, вы ожидаете, что, во-первых, у них будет больше стимулов для просмотра списка потенциальных кандидатов, а во-вторых, так 
интереснее.
Центральное место в вашей службе занимает компонент Person, предназначенный для чтения и записи данных кандидата:
Получение информации 
о кандидате: имя, пол, интересы 
и гик-рейтинг (1-10).
Методы записи тех 
же данных.
Метод setGeekRating() получает целое число и включает его 
в накапливаемую среднюю оценку 
кандидата.
Интерфейс; вскоре 
доберемся и до 
реализации...
Обратимся к реализации...
public interface Person {
 String getName();
 String getGender();
 String getInterests();
 int getGeekRating();
 void setName(String name);
 void setGender(String gender);
 void setInterests(String interests);
 void setGeekRating(int rating); 
}
паттерн заместитель
дальше   493
Переменные экземпляров.
Класс PersonImpl реализует интерфейс Person.
Get-методы возвращают 
значения соответствующих 
переменных экземпляров...
...кроме метода getGeekRating(), 
который вычисляет среднюю оценку 
делением суммы на количество оценок 
ratingCount.
Set-методы задают 
значения соответствующих 
переменных.
Наконец, метод getGeekRating() 
увеличивает значение 
ratingCount и прибавляет 
оценку к накапливаемой сумме.
Реализация Person
public class PersonImpl implements Person {
 String name;
 String gender;
 String interests;
 int rating;
 int ratingCount = 0;
 
 public String getName() {
 return name; 
 } 
 
 public String getGender() {
 return gender;
 }
 
 public String getInterests() {
 return interests;
 }
 
 public int getGeekRating() {
 if (ratingCount == 0) return 0;
 return (rating/ratingCount);
 }
 
 public void setName(String name) {
 this.name = name;
 }
 public void setGender(String gender) {
 this.gender = gender;
 } 
 
 public void setInterests(String interests) {
 this.interests = interests;
 } 
 
 public void setGeekRating(int rating) {
 this.rating += rating; 
 ratingCount++;
 }
}
494 глава 11
необходимая защита
Возможно, Элрою не везет со знакомствами по другим причинам, но он прав: пользователи не должны голосовать за себя 
или изменять данные других пользователей. При нашем способе определения PersonBean любой клиент может вызывать 
любые методы.
Перед нами идеальный пример ситуации, в которой применяется защитный заместитель. Что это такое? Заместитель, 
который управляет доступом к другому объекту в зависимости от прав пользователей. Например, для объекта работника 
защитный заместитель может разрешить самому работнику 
вызывать некоторые методы, начальнику — дополнительные 
методы (скажем, setSalary()), а отделу кадров — любые методы 
объекта.
В нашей службе знакомств клиент должен иметь возможность 
задать свою личную информацию, но введенная информация 
не должна изменяться другими клиентами. С гик-рейтингом 
ситуация прямо противоположная: он должен задаваться другими пользователями, но не самим клиентом. Кроме того, интерфейс Person содержит ряд get-методов; так как эти методы 
не возвращают приватную информацию, они могут вызываться любым пользователем.
Элрой
Мне не везло со знакомствами. А потом 
я заметил, что мои увлечения кто-то 
изменил! Также выяснилось, что многие 
люди занимаются накрутками, ставя себе самим 
высокие рейтинги. Пользователь не должен 
иметь возможность менять чужие увлечения или 
ставить оценки самому себе!
паттерн заместитель
дальше   495
Пятиминутная драма: защита клиентов
«Эпоха доткомов» осталась в прошлом. Чтобы найти лучшую, более высокооплачиваемую работу, было достаточно перейти через дорогу. У программистов даже появились свои агенты...
Как и защитный 
заместитель, агент 
управляет доступом к своему 
клиенту, пропуская только 
определенные звонки...
Агент
Джейн 
Дотком
У меня есть предложение, можно пригласить ее 
к телефону? Субъект
Она занята... 
Э-э-э... на важной 
встрече. А что вы 
хотели?
Не тратьте наше время 
попусту! Ни единого 
шанса! Звоните, когда 
появятся более выгодные 
предложения.
Думаю, мы 
можем предложить 
ей на 15% больше, чем 
на ее текущей работе.
496 глава 11
общая картина
Общая картина: динамический заместитель для Person
Нужно решить две проблемы: во-первых, пользователи не должны изменять свой гик-рейтинг, а вовторых, для них должна быть недоступна персональная информация других пользователей. Мы создадим двух заместителей: для обращения к своему объекту Person и для обращения к объекту Person 
другого пользователя. Заместители будут определять, какие запросы возможны в каждой из этих ситуаций.
<<interface>>
Subject
request()
RealSubject
request()
Proxy
request()
<<interface>>
InvocationHandler
invoke()
InvocationHandler Создание двух реализаций InvocationHandler. InvocationHandler реализует поведение заместителя. Как вскоре будет 
показано, Java создает класс и объект заместителя — нам остается лишь предоставить обработчик, который знает, что делать при вызове метода.
Напишите код создания динамического 
заместителя. В программу включается 
небольшой фрагмент кода, который генерирует класс заместителя и создает его 
экземпляр. Вскоре мы рассмотрим этот 
код более подробно.
Каждый объект Person упаковывается 
в соответствующий заместитель. Когда 
вам понадобится использовать объект 
Person, этот объект представляет либо самого пользователя, либо другого пользователя службы знакомств.
В любом случае для Person создается соответствующий заместитель.
Шаг 1:
Шаг 2:
Шаг 3:
Понадобятся два 
таких объекта.
Сам заместитель 
создается во время 
выполнения.
request()
Proxy
invoke()
OwnerInvocationHandler
request()
Proxy
invoke()
NonOwnerInvocationHandler
Пользователь просматривает свой объект.
Пользователь просматривает чужой объект.
invoke()
Для создания заместителей мы воспользуемся механизмом динамических заместителей Java API, 
который был представлен несколько страниц 
назад. Java сгенерирует заместителей автоматически; нам остается лишь предоставить обработчики, которые определяют действия при вызове 
методов заместителей.
Вспомните диаграмму, приведенную несколько страниц назад...
паттерн заместитель
дальше   497
Шаг 1: создание реализаций Invocation Handler
Итак, мы должны написать два обработчика: для владельца и для других пользователей. Но что собой представляет обработчик? Когда клиент вызывает метод заместителя, последний перенаправляет 
этот вызов обработчику — не вызывая соответствующий метод обработчика. Что же тогда он вызывает? Посмотрите на интерфейс InvocationHandler:
Он содержит единственный метод invoke(), и какой бы метод заместителя ни был вызван, это всегда 
приводит к вызову метода invoke() обработчика. Вот как работает эта схема:
proxy.setGeekRating()(9);
invoke(Object proxy, Method method, Object[] args)
Допустим, вызывается метод 
setGeekRating() заместителя.
Заместитель вызывает 
метод invoke() для 
InvocationHandler.
1
2
Обработчик решает, 
как поступить с запросом; возможно, запрос 
будет передан объекту RealSubject. Как 
обработчик принимает 
решение? Сейчас разберемся.
3
return method.invoke(person, args);
Исходный метод, 
вызванный для 
заместителя (объект 
метода передается 
при вызове invoke).
И только 
теперь он 
вызывается 
для реального 
объекта...
...с исходными 
аргументами.
Вызов метода 
реального 
объекта.
Класс Method из Reflection API 
сообщает, какой метод был 
вызван для заместителя, для 
чего используется его метод 
getName().
<<interface>>
InvocationHandler
invoke()
498 глава 11
создание InvocationHandler
Создание реализаций InvocationHandler (продолжение)...
Как же при вызове invoke() заместителя определить, что делать с этим 
вызовом? Обычно решение принимается на основании анализа имени 
метода и, возможно, аргументов. Следующая реализация обработчика 
OwnerInvocationHandler показывает, как это делается:
Необходимо импортировать пакет java.
lang.reflect, в котором определяется 
интерфейс InvocationHandler. Все обработчики реализуют 
интерфейс InvocationHandler.
Передаем реальный 
объект в конструкторе и сохраняем 
ссылку на него.
При каждом вызове 
метода заместителя вызывается метод 
invoke.
Если вызван getметод, вызов передается реальному 
объекту.
Вызов метода
setGeekRating()
блокируется 
выдачей исключения 
IllegalAccessException.
Вызов любых 
других set-методов 
владельцу разрешен, 
передаем реальному 
объекту.
При вызове любого другого 
метода мы просто 
возвращаем null, чтобы 
избежать лишнего риска.
Выполняется при 
выдаче исключения 
реальным объектом.
import java.lang.reflect.*;
public class OwnerInvocationHandler implements InvocationHandler { 
 Person person;
 public OwnerInvocationHandler(Person person) {
 this.person = person;
 }
 public Object invoke(Object proxy, Method method, Object[] args) 
 throws IllegalAccessException {
 
 try {
 if (method.getName().startsWith("get")) {
 return method.invoke(person, args);
 } else if (method.getName().equals("setGeekRating")) {
 throw new IllegalAccessException();
 } else if (method.getName().startsWith("set")) {
 return method.invoke(person, args);
 } 
 } catch (InvocationTargetException e) {
 e.printStackTrace();
 } 
 return null;
 }
}
паттерн заместитель
дальше   499
Обработчик данных других пользователей NonOwnerInvocationHandler 
работает точно так же, как OwnerInvocationHandler, если не считать 
того, что он разрешает вызовы setGeekRating() и запрещает вызовы всех Упражнение остальных set-методов. Напишите код обработчика самостоятельно:
500 глава 11
создание класса
Остается лишь динамически сгенерировать класс заместителя и создать экземпляр объекта. Начнем с 
написания метода, который получает объект Person и который создает для него заместитель, предназначенный для владельца. Таким образом, мы создаем заместитель, который передает вызовы методов 
OwnerInvocationHandler.
Шаг 2: создание класса и экземпляра заместителя
Этот метод получает объект Person (данные 
конкретного человека) и возвращает для него 
заместитель. Так как заместитель обладает 
тем же интерфейсом, что и реальный объект, мы возвращаем Person.
Код, генерирующий заместитель. Мы последовательно разберем каждую из выполняемых операций.
Для создания заместителя используется статический метод 
newProxyInstance() класса Proxy...
Передаем ему загрузчик класса 
для нашего реального объекта...
...и набор интерфейсов, который должен реализовать заместитель...
...и обработчик вызова — в нашей 
ситуации OwnerInvocationHandler.
Конструктору обработчика передается 
реальный объект (как было показано пару 
страниц назад, именно так обработчик 
получает доступ к реальному объекту).
Код создания динамических заместителей нетривиален, но и сложным его никак не 
назовешь. Почему бы вам не написать собственную реализацию getNonOwnerProxy(), 
возвращающую заместителей для NonOwnerInvocationHandler?
Удастся ли вам написать общий метод getProxy(), который получает обработчик 
и объект Person и возвращает соответствующий заместитель?
Возьми в руку карандаш
Person getOwnerProxy(Person person) {
 
 return (Person) Proxy.newProxyInstance( 
 person.getClass().getClassLoader(),
 person.getClass().getInterfaces(),
 new OwnerInvocationHandler(person));
}
паттерн заместитель
дальше   501
Тестирование службы знакомств
Тестовый запуск наглядно показывает, как доступ к set-методам ограничивается в зависимости от используемого заместителя:
Метод main() просто создает тестовый 
сценарий и запускает тестирование вызовом drive().
Конструктор инициализирует базу 
данных кандидатов службы знакомств.
Чтение записи из базы данных...
...и создание заместителя 
для владельца.
Вызываем get-метод...
...затем set-метод...
...а затем пытаемся 
изменить оценку.
Не должно работать!
Теперь создаем заместитель 
для другого пользователя.
...вызываем get-метод...
...set-метод...
Не должно работать!
Теперь пытаемся 
задать оценку.
Должно работать!
public class MatchMakingTestDrive {
 // Переменные экземпляра
 
 public static void main(String[] args) {
 MatchMakingTestDrive test = new MatchMakingTestDrive();
 test.drive();
 }
 public MatchMakingTestDrive() {
 initializeDatabase();
 }
 public void drive() {
 Person joe = getPersonFromDatabase("Joe Javabean"); 
 Person ownerProxy = getOwnerProxy(joe);
 System.out.println("Name is " + ownerProxy.getName());
 ownerProxy.setInterests("bowling, Go");
 System.out.println("Interests set from owner proxy");
 try {
 ownerProxy.setGeekRating(10);
 } catch (Exception e) {
 System.out.println("Can't set rating from owner proxy");
 }
 System.out.println("Rating is " + ownerProxy.getGeekRating());
 Person nonOwnerProxy = getNonOwnerProxy(joe);
 System.out.println("Name is " + nonOwnerProxy.getName());
 try {
 nonOwnerProxy.setInterests("bowling, Go");
 } catch (Exception e) {
 System.out.println("Can't set interests from non owner proxy");
 }
 nonOwnerProxy.setGeekRating(3);
 System.out.println("Rating set from non owner proxy");
 System.out.println("Rating is " + nonOwnerProxy.getGeekRating());
 }
 // Другие методы — такие, как getNonOwnerProxy
}
502 глава 11
тест-драйв
File Edit Window Help Born2BDynamic
% java MatchMakingTestDrive 
Name is Joe Javabean
Interests set from owner proxy
Can’t set rating from owner proxy
Rating is 7
Name is Joe Javabean
Can’t set interests from non owner proxy
Rating set from non owner proxy
Rating is 5
%
Запуск кода...
Заместитель владельца 
разрешает чтение и запись 
(кроме оценки).
Заместитель другого 
пользователя разрешает 
только чтение, а также 
запись только для оценки.
Новая оценка вычисляется как 
среднее арифметическое предыдущей 
оценки 7 и значения, заданного другим 
пользователем (3).
В: Почему динамические заместители 
так называются? Потому что я создаю 
экземпляр заместителя и связываю его 
с обработчиком во время выполнения?
О: Нет, потому что класс заместителя 
создается во время выполнения. До выполнения вашего кода класс заместителя 
не существует; он строится по требованию 
на основании переданных ему интерфейсов.
В: Для заместителя InvocationHandler 
выглядит довольно странно — он не реализует ни один метод класса, который 
он представляет.
О: InvocationHandler не является заместителем — это класс, к которому обращается заместитель за обработкой 
вызовов методов. Сам заместитель строится динамически вызовом метода Proxy.
newProxyInstance().
В: Как отличить класс динамического 
заместителя от других классов?
О: Класс Proxy содержит статический 
метод isProxyClass(). Вызов этого метода 
для класса вернет true, если класс является классом динамического заместителя. 
В остальном класс ведет себя точно так 
же, как любой другой класс, реализующий 
конкретный набор интерфейсов.
В: Существуют ли ограничения для 
типов интерфейсов, передаваемых 
newProxyInstance()?
О: Да, существуют. Во-первых, 
newProxyInstance() всегда передается 
массив интерфейсов — разрешены только интерфейсы, но не классы. Главное 
ограничение заключается в том, что все 
интерфейсы с уровнем доступа, отличным 
от public, должны принадлежать одному 
пакету. Кроме того, запрещены конфликты 
имен в интерфейсах (то есть интерфейсы 
с методами, имеющими одинаковую сигнатуру). Существуют и другие второстепенные ограничения; информацию о них 
можно найти в javadoc.
часто Задаваемые вопросы
паттерн заместитель
дальше   503
Соедините каждый паттерн с его описанием:
Паттерн Описание
Декоратор
Фасад
Заместитель
Адаптер
Упаковывает другой объект 
и предоставляет другой интерфейс для работы с ним
Упаковывает другой 
объект и предоставляет 
дополнительное поведение
Упаковывает другой 
объект для управления 
доступом к нему
Упаковывает группу 
объектов для упрощения 
их интерфейса
Кто и что делает?
504 глава 11
Разновидности заместителей
Добро пожаловать в зоопарк городка Объектвиль! 
Вы уже знакомы с удаленным, виртуальным и защитным заместителями, но в разных уголках нашего мира встречается немало других форм 
и разновидностей этого паттерна. В специальном уголке нашего зоопарка представлена коллекция типичных экспонатов, собранных здесь для 
расширения вашего кругозора.
Наверняка вы встретите и другие разновидности этого паттерна; надеемся, что вы поможете нам пополнить каталог новыми видами. А пока 
давайте познакомимся с коллекцией в ее текущем состоянии:
Кэширующий Заместитель 
обеспечивает временное 
хранение результатов 
высокозатратных операций. 
Также может обеспечивать 
совместный доступ к результатам 
для предотвращения лишних вычислений 
или пересылки данных по Сети.
Фильтрующий 
Заместитель управляет 
доступом к группам 
сетевых ресурсов, защищая их от 
«недобросовестных» клиентов.
Умная Ссылка 
обеспечивает 
выполнение 
дополнительных 
действий при 
обращении к объекту 
(например, изменение 
счетчика ссылок).
Среда обитания: 
часто встречается 
в корпоративных системах 
защиты данных.
Среда обитания: часто встречается 
в веб-серверах, системах управления 
контентом и публикацией.
Опишите среду обитания
разновидности заместителей
паттерн заместитель
дальше   505
Синхронизирующий 
Заместитель 
предоставляет 
безопасный доступ 
к объекту из нескольких 
программных потоков.
Упрощающий 
Заместитель скрывает 
сложность и управляет 
доступом к сложному 
набору классов. Иногда 
по очевидным соображениям 
называется Фасадным Заместителем. 
Упрощающий Заместитель отличается 
от паттерна Фасад тем, что первый 
управляет доступом, а второй только 
предоставляет альтернативный Заместитель Отло- интерфейс. женного Копирования 
задерживает фактическое копирование 
объекта до момента 
выполнения операций 
с копией (разновидность Виртуального 
Заместителя).
Встречается в окрестностях коллекций; 
управляет синхронизацией доступа 
к группам объектов в многопоточной 
среде.
Запишите другие разновидности заместителей, с которыми 
вы столкнулись в естественной среде обитания:
Среда обитания: 
встречается в окрестностях 
CopyOnWriteArrayList (Java 5).
Опишите среду обитания
506 глава 11
ваш инструментарий
Новые инструменты
Ваш инструментарий почти полон; у вас есть 
все необходимое для решения почти любой 
проблемы.
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции   Паттерн Заместитель предоставляет «суррогат» для управления 
доступом к другому объекту.
  Удаленный Заместитель управляет взаимодействием клиента 
с удаленным объектом.
  Виртуальный Заместитель 
управляет доступом к объекту, 
создание которого сопряжено 
с большими затратами.
  Защитный Заместитель управляет доступом к методам объекта 
в зависимости от привилегий 
вызывающей стороны.
  Существует много других разновидностей паттерна Заместитель: Кэширующий Заместитель, 
Синхронизирующий Заместитель, 
Фильтрующий Заместитель и т. д.
  На структурном уровне паттерны 
Заместитель и Декоратор похожи, но они различаются по своим 
целям.
  Паттерн Декоратор расширяет 
поведение объекта, а Заместитель управляет доступом.
  Встроенная поддержка посредников в Java позволяет генерировать классы динамических 
заместителей во время выполнения и передавать все вызовы 
обработчику по вашему выбору.
  Заместители, как и любые 
«обертки», увеличивают количество классов и объектов в архитектуре.
В этой главе новых 
принципов не было. 
Сможете ли вы закрыть книгу и вспомнить их все?
Новый паттерн 
Заместитель 
выполняет 
функции представителя другого объекта.
Принципы
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты 
для расширения, но закрыты для 
изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Взаимодействуйте только с 
«друзьями».
Не вызывайте нас — мы вас сами 
вызовем.
Класс должен иметь только 
одну причину для изменений.
Стратегия — определяет 
семейство алгоритмов, инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет модифицировать алгоритмы 
независимо от их использования на стороне клиента.
Паттерны
Наблюдатель — defines a 
one-to-many dependency 
between objects so that 
when one object changes 
state, all its dependents are 
notified and updated 
automatically
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a flexible 
alternative to subclassing for 
extending functionality.
Абстрактная Фабри- ка — Provide an interface for creating families of related 
or depedent objects without 
specifying their concrete 
classes.
Фабричный метод — 
Define an interface for 
creating an object, but let 
subclasses decide which class 
to instantiate. Factory 
Method lets a class 
defer instantiation to 
the subclasses.
Одиночка — гарантирует, 
что класс имеет только 
один экземпляр, и предоставляет глобальную точку 
доступа к этому экземпляру.
Command — Encapsulates a 
request as an object, thereby 
letting you parameterize 
clients with different requests, 
queue or log requests, 
and support undoable 
operations.
Адаптер — Encapsulates a 
request as an object, thereby 
letting you parameterize 
clients with different requests, 
queue or log requests, and support undoable 
operations.
Фасад — Encapsulates a 
request as an object, thereby 
letting you parameterize 
clients with different requests, 
queue or log requests, and 
support undoable 
operations.
Состояние — управляет изменением поведения объекта 
при изменении его внутреннего состояния. Внешне это 
выглядит так, словно объект 
меняет свой класс.
Заместитель — предоставляет суррогатный объект, управляющий доступом к другому объекту.
КЛЮЧЕВЫЕ 
МОМЕНТЫ
паттерн заместитель
дальше   507
Используйте паттерн Состояние: реализуйте два состояния (ImageLoaded и ImageNotLoaded) 
и переместите код из конструкций if в соответствующие состояния. Начните с состояния 
ImageNotLoaded, а затем перейдите в состояние ImageLoaded после получения данных 
ImageIcon.
Обработчик данных других пользователей NonOwnerInvocationHandler 
работает точно так же, как OwnerInvocationHandler, если не считать 
того, что он разрешает вызовы setGeekRating() и запрещает вызовы всех 
остальных set-методов. Напишите код обработчика самостоятельно:
Похоже, класс ImageProxy обладает двумя состояниями, причем нужное состояние выбирается при помощи условной конструкции. Можете ли вы предложить другой паттерн для упрощения этого кода? Как 
бы вы переработали ImageProxy в контексте этого паттерна?
Головоломка
Решение
Возьми в руку карандаш
 Решение
import java.lang.reflect.*;
public class NonOwnerInvocationHandler implements InvocationHandler { 
 Person person;
 public NonOwnerInvocationHandler(Person person) {
 this.person = person;
 }
 public Object invoke(Object proxy, Method method, Object[] args) 
 throws IllegalAccessException {
 
 try {
 if (method.getName().startsWith("get")) {
 return method.invoke(person, args);
 } else if (method.getName().equals("setGeekRating")) {
 return method.invoke(person, args);
 } else if (method.getName().startsWith("set")) {
 throw new IllegalAccessException();
 } 
 } catch (InvocationTargetException e) {
 e.printStackTrace();
 } 
 return null;
 }
}
508 глава 11
ответы к упражнениям
Код создания динамических заместителей нетривиален, но и сложным его никак не назовешь. Почему бы вам не написать собственную 
реализацию getNonOwnerProxy(), возвращающую заместитель для 
NonOwnerInvocationHandler?
Возьми в руку карандаш
 Решение
Соедините каждый паттерн с его описанием:
Паттерн Описание
Декоратор
Фасад
Заместитель
Адаптер
Упаковывает другой объект 
и предоставляет другой интерфейс для работы с ним
Упаковывает другой 
объект и предоставляет 
дополнительное поведение
Упаковывает другой 
объект для управления 
доступом к нему
Упаковывает группу 
объектов для упрощения 
их интерфейса
Кто и что делает?
решение
Person getNonOwnerProxy(Person person) {
 
 return (Person) Proxy.newProxyInstance(
 person.getClass().getClassLoader(),
 person.getClass().getInterfaces(),
 new NonOwnerInvocationHandler(person));
}
паттерн заместитель
дальше   509
Готово Код просмотра обложек альбомов 
к употреблению
package headfirst.designpatterns.proxy.virtualproxy;
import java.net.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.util.*;
public class ImageProxyTestDrive {
 ImageComponent imageComponent;
 JFrame frame = new JFrame("Album Cover Viewer");
 JMenuBar menuBar;
 JMenu menu;
 Hashtable<String, String> albums = new Hashtable<String, String>();
 public static void main (String[] args) throws Exception {
 ImageProxyTestDrive testDrive = new ImageProxyTestDrive();
 }
 public ImageProxyTestDrive() throws Exception{
 albums.put("Buddha Bar","http://images.amazon.com/images/P/B00009XBYK.01.LZZZZZZZ.jpg");
 albums.put("Ima","http://images.amazon.com/images/P/B000005IRM.01.LZZZZZZZ.jpg");
 albums.put("Karma","http://images.amazon.com/images/P/B000005DCB.01.LZZZZZZZ.gif");
 albums.put("MCMXC a.D.","http://images.amazon.com/images/P/B000002URV.01.LZZZZZZZ.jpg");
 albums.put("Northern Exposure","http://images.amazon.com/images/P/B000003SFN.01.LZZZZZZZ.
jpg");
 albums.put("Selected Ambient Works, Vol. 2","http://images.amazon.com/images/P/
B000002MNZ.01.LZZZZZZZ.jpg");
 URL initialURL = new URL((String)albums.get("Selected Ambient Works, Vol. 2"));
 menuBar = new JMenuBar();
 menu = new JMenu("Favorite Albums");
 menuBar.add(menu);
510 глава 11
готовый код
Готово Код просмотра обложек альбомов (продолжение)
к употреблению
 frame.setJMenuBar(menuBar);
 for(Enumeration e = albums.keys(); e.hasMoreElements();) {
 String name = (String)e.nextElement();
 JMenuItem menuItem = new JMenuItem(name);
 menu.add(menuItem); 
 menuItem.addActionListener(event -> {
 imageComponent.setIcon(
 new ImageProxy(getAlbumUrl(event.getActionCommand())));
 frame.repaint();
 });
 }
 
 // Настройка фрейма и меню
 Icon icon = new ImageProxy(initialURL);
 imageComponent = new ImageComponent(icon);
 frame.getContentPane().add(imageComponent);
 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 frame.setSize(800,600);
 frame.setVisible(true);
 }
 URL getAlbumUrl(String name) {
 try {
 return new URL((String)albums.get(name));
 } catch (MalformedURLException e) {
 e.printStackTrace();
 return null;
 }
 }
}
паттерн заместитель
дальше   511
package headfirst.designpatterns.proxy.virtualproxy;
import java.net.*;
import java.awt.*;
import javax.swing.*;
class ImageProxy implements Icon {
 volatile ImageIcon imageIcon;
 final URL imageURL;
 Thread retrievalThread;
 boolean retrieving = false;
 
 public ImageProxy(URL url) { imageURL = url; }
 
 public int getIconWidth() {
 if (imageIcon != null) {
 return imageIcon.getIconWidth();
 } else {
 return 800;
 }
 }
 public int getIconHeight() {
 if (imageIcon != null) {
 return imageIcon.getIconHeight();
 } else {
 return 600;
 }
 }
 synchronized void setImageIcon(ImageIcon imageIcon) {
 this.imageIcon = imageIcon;
 }
 
 public void paintIcon(final Component c, Graphics g, int x, int y) {
 if (imageIcon != null) {
 imageIcon.paintIcon(c, g, x, y);
 } else {
 g.drawString("Loading album cover, please wait...", x+300, y+190);
 if (!retrieving) {
 retrieving = true;
512 глава 11
готовый код
Готово 
к употреблению
Код просмотра обложек альбомов (продолжение)
 retrievalThread = new Thread(new Runnable() {
 public void run() {
 try {
 setImageIcon(new ImageIcon(imageURL, "Album Cover"));
 c.repaint();
 } catch (Exception e) {
 e.printStackTrace();
 }
 }
 });
 retrievalThread.start();
 }
 }
 }
}
package headfirst.designpatterns.proxy.virtualproxy;
import java.awt.*;
import javax.swing.*;
class ImageComponent extends JComponent {
 private Icon icon;
 public ImageComponent(Icon icon) {
 this.icon = icon;
 }
 public void setIcon(Icon icon) {
 this.icon = icon;
 }
 public void paintComponent(Graphics g) {
 super.paintComponent(g);
 int w = icon.getIconWidth();
 int h = icon.getIconHeight();
 int x = (800 - w)/2;
 int y = (600 - h)/2;
 icon.paintIcon(this, g, x, y);
 }
}
Кто бы мог предположить, что паттерны порой работают рука об 
руку? Вы уже были свидетелями ожесточенных перепалок в «Беседах у камина» 
(причем вы не видели «Смертельные поединки» паттернов — редактор заставил 
нас исключить их из книги!). И после этого оказывается, что мирное сосуществование все же возможно. Хотите верьте, хотите нет, но некоторые из самых мощных 
ОО-архитектур строятся на основе комбинаций нескольких паттернов.
Паттерны
12 Составные паттерны
паттернов
514 глава 12
Совместная работа паттернов
Чтобы паттерны проявили себя в полной мере, не ограничивайте их 
жесткими рамками и позвольте им взаимодействовать с другими паттернами. Чем шире вы используете паттерны, тем больше вероятность их объединения в ваших архитектурах. Для таких комбинаций 
паттернов, применимых в разных задачах, существует специальный 
термин— составные паттерны. Да, именно так: речь идет о паттернах, 
составленных из других паттернов!
Составные паттерны очень часто применяются в реальном программировании. Теперь, когда основные паттерны твердо запечатлелись 
в вашей памяти, вы сразу увидите, что составные паттерны — всего 
лишь комбинация уже известных вам паттернов.
В начале этой главы мы вернемся к старому примеру с утками. Утки 
помогут вам понять, как паттерны объединяются в одном решении. 
Однако совмещение паттернов еще не означает, что решение может 
быть отнесено к категории составных паттернов, — для этого оно 
должно иметь общий характер и быть применимым для решения 
многих задач. Таким образом, во второй половине главы мы рассмотрим настоящий составной паттерн Модель-Представление-Контроллер, также известный как MVC. Если вы еще не слышали о нем, 
знайте: он станет одним из самых мощных составных паттернов в вашем инструментарии.
Паттерны часто используются вместе 
и комбинируются в реализациях 
проектировочных решений.
Составной паттерн объединяет два и более 
паттерна для решения распространенной 
или общей проблемы.
паттерны могут сотрудничать
составные паттерны
дальше   515
public interface Quackable {
 public void quack();
}
public class MallardDuck implements Quackable {
 public void quack() {
 System.out.println("Quack");
 }
}
Интерфейс Quackable 
состоит из единственного 
метода quack().
Стандартная 
утка-кряква 
(Mallard).
Чтобы программа 
получилась интересной, 
нужно добавить другие 
разновидности.
И снова утки
Как вы уже знаете, мы снова будем работать с утками. На этот раз они покажут вам, 
как паттерны могут сосуществовать — и даже сотрудничать — в одном решении.
Мы заново построим «утиную» программу и наделим ее интересными возможностями при помощи нескольких паттернов. Итак, за дело...
Напомним, что программа будет написана с нуля. На этот раз объекты 
Duck будут реализовывать интерфейс Quackable. От реализации этого 
интерфейса зависит поддержка метода quack() разными классами.
1 Начинаем с создания интерфейса Quackable.
Какой прок от интерфейса без реализующих его классов? Пора создать 
несколько конкретных разновидностей уток («газетные» не в счет).
Переходим к объектам Duck, реализующим Quackable.
public class RedheadDuck implements Quackable {
 public void quack() {
 System.out.println("Quack");
 }
}
2
516 глава 12
public class DuckSimulator {
 public static void main(String[] args) {
 DuckSimulator simulator = new DuckSimulator();
 simulator.simulate();
 }
 
 void simulate() {
 Quackable mallardDuck = new MallardDuck();
 Quackable redheadDuck = new RedheadDuck();
 Quackable duckCall = new DuckCall();
 Quackable rubberDuck = new RubberDuck();
 System.out.println("\nDuck Simulator");
 simulate(mallardDuck);
 simulate(redheadDuck);
 simulate(duckCall);
 simulate(rubberDuck);
 }
 
 void simulate(Quackable duck) {
 duck.quack();
 }
}
Создаем по одному 
экземпляру для каждой 
реализации Quackable...
...и запускаем имитацию для каждой из них.
Здесь мы полагаемся на волшебство полиморфизма: какая бы реализация Quackable ни была 
передана, simulate() вызовет ее метод quack().
Звук утиного манка 
несколько отличается от 
кряканья настоящей утки.
public class DuckCall implements Quackable {
 public void quack() {
 System.out.println("Kwak");
 }
}
Резиновая утка пищит 
вместо того, чтобы 
нормально крякать.
public class RubberDuck implements Quackable {
 public void quack() {
 System.out.println("Squeak");
 }
}
Помните предыдущую версию? В нее входили утиные манки DuckCall (те штуки, которыми 
пользуются охотники, — они определенно умеют крякать) и резиновые утки RubberDuck:
Но если все утки будут вести себя одинаково, программа получится неинтересной.
Напишем небольшую программу, которая создает нескольких уток и заставляет их крякать...
3 Утки есть, теперь нужен имитатор.
Метод main запускает 
имитатор.
Создаем объект 
и вызываем его 
метод simulate().
Перегруженная версия 
метода simulate 
имитирует одну утку.
добавление новых уток
составные паттерны
дальше   517
% java DuckSimulator
Duck Simulator
Quack
Quack
Kwak
Squeak
Пока не впечатляет, но мы 
File Edit Window Help ItBetterGetBetterThanThis
еще не добавили паттерны!
public class Goose {
 public void honk() {
 System.out.println("Honk");
 }
}
Гуси не крякают — 
вместо quack() они 
реализуют метод honk().
Класс Goose представляет другую водоплавающую птицу — гуся:
4 Там, где есть утки, найдется место и гусям.
Вроде все работает, идем дальше.
Все объекты реализуют один 
интерфейс Quackable, но каждый 
делает это по-своему.
Допустим, нужно, чтобы объект Goose мог использоваться везде, где могут использоваться объекты 
Duck. В конце концов, гуси тоже издают звуки, умеют летать и плавать. Так почему бы не включить 
их в программу?
Какой паттерн позволит легко смешать гусей с утками?
Мозговой
штурм
518 глава 12
Конструктор получает 
адаптируемый объект Goose.
Напоминаем: паттерн Адаптер реализует целевой интерфейс, которым в данном случае 
является Quackable.
Вызов quack() делегируется методу honk() класса Goose.
public class GooseAdapter implements Quackable {
 Goose goose;
 public GooseAdapter(Goose goose) {
 this.goose = goose;
 }
 public void quack() {
 goose.honk();
 }
}
public class DuckSimulator {
 public static void main(String[] args) {
 DuckSimulator simulator = new DuckSimulator();
 simulator.simulate();
 }
 void simulate() {
 Quackable mallardDuck = new MallardDuck();
 Quackable redheadDuck = new RedheadDuck();
 Quackable duckCall = new DuckCall();
 Quackable rubberDuck = new RubberDuck();
 Quackable gooseDuck = new GooseAdapter(new Goose());
 System.out.println("\nDuck Simulator: With Goose Adapter");
 simulate(mallardDuck);
 simulate(redheadDuck);
 simulate(duckCall);
 simulate(rubberDuck);
 simulate(gooseDuck);
 }
 void simulate(Quackable duck) {
 duck.quack();
 }
}
Создаем объект Goose, 
замаскированный 
под Duck; для этого 
Goose упаковывается 
в GooseAdapter.
С адаптированным объектом 
Goose можно работать как 
с обычным объектом Duck, 
реализующим Quackable.
Программа работает с реализациями Quackable. Поскольку гуси не поддерживают метод 
quack(), мы можем воспользоваться адаптером для превращения гуся в утку:
5 Нам понадобится адаптер.
Нужно лишь создать объект Goose, упаковать его в адаптер, реализующий Quackable, — 
и можно работать.
6 Теперь гуси тоже смогут участвовать в нашей имитации.
адаптер для гусей
составные паттерны
дальше   519
% java DuckSimulator
Duck Simulator: With Goose Adapter
Quack
Quack
Kwak
Squeak
Honk
File Edit Window Help GoldenEggs
Вызов honk()! Теперь 
объекты Goose издают звуки вместе 
с объектами Duck.
7 Пробный запуск...
 Утковедение
На этот раз список объектов, передаваемых методу 
simulate(), содержит объект Goose, упакованный в «утиный» 
адаптер. Результат? Мы видим вызовы honk()!
Ученые-утковеды в восторге от всех аспектов поведения Quackable. В частности, 
они всегда мечтали подсчитать общее количество кряков, издаваемых утиной 
стаей.
Как реализовать возможность подсчета без изменения классов уток?
Какой паттерн нам в этом поможет?
Дж. Брюэр, смотритель парка 
и знатный утковед.
520 глава 12
public class QuackCounter implements Quackable {
 Quackable duck;
 static int numberOfQuacks;
 
 public QuackCounter (Quackable duck) {
 this.duck = duck;
 }
 
 public void quack() {
 duck.quack();
 numberOfQuacks++;
 }
 public static int getQuacks() {
 return numberOfQuacks;
 }
}
8 Мы осчастливим этих утковедов и реализуем механизм подсчета. 
Как это сделать? Мы наделим уток новым поведением (подсчет), 
упаковывая их в объекте-декораторе. Изменять код Duck для этого не 
придется.
Как и в паттерне Адаптер, 
необходимо реализовать целевой 
интерфейс.
Переменная для хранения 
декорируемого объекта.
Для подсчета ВСЕХ кряков 
используется статическая 
переменная.
В конструкторе получаем ссылку на декорируемую реализацию 
Quackable.
Вызов quack() делегируется декорируемой 
реализации Quackable...
...после чего увеличиваем счетчик.
Декоратор дополняется статическим 
методом, который возвращает 
количество кряков во всех реализациях 
Quackable.
утиный декоратор
QuackCounter — 
декоратор.
составные паттерны
дальше   521
9 Обновляем программу, чтобы в ней создавались декорированные реализации Quackable.
Теперь каждый объект Quackable, экземпляр которого создается в программе, должен упаковываться в декоратор QuackCounter. Если этого не сделать, вызовы quack() не будут учитываться при подсчете.
public class DuckSimulator {
 public static void main(String[] args) {
 DuckSimulator simulator = new DuckSimulator();
 simulator.simulate();
 }
 void simulate() {
 Quackable mallardDuck = new QuackCounter(new MallardDuck());
 Quackable redheadDuck = new QuackCounter(new RedheadDuck());
 Quackable duckCall = new QuackCounter(new DuckCall());
 Quackable rubberDuck = new QuackCounter(new RubberDuck());
 Quackable gooseDuck = new GooseAdapter(new Goose());
 System.out.println("\nDuck Simulator: With Decorator");
 simulate(mallardDuck);
 simulate(redheadDuck);
 simulate(duckCall);
 simulate(rubberDuck);
 simulate(gooseDuck);
 System.out.println("The ducks quacked " + 
 QuackCounter.getQuacks() + " times");
 }
 void simulate(Quackable duck) {
 duck.quack();
 }
}
Вывод данных, собранных для утковедов.
Каждая вновь создаваемая 
реализация Quackable 
упаковывается в декоратор.
Результаты
% java DuckSimulator
Duck Simulator: With Decorator
Quack
Quack
Kwak
Squeak
Honk
4 quacks were counted
%
File Edit Window Help DecoratedEggs
Ничего не изменилось: декорированные 
объекты остаются реализациями Quackable.
Гусиные крики ученых не нтересуют, поэтому объекты Goose
не декорируются.
Напоминаем, что 
гусиные крики не 
подсчитываются.
522 глава 12
Этот ваш счетчик 
кряков — отличная штука. Мы 
получили ценные научные данные. 
Но мы видим, что многие кряки 
остались неподсчитанными. 
Поможете?
10 Нужна фабрика для производства уток!
Мы должны позаботиться о том, чтобы все утки обязательно были упакованы в декоратор. Для создания декорированных уток будет построена 
целая фабрика! Она должна производить целое семейство продуктов, 
состоящее из разных утиных разновидностей, поэтому мы воспользуемся паттерном Абстрактная Фабрика.
Начнем с определения AbstractDuckFactory:
Основная проблема с упаковкой объектов: при использовании недекорированного объекта вы лишаетесь декорированного поведения.
Так почему бы не объединить операции создания 
экземпляров с декорированием, инкапсулируя их 
в специальном методе? 
Не напоминает ли это вам какой-нибудь паттерн?
public abstract class AbstractDuckFactory {
 public abstract Quackable createMallardDuck();
 public abstract Quackable createRedheadDuck();
 public abstract Quackable createDuckCall();
 public abstract Quackable createRubberDuck();
}
Мы определяем абстрактную фабрику, которая 
будет реализовываться 
субклассами для создания 
разных продуктов.
Каждый метод создает одну 
из разновидностей уток.
Декорированное поведение 
обеспечивается только для 
декорированных объектов.
утиная фабрика
составные паттерны
дальше   523
public class DuckFactory extends AbstractDuckFactory {
 
 public Quackable createMallardDuck() {
 return new MallardDuck();
 }
 
 public Quackable createRedheadDuck() {
 return new RedheadDuck();
 }
 
 public Quackable createDuckCall() {
 return new DuckCall();
 }
 
 public Quackable createRubberDuck() {
 return new RubberDuck();
 }
}
public class CountingDuckFactory extends AbstractDuckFactory {
 
 public Quackable createMallardDuck() {
 return new QuackCounter(new MallardDuck());
 }
 
 public Quackable createRedheadDuck() {
 return new QuackCounter(new RedheadDuck());
 }
 
 public Quackable createDuckCall() {
 return new QuackCounter(new DuckCall());
 }
 
 public Quackable createRubberDuck() {
 return new QuackCounter(new RubberDuck());
 }
}
Первая версия фабрики создает уток без декораторов — просто для 
того, чтобы вы лучше усвоили, как работает фабрика:
А теперь перейдем к той фабрике с декораторами, которая нам нужна:
DuckFactory расширяет 
абстрактную фабрику.
Каждый метод создает продукт — 
конкретную разновидность утки. 
Программа не знает фактический 
класс создаваемого продукта — ей 
известно лишь то, что создается 
реализация Quackable.
CountingDuckFactory 
также расширяет класс 
абстрактной фабрики. 
Каждый метод упаковывает Quackable в декоратор. Программа 
этого не замечает: она 
получает то, что ей 
нужно, то есть реализацию Quackable. Но теперь ученые могут быть 
твердо уверены в том, 
что каждый кряк будет 
подсчитан.
524 глава 12
public class DuckSimulator {
 public static void main(String[] args) {
 DuckSimulator simulator = new DuckSimulator();
 AbstractDuckFactory duckFactory = new CountingDuckFactory();
 simulator.simulate(duckFactory);
 }
 void simulate(AbstractDuckFactory duckFactory) {
 Quackable mallardDuck = duckFactory.createMallardDuck();
 Quackable redheadDuck = duckFactory.createRedheadDuck();
 Quackable duckCall = duckFactory.createDuckCall();
 Quackable rubberDuck = duckFactory.createRubberDuck();
 Quackable gooseDuck = new GooseAdapter(new Goose());
 System.out.println("\nDuck Simulator: With Abstract Factory");
 simulate(mallardDuck);
 simulate(redheadDuck);
 simulate(duckCall);
 simulate(rubberDuck);
 simulate(gooseDuck);
 System.out.println("The ducks quacked " + 
 QuackCounter.getQuacks() + 
 " times");
 }
 void simulate(Quackable duck) {
 duck.quack();
 }
}
11 Переведем имитатор на использование фабрики.
Помните, как работает паттерн Абстрактная Фабрика? Мы создаем полиморфный метод, который получает фабрику и использует ее для создания объектов. Передавая разные фабрики, мы можем создавать разные 
семейства продуктов в одном методе.
Новая версия метода simulate() получает фабрику и использует ее для 
создания уток.
Сначала создаем 
фабрику, которая 
будет передаваться 
методу simulate(). 
Метод simulate() получает AbstractDuckFactory 
и использует фабрику 
для создания уток (вместо непосредственного 
создания экземпляров).
Здесь ничего 
не изменилось!
семейства уток
составные паттерны
дальше   525
То же, что в предыдущей 
версии, но на этот раз 
каждая утка заведомо 
декорируется, потому 
что мы используем 
CountingDuckFactory.
% java DuckSimulator
Duck Simulator: With Abstract Factory
Quack
Quack
Kwak
Squeak
Honk
4 quacks were counted
%
File Edit Window Help EggFactory
Однако экземпляры гусей по-прежнему создаются непосредственно, 
а код зависит от конкретных классов. Удастся ли вам написать абстрактную фабрику для гусей? Как она должна создавать «гусей, замаскированных под уток»?
Результат с использованием фабрики...
Возьми в руку карандаш
526 глава 12
 Quackable mallardDuck = duckFactory.createMallardDuck();
 Quackable redheadDuck = duckFactory.createRedheadDuck();
 Quackable duckCall = duckFactory.createDuckCall();
 Quackable rubberDuck = duckFactory.createRubberDuck();
 Quackable gooseDuck = new GooseAdapter(new Goose());
 simulate(mallardDuck);
 simulate(redheadDuck);
 simulate(duckCall);
 simulate(rubberDuck);
 simulate(gooseDuck);
Управлять разными 
утками по отдельности слишком 
хлопотно. Нельзя ли выполнять 
операции со всеми утками сразу 
или даже выделить несколько 
утиных «семейств», которые 
отслеживаются отдельно 
от других?
Хороший вопрос: а почему мы работаем с разными утками по отдельности?
Не очень-то 
удобно!
Необходим механизм создания коллекций 
уток, и даже субколлекций (раз уж заказчик 
говорит о «семействах»). Также было бы желательно иметь возможность применять операции ко всему множеству уток.
Какой паттерн нам в этом поможет?
Теперь он хочет управлять 
утиными стаями.
утиные стаи
составные паттерны
дальше   527
12 Создаем утиную стаю (а точнее, стаю реализаций Quackable).
Помните паттерн Компоновщик — тот, что позволял интерпретировать 
коллекцию объектов как отдельный объект? Применим его к реализациям Quackable!
Вот как это делается:
public class Flock implements Quackable {
 ArrayList<Quackable> quackers = new ArrayList<Quackable>();
 public void add(Quackable quacker) {
 quackers.add(quacker);
 }
 public void quack() {
 Iterator<Quackable> iterator = quackers.iterator();
 while (iterator.hasNext()) {
 Quackable quacker = iterator.next();
 quacker.quack();
 }
 }
}
Комбинация должна реализовать тот же 
интерфейс, что и листовые элементы 
(Quackable в нашем примере).
Каждая стая (Flock) содержит 
ArrayList для хранения реализаций 
Quackable, входящих в эту стаю.
Метод add() включает 
реализацию Quackable 
в Flock.
Теперь метод quack() — в конце концов, Flock тоже 
является реализацией Quackable. Метод quack() для 
объекта Flock должен применяться ко всем уткам стаи. 
Мы перебираем элементы ArrayList и вызываем quack() 
для каждого элемента.
 public void quack() {
 Iterator<Quackable> iterator = quackers.iterator();
 while (iterator.hasNext()) {
 Quackable quacker = iterator.next();
 quacker.quack();
 }
 }
Вот он!
Паттерн Итератор!
Код под увеличительным стеклом
А вы заметили, что мы тайком подсунули вам еще один паттерн, ни словом не упомянув 
о нем?
528 глава 12
13 Теперь нужно изменить программу.
Осталось добавить немного кода, чтобы утки вписывались 
в новую структуру.
public class DuckSimulator {
 // Метод main
 void simulate(AbstractDuckFactory duckFactory) {
 Quackable redheadDuck = duckFactory.createRedheadDuck();
 Quackable duckCall = duckFactory.createDuckCall();
 Quackable rubberDuck = duckFactory.createRubberDuck();
 Quackable gooseDuck = new GooseAdapter(new Goose());
 System.out.println("\nDuck Simulator: With Composite — Flocks");
 Flock flockOfDucks = new Flock();
 flockOfDucks.add(redheadDuck);
 flockOfDucks.add(duckCall);
 flockOfDucks.add(rubberDuck);
 flockOfDucks.add(gooseDuck);
 Flock flockOfMallards = new Flock();
 Quackable mallardOne = duckFactory.createMallardDuck();
 Quackable mallardTwo = duckFactory.createMallardDuck();
 Quackable mallardThree = duckFactory.createMallardDuck();
 Quackable mallardFour = duckFactory.createMallardDuck();
 flockOfMallards.add(mallardOne);
 flockOfMallards.add(mallardTwo);
 flockOfMallards.add(mallardThree);
 flockOfMallards.add(mallardFour);
 flockOfDucks.add(flockOfMallards);
 System.out.println("\nDuck Simulator: Whole Flock Simulation");
 simulate(flockOfDucks);
 System.out.println("\nDuck Simulator: Mallard Flock Simulation");
 simulate(flockOfMallards);
 System.out.println("\nThe ducks quacked " + 
 QuackCounter.getQuacks() + 
 " times");
 }
 void simulate(Quackable duck) {
 duck.quack();
 }
}
Создание реализаций 
Quackables
(как и прежде).
Создаем объект Flock и заполняем 
его реализациями Quackable.
Создаем несколько 
объектов...
Затем создаем новый объект 
Flock, предназначенный только 
для крякв (MallardDuck).
...и добавляем их в контейнер Flock.
А теперь стая крякв 
добавляется в основную стаю.
Сначала тестируем всю стаю!
А теперь — только стаю крякв.
Данные для утковедов.
Ничего менять не нужно — Flock является реализацией Quackable!
утиные комбинации
составные паттерны
дальше   529
Запускаем...
% java DuckSimulator
Duck Simulator: With Composite — Flocks
Duck Simulator: Whole Flock Simulation
Quack
Kwak
Squeak
Honk
Quack
Quack
Quack
Quack
Duck Simulator: Mallard Flock Simulation
Quack
Quack
Quack
Quack
The ducks quacked 11 times
File Edit Window Help FlockADuck
Первый объект Flock.
Второй объект Flock.
Вроде все хорошо 
(помните: гуси 
не в счет!)
Безопасность и прозрачность
Возможно, вы помните, что в главе, посвященной паттерну Компоновщик, листовые 
узлы (MenuItem) и комбинации (Menu) имели совпадающие наборы методов. Из-за 
этого для MenuItem могли вызываться методы, не имеющие смысла (например, метод 
add()). Преимуществом такого подхода была прозрачность: клиенту не нужно было 
знать, имеет ли он дело с листом или комбинацией, — он просто вызывал одни и те 
же методы в обеих ситуациях.
Здесь мы решили отделить методы комбинаций, относящиеся к управлению дочерними элементами, от листовых узлов: другими словами, только объекты Flock содержат 
метод add(). Мы знаем, что вызов add() для Duck не имеет смысла и в данной реализации он невозможен. Метод add() может вызываться только для Flock. Такая архитектура обладает большей безопасностью (клиент не сможет вызывать для компонентов 
бессмысленные методы), но она менее прозрачна. 
В ходе ОО-проектирования часто приходится принимать компромиссные решения. 
Учитывайте их при проектировании своих архитектур.
530 глава 12
14 Сначала определяем интерфейс наблюдаемого объекта.
Напомним, что интерфейс наблюдаемого объекта содержит методы регистрации и оповещения наблюдателей. Присвоим ему более запоминающееся имя — как насчет Observable? Также можно включить в него метод 
удаления наблюдателей, но мы опустим его, чтобы по возможности упростить реализацию.
Паттерн Компоновщик 
отлично работает! Теперь у 
нас другая просьба: мы хотим 
наблюдать за отдельными утками. 
Как нам получать информацию 
о них в реальном времени?
Похоже, наш знакомый хочет наблюдать за поведением 
отдельных уток. Этот путь ведет нас прямиком к паттерну, 
предназначенному для наблюдения за поведением объектов. Конечно, речь идет о паттерне Наблюдатель.
public interface QuackObservable {
 public void registerObserver(Observer observer);
 public void notifyObservers();
}
public interface Quackable extends QuackObservable {
 public void quack();
}
Чтобы за Quackable можно было наблюдать, они должны реализовать 
интерфейс QuackObservable.
Также имеется метод 
оповещения наблюдателей.
Метод регистрации наблюдателей. Любой объект, реализующий 
интерфейс Observer, сможет 
получать оповещения. Определение интерфейса Observer приводится ниже.
Проследите за тем, чтобы интерфейс был реализован всеми Quackable...
Таким образом, интерфейс 
Quackable расширяет 
QuackObservable.
«Наблюдать», говорите?
наблюдение за утками
составные паттерны
дальше   531
public class Observable implements QuackObservable {
 List<Observer> observers = new ArrayList<Observer>();
 QuackObservable duck;
 public Observable(QuackObservable duck) {
 this.duck = duck;
 }
 
 public void registerObserver(Observer observer) {
 observers.add(observer);
 }
 
 public void notifyObservers() {
 Iterator iterator = observers.iterator();
 while (iterator.hasNext()) {
 Observer observer = iterator.next();
 observer.update(duck);
 }
 }
}
15 Теперь нужно позаботиться о том, чтобы все конкретные классы, реализующие Quackable, могли использоваться в качестве QuackObservable.
Задачу можно решить, реализуя регистрацию и оповещение в каждом классе (как было сделано в главе 2). На этот 
раз мы поступим немного иначе: инкапсулируем код регистрации и оповещения в другом классе — Observable — 
и объединим его с QuackObservable. В этом случае реальный код пишется только один раз, а в QuackObservable 
достаточно включить код делегирования вызовов вспомогательному классу Observable.
Начнем со вспомогательного класса Observable...
Хватит следить 
за мной. Ты меня 
раздражаешь!
Observable реализует всю 
функциональность, необходимую 
Quackable для наблюдения.
QuackObserverable
Конструктору передается объект 
QuackObservable, который используется им для 
управления наблюдением. 
Посмотрите на приведенный ниже метод 
notify(): при оповещении Observable передает 
этот объект, чтобы 
наблюдатель знал, в каком объекте произошло 
наблюдаемое событие.
Код регистрации
наблюдателя.
Код оповещения.
Посмотрим, как Quackable использует 
этот вспомогательный класс...
Класс Observable должен реализовать 
QuackObservable.
532 глава 12
public class MallardDuck implements Quackable {
 Observable observable;
 public MallardDuck() {
 observable = new Observable(this);
 }
 public void quack() {
 System.out.println("Quack");
 notifyObservers();
 }
 public void registerObserver(Observer observer) {
 observable.registerObserver(observer);
 }
 public void notifyObservers() {
 observable.notifyObservers();
 }
}
16 Интеграция вспомогательного класса Observable с классами Quackable.
Задача не такая уж сложная. Все, что нужно, — это позаботиться о том, чтобы 
классы Quackable содержали комбинированные объекты Observable и умели 
делегировать им операции. После этого они готовы к использованию в качестве Observable. Ниже приводится реализация MallardDuck; остальные классы 
выглядят аналогично.
Каждая реализация Quackable 
содержит объект Observable.
В конструкторе создаем объект 
Observable и передаем ему ссылку 
на объект MallardDuck.
Наблюдатели оповещаются о вызовах quack().
Два метода QuackObservable. 
Обратите внимание на делегирование 
операций вспомогательному объекту.
Мы еще не изменили реализацию декоратора QuackCounter. Его тоже необходимо интегрировать с Observable. Почему бы вам не сделать это самостоятельно?
интеграция классов
Возьми в руку карандаш
составные паттерны
дальше   533
public interface Observer {
 public void update(QuackObservable duck);
}
public class Quackologist implements Observer {
 public void update(QuackObservable duck) {
 System.out.println("Quackologist: " + duck + " just quacked.");
 }
}
17 Работа почти завершена! Осталось разобраться с кодом на стороне Observer.
Мы реализовали все необходимое для наблюдаемых объектов; 
теперь нужны наблюдатели. Начнем с интерфейса Observer:
Интерфейс Observer состоит 
из единственного метода update(), 
которому передается реализация 
QuackObservable.
Теперь нужен наблюдатель:
Класс наблюдателя прост: 
единственный метод update() 
выводит информацию о
Quackable, от которой поступило 
реализации 
оповещение.
Наблюдатель должен реализовать 
интерфейс Observer, иначе его не удастся 
зарегистрировать с QuackObservable.
534 глава 12
А если наблюдатель захочет понаблюдать за целой стаей? Как вообще это следует понимать? Понимайте так: наблюдение за комбинацией означает наблюдение за каждым ее элементом. Таким образом, при регистрации комбинация 
Flock должна позаботиться о регистрации всех своих дочерних элементов, среди которых могут быть другие комбинации.
Прежде чем двигаться дальше, напишите код наблюдения для Flock...
flock как observable
Возьми в руку карандаш
составные паттерны
дальше   535
public class DuckSimulator {
 public static void main(String[] args) {
 DuckSimulator simulator = new DuckSimulator();
 AbstractDuckFactory duckFactory = new CountingDuckFactory();
 simulator.simulate(duckFactory);
 }
 
 void simulate(AbstractDuckFactory duckFactory) {
 
 // Создание фабрик и объектов Duck
 // Создание объектов Flock
 System.out.println("\nDuck Simulator: With Observer");
 Quackologist quackologist = new Quackologist();
 flockOfDucks.registerObserver(quackologist);
 simulate(flockOfDucks);
 System.out.println("\nThe ducks quacked " + 
 QuackCounter.getQuacks() + 
 " times");
 }
 void simulate(Quackable duck) {
 duck.quack();
 }
}
18 Все готово к наблюдению. Давайте обновим 
программу и опробуем ее в деле:
Создаем объект 
Quackologist и назначаем его наблюдателем для Flock.
Смотрим, что же получилось!
На этот раз simulate() 
выполняется для Flock.
536 глава 12
Приближается грандиозный финал. Пять... нет, шесть паттернов объединились для создания потрясающего имитатора утиного пруда!
File Edit Window Help DucksAreEverywhere
% java DuckSimulator
Duck Simulator: With Observer
Quack
Quackologist: Redhead Duck just quacked.
Kwak
Quackologist: Duck Call just quacked.
Squeak
Quackologist: Rubber Duck just quacked.
Honk
Quackologist: Goose pretending to be a Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
Quack
Quackologist: Mallard Duck just quacked.
The Ducks quacked 7 times.
После каждого 
вызова quack() 
(независимо от 
его реализации!) 
наблюдатель 
получает оповещение.
В: Так это был составной паттерн?
О: Нет, это был простой пример совместного использования паттернов. Составной 
паттерн представляет собой набор паттернов, объединенных для решения типичной 
задачи. Например, рассматриваемый ниже 
паттерн Модель-Представление-Контроллер снова и снова используется во многих 
проектировочных решениях.
В: Выходит, я беру задачу и начинаю 
применять к ней паттерны, пока не приду к решению. Верно?
О: Неверно. Мы привели этот пример, 
чтобы показать, что паттерны могут использоваться совместно. Никогда не следуйте нашему примеру при проектировании. В некоторых аспектах архитектуры 
нашего примера применение паттернов 
было явным перебором. Иногда задача 
решается простым соблюдением принципов 
ОО-проектирования.
Мы подробнее поговорим на эту тему в следующей главе, но паттерны следует применять только тогда, когда это оправданно. 
Не старайтесь применять паттерны только 
ради того, чтобы они присутствовали в вашей архитектуре.
Наблюдатель получает правильные 
данные.
грандиозный финал
часто Задаваемые вопросы
составные паттерны
дальше   537
Что мы сделали?
Мы начали с реализаций Quackable...
Сначала потребовалось, чтобы класс Goose тоже мог использоваться в качестве Quackable. Мы воспользовались паттерном Адаптер, чтобы преобразовать Goose в Quackable.
Затем было решено, что вызовы quack() должны подсчитываться. Мы воспользовались паттерном Декоратор и добавили декоратор QuackCounter.
Но клиент мог забыть добавить декоратор QuackCounter к объекту. Мы воспользовались паттерном Абстрактная Фабрика для создания экземпляров. Теперь 
каждый раз, когда клиент хотел создать объект Duck, он запрашивал его у фабрики и получал объект вместе с декоратором (а если ему нужен был объект без декоратора — использовал другую фабрику).
У нас возникли проблемы управления многочисленными объектами Duck, 
Goose и Quackable. Мы воспользовались паттерном Компоновщик для группировки объектов в коллекции. Паттерн также позволяет создавать субколлекции 
для управления подмножествами объектов. В нашей реализации также был задействован паттерн Итератор (мы воспользовались итератором ArrayList из пакета 
java.util).
Наконец, потребовалось организовать оповещение клиента о вызовах quack(). Мы воспользовались паттерном Наблюдатель, чтобы объекты 
Quackologist могли регистрироваться в качестве наблюдателей Quackable. В этой 
реализации тоже был применен паттерн Итератор. Следует отметить, что паттерн Наблюдатель может применяться не только к отдельным объектам, но 
и к комбинациям.
Разминка получилась весьма 
основательной. Изучите диаграмму 
классов на следующей странице 
и немного отдохните, прежде чем 
переходить к паттерну МодельПредставление-Контроллер.
538 глава 12
DuckSimulator
createMallardDuck()
createRedheadDuck()
createDuckCall()
createRubberDuck()
AbstractDuckFactory
createMallardDuck()
createRedheadDuck()
createDuckCall()
createRubberDuck()
DuckFactory
createMallardDuck()
createRedheadDuck()
createDuckCall()
createRubberDuck()
CountingDuckFactory
update(QuackObservable)
<<interface>> 
Observer
update(QuackObservable)
Quackologist
Диаграмма классов с высоты птичьего утиного полета
DuckSimulator использует фабрику 
для создания объектов Duck. 
Две разные фабрики производят продукты одного 
семейства: DuckFactory 
создает объекты Duck, 
а CountingDuckFactory — 
объекты Duck, упакованные в декораторы 
QuackCounter. 
Если класс реализует Observer, 
это означает, 
что он наблюдает за Quackable 
и будет получать 
оповещения о вызовах quack().
В одной маленькой программе поместилось много паттернов! Общая картина того, 
что было сделано:
диаграмма классов
Мы реализуем только одну 
разновидность наблюдателей 
для Quackable — Quackologist. 
Но любой класс, реализующий 
интерфейс Observer, может 
стать Наблюдателем.
составные паттерны
дальше   539
registerObserver(Observer)
notifyObservers()
<<interface>> 
QuackObservable
quack()
<<interface>> 
Quackable
quack()
registerObserver(Observer)
notifyObservers()
MallardDuck
quack()
registerObserver(Observer)
notifyObservers()
RedheadDuck
quack()
registerObserver(Observer)
notifyObservers()
DuckCall
registerObserver(Observer)
notifyObservers()
Observable
ArrayList observers
QuackObservable duck
quack()
registerObserver(Observer)
notifyObservers()
GooseAdapter
Goose goose
add(Quackable)
quack()
registerObserver(Observer)
notifyObservers()
Flock
ArrayList ducks
getQuacks()
quack()
registerObserver(Observer)
notifyObservers()
QuackCounter
Quackable duck
quack()
registerObserver(Observer)
notifyObservers()
RubberDuck
Интерфейс QuackObservable 
предоставляет набор методов, 
которые должны быть реализованы 
любым объектом Observable.
Мы имеем дело 
с двумя разновидностями Quackable: 
Duck и другие объекты, желающие 
обладать поведением Quackable, — 
как, например, 
GooseAdapter, Flock 
и QuackCounter.
Интерфейс 
Quackable должен 
быть реализован 
всеми классами, 
реализующими 
поведение quack().
Каждая реализация 
Quackable содержит 
экземпляр Observable; 
с его помощью она 
отслеживает своих наблюдателей и оповещает их о вызовах quack().
Этот
адаптер...
...и эта 
комбинация...
...и этот 
декоратор — 
все они работают как 
Quackable!
540 глава 12
А что вы там говорили 
о паттерне Модель-ПредставлениеКонтроллер? Я пыталась изучать 
его ранее, но у меня только 
разболелась голова 
от напряжения.
У вас уже был неудачный опыт использования 
паттерна Модель-Представление-Контроллер 
(MVC)? Вы не одиноки. Возможно, вы слышали 
от других программистов, что этот паттерн изменил их жизнь и что он помогает обрести внутреннюю гармонию. Безусловно, это мощный 
составной паттерн, и хотя внутренней гармонии мы не гарантируем, после освоения он сэкономит вам немало времени.
Но сначала его нужно освоить, верно? Однако 
на этот раз сделать это будет значительно проще, потому что вы знаете паттерны!
Да, паттерны — ключ к MVC. Осваивать MVC 
«сверху вниз» сложно; лишь немногие программисты справляются с этой задачей. Вы должны 
понять главный секрет изучения MVC: это всего 
лишь комбинация нескольких паттернов. Если при 
изучении паттерна MVC вы обращаете внимание на составляющие его паттерны, все внезапно встает на свои места.
Приступаем к делу. На этот раз MVC от вас не 
уйдет!
Паттерны проектирования — ключ к MVC
MVC как комбинация паттернов
составные паттерны
дальше   541
Знакомьтесь! Паттерн Модель-Представление-Контроллер
Представление Контроллер
Вы работаете 
с интерфейсом, 
а ваши действия 
передаются контроллеру.
Модель
Представьте, что вы используете свой любимый MP3-проигрыватель (скажем, iTunes). Интерфейс 
программы используется для добавления новых песен, управления списками воспроизведения и переименования. Проигрыватель ведет небольшую базу данных с названиями и информацией о песнях. 
Кроме того, он воспроизводит их, причем в ходе воспроизведения пользовательский интерфейс постоянно обновляется: в нем выводится название текущей песни, позиция воспроизведения и т. д.
А в основе этой модели заложен паттерн Модель-Представление-Контроллер...
Контроллер выполняет операции 
с моделью
Модель оповещает представление 
об изменении 
состояния.
представление 
обновляется 
автоматически
«Воспроизвести 
песню»
Контроллер 
приказывает 
модели 
(Player) начать 
воспроизведение 
песни.
Вы видите, как обновляется информация о песне 
(название, текущие данные), и слышите, как она 
воспроизводится.
Модель содержит всю информацию состояния, данные и логику приложения, необходимые 
для ведения базы данных и воспроизведения MP3-файлов.
class Player {
 play(){}
 rip(){}
 burn(){}
}
 
542 глава 12
Модель
Контроллер
КОНТРОЛЛЕР
Получает данные, вводимые 
пользователем, и определяет 
их смысл для модели. МОДЕЛЬ
Модель хранит все данные, 
информацию состояния 
и логику приложения. Она 
не знает о существовании 
представления и контроллера, хотя и предоставляет 
интерфейс для получения/изменения состояния, 
а также может отправлять 
оповещения об изменениях 
состояния наблюдателям.
ПРЕДСТАВЛЕНИЕ
Определяет представление 
модели. Как правило, представление получает состояние 
и данные для отображения непосредственно от модели.
Присмотримся повнимательнее...
2
Я изменилась!
Мне нужна твоя 
информация
состояния
Пользователь 
что-то сделал
Изменить 
изображение
Изменить 
состояние
3
1
4
5
Пользовательский 
интерфейс
Модель 
обеспечивает 
работу 
с данными 
и логикой 
приложения.
Контроллер 
находится 
в середине.
Описание MP3-проигрывателя в общих чертах демонстрирует работу MVC, но оно совершенно не объясняет все технические тонкости работы и построения составного 
паттерна и того, зачем он вообще нужен. Начнем с анализа отношений между моделью, представлением и контроллером, а затем рассмотрим эту архитектуру в контексте паттернов проектирования.
class Player {
 play(){}
 rip(){}
 burn(){}
}
 
подробнее о mvc
Представление
составные паттерны
дальше   543
Представление — «окно», через которое пользователь воспринимает модель. Когда вы делаете что-то с представлением (скажем, щелкаете на кнопке воспроизведения), представление 
сообщает контроллеру, какая операция была выполнена. Контроллер должен обработать это 
действие.
1 Пользователь взаимодействует с моделью.
Контроллер получает действия пользователя и интерпретирует их. Если вы щелкаете на 
кнопке, контроллер должен разобраться, что это значит и какие операции с моделью должны 
быть выполнены при данном действии.
2 Контроллер обращается к модели с запросами об изменении состояния.
Когда контроллер получает действие от представления, в результате его обработки он может обратиться к представлению с запросом на изменение (скажем, заблокировать некоторые 
кнопки или команды меню).
3 Контроллер также может обратиться к представлению с запросом об изменении.
Когда в модели что-то изменяется (вследствие действий пользователя или других внутренних изменений — скажем, перехода к следующей песне в списке), модель оповещает представление об изменении состояния.
4 Модель оповещает представление об изменении состояния.
Представление получает отображаемую информацию состояния непосредственно от модели. 
Например, когда модель оповещает представление о начале воспроизведения новой песни, 
представление запрашивает название песни и отображает его. Представление также может 
запросить у модели информацию состояния в результате запроса на изменение состояния со 
стороны контроллера.
5 Представление запрашивает у модели информацию состояния.
В: Контроллер бывает наблюдателем 
для модели?
О: Конечно. В некоторых архитектурах контроллер регистрируется у модели 
и оповещается о ее изменениях — например, если какие-либо аспекты модели напрямую влияют на пользовательский интерфейс (скажем, в некоторых состояниях 
модели отдельные элементы интерфейса 
могут блокироваться).
В: Выходит, задача контроллера сводится к получению пользовательского
ввода в представлении и передаче его 
модели? Так почему бы не разместить 
соответствующий код прямо в представлении? Ведь обычно работа контроллера сводится к вызову метода 
модели?
О: Функции контроллера не сводятся 
к передаче данных модели. Контроллер отвечает за интерпретацию ввода и выполнение соответствующих операций с моделью.
Почему нельзя «сделать все в коде представления»? Можно, но не стоит по двум 
причинам. Во-первых, это усложнит код 
представления — у него появятся две обязанности: управление пользовательским 
интерфейсом и логика управления моделью. Во-вторых, между представлением 
и моделью формируется жесткая привязка. О повторном использовании кода 
представления с другой моделью можно 
забыть. Логическая изоляция представления и контроллера способствует формированию более гибкой и расширяемой 
архитектуры, которая лучше адаптируется 
к возможным изменениям.
часто Задаваемые вопросы
544 глава 12
MVC как набор паттернов
Как мы уже говорили, MVC лучше всего изучать как совокупность паттернов, работающих совместно 
в одной архитектуре.
Начнем с модели. Как вы, возможно, догадались, модель использует паттерн Наблюдатель для оповещения представлений и контроллеров об изменениях состояния. С другой стороны, представление 
и контроллер реализуют паттерн Стратегия. Контроллер определяет стратегию представления и может быть легко заменен другим контроллером при необходимости смены поведения. Само представление тоже использует внутренний паттерн Компоновщик для управления окнами, кнопками и другими 
компонентами изображения.
Присмотримся повнимательнее:
Изображение состоит из вложенных окон, 
панелей, кнопок, надписей и т. д. Каждый 
компонент является комбинацией (окно) или 
листом (кнопка). Когда контроллер приказывает 
представлению обновиться, он обращается 
к верхнему компоненту, а паттерн Компоновщик 
делает все остальное.
Модель реализует паттерн Наблюдатель для 
оповещения заинтересованных объектов об 
изменениях состояния. Паттерн Наблюдатель 
обеспечивает полную независимость модели от 
представлений и контроллеров. Он позволяет 
использовать разные представления с одной 
моделью или даже несколько представлений 
одновременно.
Модель
Контроллер
Я изменилась!
Мне нужна твоя 
информация состояния
Пользователь 
что-то сделал
Изменить 
изображение
Изменить 
состояние
Стратегия
Наблюдатель
Компоновщик
Представление и контроллер реализуют классический паттерн 
Стратегия. Представление — объект со сменной стратегией, 
контроллер эту стратегию предоставляет. Представление интересуют 
только визуальные аспекты приложения, а все решения относительно 
поведения интерфейса делегируются контроллеру. Применение 
паттерна Стратегия также сохраняет логическую изоляцию 
представления от модели, потому что все взаимодействия с моделью 
для выполнения пользовательских запросов осуществляются 
контроллером. Представлению о них ничего не известно.
class Player {
 play(){}
 rip(){}
 burn(){}
}
 
паттерны в mvc
Представление
составные паттерны
дальше   545
Представление
Модель
class Foo {
 void bar() 
{
 doBar();
 }
}
 
Представление
Контроллер
Представление
Представление
Наблюдатель
Observable
Хочу 
зарегистрироваться 
для наблюдения
Мое 
состояние 
изменилось!
Наблюдатель
Контроллер
Представление
Стратегия
Контроллер
Пользователь 
что-то сделал
Компоновщик
Все эти наблюдатели 
будут оповещаться 
об изменениях состояния модели.
Любой объект, 
интересующийся 
изменениями состояния модели, 
регистрируется 
у модели в качестве наблюдателя.
Контроллер является объектом 
стратегии для представления — 
объектом, который умеет 
обрабатывать действия пользователя.
Чтобы переключить пред
ставление на другое пове
-
дение, достаточно сменить 
-
контроллер.
Представление 
делегирует кон
троллеру обра
-
-
ботку действий 
пользователя.
Представление является комбинацией компонентов GUI 
(надписи, кнопки, текстовые 
поля и т. д.). Компонент верхнего уровня содержит другие 
компоненты, которые содержат другие компоненты,
и так далее вплоть до листовых узлов.
paint()
Модель не связана зависимостями с представлениями или контроллерами!
Представление занимается только 
отображением данных, а контроллер преобразует 
пользовательский ввод в операции с моделью.
546 глава 12
Использование MVC для управления ритмом...
Для диджея главное — это ритм. Вы начинаете свой микс с медленных 
95 ударов в минуту (BPM), а потом доводите толпу до бешеного технотранса на 140 BPM. Серия должна завершаться спокойным эмбиент-миксом на 80 BPM.
Как это сделать? Разумеется, нам придется создать специальные инструменты для управления ритмом.
Представление состоит из двух 
частей: для просмотра состояния 
модели и для управления им.
Увеличивает 
частоту на 1 удар 
в минуту.
Уменьшает частоту 
на 1 удар в минуту.
Пользователь либо вводит 
конкретное значение и щелкает 
на кнопке Set, либо использует 
кнопки увеличения и уменьшения 
для более точной регулировки.
Пульсирующая полоска отображает ритм 
в реальном времени.
Индикатор текущей частоты; 
автоматически обновляется 
при ее изменении.
Представление для диджея
Начнем с представления нашего нового инструмента. Оно 
позволяет создать заводной ритм и задать количество ударов в минуту...
mvc для диджея
составные паттерны
дальше   547
И не забывайте о модели, которая лежит в основе...
Модель не видна, но хорошо слышна. Она лежит 
в основе всего происходящего, управляя ритмом 
и динамиками через интерфейс MIDI.
BeatModel
setBPM()
getBPM()
on()
off()
Ритм может 
запускаться 
командой Start 
меню «DJ 
Control».
Кнопка Stop 
доступна только 
после запуска 
ритма.
Кнопка Stop 
прекращает 
генерирование 
ритма.
Кнопка Start 
блокируется 
после запуска.
Контроллер находится в середине...
Контроллер
Все действия 
пользователя 
передаются 
контроллеру.
Контроллер находится между представлением и моделью. Он получает ввод от 
пользователя (скажем, выбор команды 
Start) и преобразует его в действие с моделью (запуск ритма). Контроллер получает 
данные от пользователя и решает, как 
преобразовать их в запросы к модели.
Модель BeatModel — «сердце» 
приложения. Она реализует 
логику запуска и остановки 
ритма, задает частоту (BPM) 
и генерирует звук.
Еще несколько способов управления 
представлением для диджеев...
Модель также позволяет получить 
информацию о текущем состоянии 
методом getBPM().
548 глава 12
BeatModel
Контроллер
setBPM()
getBPM()
on()
off()
Щелкните на 
кнопке увеличения...
Контроллер 
приказывает 
модели увеличить 
частоту на 1.
Представление оповещается 
об изменении частоты. Оно 
вызывает метод getBPM() 
для получения состояния модели.
Так как установлена частота 
120 BPM, представление 
получает оповещения каждые 
1/2 секунды.
Генерируется ритм 
с частотой 119 BPM; вы 
хотите увеличить его до 120.
...это приводит к активизации 
контроллера.
Представление обновляется 
новым значением 120 BPM.
Полоса пульсирует 
каждые 1/2 секунды.
Представление
Представление
Все вместе
модель, представление и контроллер
составные паттерны
дальше   549
Построение компонентов
public interface BeatModelInterface {
 void initialize();
 
 void on();
 
 void off();
 
 void setBPM(int bpm);
 
 int getBPM();
 
 void registerObserver(BeatObserver o);
 
 void removeObserver(BeatObserver o);
 
 void registerObserver(BPMObserver o);
 
 void removeObserver(BPMObserver o);
}
Методы, 
используемые 
контроллером 
для управления 
моделью на 
основании действий 
пользователя.
Методы, при помощи которых представление и контроллер получают 
информацию состояния и изменяют 
свой статус наблюдателя.
Выглядит знакомо: 
методы регистрации 
объектов для оповещения 
об изменениях состояния.
Наблюдатели делятся на две группы: 
те, которые должны оповещаться 
о каждом ударе, и те, которые должны 
оповещаться только об изменениях 
частоты.
Итак, модель отвечает за хранение всех данных, информации состояния и логики приложения. Что будет 
хранить конкретная модель BeatModel? Ее главная задача — управление ритмом, поэтому в ней должны 
храниться текущая частота и код, генерирующий события MIDI для создания того ритма, который мы 
слышим. Кроме того, модель предоставляет интерфейс, через который контроллер управляет ритмом, 
и предоставляет представлению и контроллеру возможность получения состояния модели. А поскольку 
модель использует паттерн Наблюдатель, также понадобятся методы для регистрации объектов и отправки оповещений.
Вызывается после создания 
экземпляра BeatModel.
Методы запуска и остановки 
генератора ритма.
Метод задает частоту ритма 
(удары в минуту). Частота 
изменяется сразу же после его 
вызова.
Метод getBPM() возвращает 
текущую частоту или 0, 
если генератор отключен.
Прежде чем обращаться к реализации, рассмотрим
интерфейс BeatModelInterface:
550 глава 12
Модель использует 
аудиоклип для генерирования ритма. Полную 
реализацию всех классов 
DJ вы найдете в исходных классах Java на сайте 
wickedlysmart.com или 
в конце главы.
модель генератора ритма
Готово 
к употреблению
public class BeatModel implements BeatModelInterface, Runnable {
 List<BeatObserver> beatObservers = new ArrayList<BeatObserver>();
 List<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();
 int bpm = 90;
 Thread thread;
 boolean stop = false;
 Clip clip;
 public void initialize() {
 try {
 File resource = new File("clap.wav");
 clip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));
 clip.open(AudioSystem.getAudioInputStream(resource));
 }
 catch(Exception ex) { /* ... */}
 }
 public void on() {
 bpm = 90;
 notifyBPMObservers();
 thread = new Thread(this);
 stop = false;
 thread.start();
 }
 public void off() {
 stopBeat();
 stop = true;
 }
 public void run() {
 while (!stop) {
 playBeat();
 notifyBeatObservers();
 try {
 Thread.sleep(60000/getBPM());
 } catch (Exception e) {}
 }
 }
 public void setBPM(int bpm) {
 this.bpm = bpm;
 notifyBPMObservers();
 }
 public int getBPM() {
 return bpm;
 }
 // Код регистрации и оповещения наблюдателей
 // Код управления частотой
}
Перед вами конкретный класс BeatModel: Реализуем 
BeatModelInterface 
и Runnable.
Аудиоклип, который будет 
воспроизводиться.
Списки для двух разновидностей 
наблюдателей (BeatObserver 
и BPMObserver.)
В переменной bpm хранится частота 
ритма – по умолчанию 90 BPM.
Метод готовит 
воспроизведение 
ритмической 
дорожки.
Метод on() назначает частоту по умолчанию 
и запускает поток для воспроизведения ритма.
А метод off() обнуляет ритм и останавливает 
поток, воспроизводящий ритм.
Метод setBPM() используется 
контроллером для управления 
ритмом. Он задает переменную bpm и уведомляет всех наблюдателей BPM об изменении 
частоты.
Используются для запуска 
и остановки потока ритма.
Метод getBPM() просто 
возвращает текущую 
частоту ритма.
Метод run() запускает ритмический 
поток, воспроизводит ритм, определяемый 
величиной BPM, и уведомляет наблюдателей 
о воспроизведении ритма. Цикл завершается 
при выборе команды Stop в меню.
составные паттерны
дальше   551
Представление
А теперь начинается самое интересное: мы подключим представление и обеспечим визуальное отображение BeatModel!
Первая важная особенность нашего представления заключается в том, что оно отображается в двух разных окнах. Одно окно содержит текущую частоту и индикатор ударов, а в другом отображаются элементы 
управления. Почему мы выбрали такое решение? Потому, что хотели подчеркнуть разницу между интерфейсом, обеспечивающим отображение модели, и средствами управления. Давайте получше присмотримся к двум составляющим представления:
Мы отделили визуальное представление модели от 
Представление средств управления.
разделено на 
два аспекта 
BeatModel...
...текущая частота, 
полученная из 
оповещений 
BPMObserver...
...и индикатор, пульсирующий синхронно с ритмом и находящийся под 
управлением BeatObserver.
Бегущая строка с названием музыкального жанра в зависимости 
от частоты (эмбиент, техно и т. д.).
Наша модель BeatModel никак не зависит от представления. Она реализуется на базе паттерна 
Наблюдатель: любое представление, зарегистрированное в качестве наблюдателя, просто оповещается об изменении состояний. Представление работает с состоянием через API. Мы реализовали одно из возможных представлений; можете ли вы предложить другие представления, 
использующие оповещения и состояние BeatModel?
Световое шоу, управляемое ритмом в реальном времени.
Часть представления, которая 
используется для управления 
ритмом. Все выполняемые 
операции передаются 
контроллеру.
Мозговой
штурм
552 глава 12
Реализация представления
Две части нашего представления — визуальная информация модели и элементы управления — отображаются в разных окнах, но находятся в одном 
классе Java. Сначала мы рассмотрим код создания 
визуального представления, в котором выводится 
текущая частота и индикатор ударов. На следующей странице будет представлен код создания 
элементов управления: текстового поля для ввода 
частоты и кнопок.
public class DJView implements ActionListener, BeatObserver, BPMObserver {
 BeatModelInterface model;
 ControllerInterface controller;
 JFrame viewFrame;
 JPanel viewPanel;
 BeatBar beatBar;
 JLabel bpmOutputLabel;
 
 public DJView(ControllerInterface controller, BeatModelInterface model) { 
 this.controller = controller;
 this.model = model;
 model.registerObserver((BeatObserver)this);
 model.registerObserver((BPMObserver)this);
 }
 
 public void createView() {
 // Create all Swing components here
 }
 
 public void updateBPM() {
 int bpm = model.getBPM();
 if (bpm == 0) {
 bpmOutputLabel.setText("offline");
 } else {
 bpmOutputLabel.setText("Current BPM: " + model.getBPM());
 }
 }
 
 public void updateBeat() {
 beatBar.setValue(100);
 }
}
DJView — наблюдатель для событий обоих видов
(удары в реальном времени и изменения частоты).
Создание отображаемых компонентов.
В представлении хранятся ссылки на модель и на контроллер. Контроллер используется только управляющими элементами, до которых мы скоро доберемся...
Конструктор получает ссылки 
на контроллер и модель и 
сохраняет их в переменных.
Представление регистрируется 
в качестве наблюдателя BeatObserver 
и BPMObserver модели.
Метод updateBPM() вызывается при изменении 
состояния модели. Изображение обновляется 
текущим значением частоты, которое 
запрашивается непосредственно у модели.
Метод updateBeat() вызывается в начале нового удара. 
Когда это происходит, необходимо отобразить импульс 
на «индикаторе ритма». Для этого индикатору 
присваивается максимально возможное значение (100).
Код на этих двух 
страницах разделен 
условно!
Мы разбили ОДИН класс 
на ДВА; одна часть приведена на этой странице, 
а другая — на следующей. В действительности 
весь код находится в ОДНОМ классе DJView.java. 
Полный листинг приведен в конце главы.
представление для диджея
 Будьте осторожны!
составные паттерны
дальше   553
Реализация представления (продолжение)
Переходим к коду управляющего интерфейса представления. Это представление позволяет управлять моделью: вы сообщаете контроллеру, что необходимо сделать, а он, в свою очередь, указывает модели, что 
ей делать. Еще раз напомним, что этот код находится в том же файле класса, что и код другой части представления.
public class DJView implements ActionListener, BeatObserver, BPMObserver {
 BeatModelInterface model;
 ControllerInterface controller;
 JLabel bpmLabel;
 JTextField bpmTextField;
 JButton setBPMButton;
 JButton increaseBPMButton;
 JButton decreaseBPMButton;
 JMenuBar menuBar;
 JMenu menu;
 JMenuItem startMenuItem;
 JMenuItem stopMenuItem;
 
 public void createControls() {
 // Здесь создаются все компоненты Swing
 }
 public void enableStopMenuItem() {
 stopMenuItem.setEnabled(true);
 }
 public void disableStopMenuItem() {
 stopMenuItem.setEnabled(false);
 }
 public void enableStartMenuItem() {
 startMenuItem.setEnabled(true);
 }
 public void disableStartMenuItem() {
 startMenuItem.setEnabled(false);
 }
 public void actionPerformed(ActionEvent event) {
 if (event.getSource() == setBPMButton) {
 int bpm = Integer.parseInt(bpmTextField.getText());
 controller.setBPM(bpm);
 } else if (event.getSource() == increaseBPMButton) {
 controller.increaseBPM();
 } else if (event.getSource() == decreaseBPMButton) {
 controller.decreaseBPM();
 }
 }
}
Методы установления и снятия блокиров
ки команд меню Start и Stop. Как будет 
-
вскоре показано, контроллер использует 
эти методы для управления интерфейсом.
Метод создает все элементы управления 
и размещает их в интерфейсе приложе
ния, а также создает меню. При выборе 
-
команды Start или Stop вызываются со
ответствующие методы контроллера.
-
Метод вызывается при щелчке на кнопке.
Если выбрана кнопка Set, 
действие передается контроллеру вместе с новой 
частотой.
Если выбрана кнопка увеличения или уменьшения 
частоты, эта информация также передается 
контроллеру.
554 глава 12
А теперь --- контроллер
Осталось написать последний отсутствующий компонент: контроллер. Напомним, что контроллер представляет собой объект стратегии, который подключается к представлению для управления действиями последнего.
Как обычно, реализация паттерна Стратегия начинается с определения интерфейса, реализации которого могут подключаться к представлению. Мы назовем его ControllerInterface:
public interface ControllerInterface {
 void start();
 void stop();
 void increaseBPM();
 void decreaseBPM();
 void setBPM(int bpm);
}
Методы контроллера, которые 
могут вызываться представлением.
После изучения визуального интерфейса модели эти методы выглядят знакомо. Они выполняют те же 
операции: запуск и остановка ритма, 
изменение частоты. Этот интерфейс «шире» интерфейса BeatModel, 
потому что в нем присутствует 
возможность увеличения и уменьшения частоты.
Представление и контроллер совместно используют паттерн Стратегия. Можете ли вы 
нарисовать для них диаграмму классов, представляющую этот паттерн?
Головоломка
контроллер для диджея
составные паттерны
дальше   555
public class BeatController implements ControllerInterface {
 BeatModelInterface model;
 DJView view;
 
 public BeatController(BeatModelInterface model) {
 this.model = model;
 view = new DJView(this, model);
 view.createView();
 view.createControls();
 view.disableStopMenuItem();
 view.enableStartMenuItem();
 model.initialize();
 }
 
 public void start() {
 model.on();
 view.disableStartMenuItem();
 view.enableStopMenuItem();
 }
 
 public void stop() {
 model.off();
 view.disableStopMenuItem();
 view.enableStartMenuItem();
 }
 
 public void increaseBPM() {
 int bpm = model.getBPM();
 model.setBPM(bpm + 1);
 }
 
 public void decreaseBPM() {
 int bpm = model.getBPM();
 model.setBPM(bpm — 1);
 }
 
 public void setBPM(int bpm) {
 model.setBPM(bpm);
 }
}
Реализация контроллера:
Контроллер реализует 
ControllerInterface.
Контроллер получает объекты 
модели и представления 
и связывает их воедино.
Контроллер получает модель в конструкторе и создает представление.
И наоборот, при выборе команды контроллер деактивизирует модель, команда Start 
становится доступной, а команда Stop
блокируется.
При выборе команды Start контроллер активизирует модель и изменяет пользовательский 
интерфейс: команда Start блокируется, 
а команда Stop становится доступной.
ВНИМАНИЕ: все 
разумные решения за 
представление принимает контроллер. 
Представление умеет 
только устанавливать и снимать блокировку команд меню; 
оно не знает, в каких 
ситуациях это следует делать.
При щелчке на кнопке увеличения 
контроллер получает текущую 
частоту от модели, увеличивает ее на 1 и задает результат 
как новое значение частоты.
То же самое, только частота уменьшается на 1.
Наконец, если пользователь 
ввел произвольную частоту, 
контроллер приказывает 
модели перейти на новое 
значение.
556 глава 12
Объединяем все компоненты...
У нас есть все необходимое: модель, представление и контроллер. Пора объединить их в архитектуру MVC и посмотреть (а также услышать), как эти компоненты работают в сочетании друг с другом.
Также необходимо написать небольшой фрагмент тестового кода; это не
займет много времени:
public class DJTestDrive {
 public static void main (String[] args) {
 BeatModelInterface model = new BeatModel();
 ControllerInterface controller = new BeatController(model);
 }
}
Сначала создается модель...
...затем создаем контроллер и передаем ему модель. Напомним, что 
представление создается контроллером, поэтому нам это делать 
не нужно. А теперь тестовый запуск...
% java DJTestDrive
%
File Edit Window Help LetTheBassKick
Введите эту 
команду...
...и вы получите такой 
результат:
Запустите генератор ритма командой 
меню Start. Обратите внимание на то, что 
контроллер блокирует эту команду.
Измените частоту при помощи элементов 
управления. Обратите внимание: изменения отражаются в визуальном 
представлении, хотя логически оно никак не связано с элементами.
Индикатор постоянно синхронизируется с ритмом, потому что он 
зарегистрирован в качестве наблюдателя модели.
Включите свою любимую песню и попробуйте подогнать ритм при 
помощи кнопок увеличения и уменьшения.
Остановите генератор. Обратите внимание: контроллер блокирует 
команду Stop и снимает блокировку с команды Start.
Что нужно сделать
5
4
3
2
1
все вместе
Не забудьте поместить файл 
clip.wav на верхний уровень папок 
с кодом!
составные паттерны
дальше   557
Анализ паттерна Стратегия
Давайте чуть подробнее разберемся в том, как паттерн 
Стратегия используется в архитектуре MVC. На этом пути 
нам встретится другой полезный паттерн, часто участвующий в трио MVC: паттерн Адаптер.
Итак, наше представление выводит частоту ритма и содержит индикатор текущего удара. Вам это ничего не напоминает? Например, ритм биения сердца? У нас совершенно 
случайно под рукой оказался класс для получения данных 
о сердечной деятельности; вот как выглядит его диаграмма 
классов:
getHeartRate()
registerBeatObserver()
registerBPMObserver()
// Другие методы
HeartModel
Метод для получения текущей 
частоты сердцебиений.
К счастью, его разработчики знали 
о существовании интерфейсов BeatObserver 
и BPMObserver!
Конечно, было бы удобно использовать текущее представление с HeartModel, но нам понадобится контроллер, работающий с этой моделью. Кроме того, интерфейс HeartModel не соответствует этому представлению — он содержит метод getHeartRate() вместо метода getBPM(). 
Как спроектировать классы, которые позволяли бы использовать представление с новой моделью?
Мозговой
штурм
558 глава 12
Адаптация модели
Прежде всего заметим, что HeartModel необходимо адаптировать к BeatModel. Если этого 
не сделать, то представление не сможет работать с моделью, потому что модель работает 
только с getBPM(), а эквивалентный метод HeartModel называется getHeartRate(). Как это 
сделать? Конечно, мы воспользуемся паттерном Адаптер! Адаптация модели к существующим контроллерам и представлениям является стандартным приемом при работе с MVC.
Код адаптера, преобразующего HeartModel к BeatModel:
public class HeartAdapter implements BeatModelInterface {
 HeartModelInterface heart;
 public HeartAdapter(HeartModelInterface heart) {
 this.heart = heart;
 }
 public void initialize() {}
 
 public void on() {}
 
 public void off() {}
 
 public int getBPM() {
 return heart.getHeartRate();
 }
 
 public void setBPM(int bpm) {}
 
 public void registerObserver(BeatObserver o) {
 heart.registerObserver(o);
 }
 
 public void removeObserver(BeatObserver o) {
 heart.removeObserver(o);
 }
 
 public void registerObserver(BPMObserver o) {
 heart.registerObserver(o);
 }
 
 public void removeObserver(BPMObserver o) {
 heart.removeObserver(o);
 }
}
Необходимо реализовать целевой 
интерфейс BeatModelInterface.
Сохранение ссылки 
на HeartModel.
Оставляем эти методы пустыми.
Вызов getBPM() преобразуется в вызов 
getHeartRate() модели HeartModel.
Еще одна пустая операция.
Вызовы методов наблюдателя делегируются встроенному объекту 
HeartModel.
mvc и адаптер
составные паттерны
дальше   559
Можно переходить к HeartController
Располагая адаптером HeartAdapter, мы можем создать контроллер и организовать работу представления с HeartModel. Повторное использование 
кода в действии!
public class HeartController implements ControllerInterface {
 HeartModelInterface model;
 DJView view;
 
 public HeartController(HeartModelInterface model) {
 this.model = model;
 view = new DJView(this, new HeartAdapter(model));
 view.createView();
 view.createControls();
 view.disableStopMenuItem();
 view.disableStartMenuItem();
 }
 
 public void start() {}
 public void stop() {}
 
 public void increaseBPM() {}
 
 public void decreaseBPM() {}
 
 public void setBPM(int bpm) {}
}
HeartController реализует 
ControllerInterface (по аналогии с классом BeatController).
Как и прежде, контроллер создает представление 
и связывает все компоненты.
Изменение: передается 
HeartModel, а не BeatModel...
...и до передачи представлению модель 
должна быть упакована в адаптер.
Пустые операции; в отличие от генератора 
ритма, сердцем невозможно управлять 
напрямую.
Вот и все! Переходим к написанию тестового кода...
public class HeartTestDrive {
 public static void main (String[] args) {
 HeartModel heartModel = new HeartModel();
 ControllerInterface model = new HeartController(heartModel);
 }
}
Создаем контроллер и передаем ему 
HeartModel.
HeartController блокирует ненужные команды 
меню.
560 глава 12
% java HeartTestDrive
%
File Edit Window Help CheckMyPulse
Введите эту 
команду...
...и вот что вы 
увидите:
Представление отлично работает с новой моделью! Так 
как HeartModel поддерживает BPM- и BeatObserver, на 
индикаторе ударов успешно отображается пульс. 
В частоте биения сердца имеются естественные 
отклонения, поэтому датчик периодически обновляется 
новым значением.
При каждом обновлении частоты адаптер преобразует 
вызовы getBPM() в вызовы getHeartRate().
Команды меню Start и Stop недоступны, потому что они 
блокируются контроллером.
Другие кнопки работают, но щелчки на них ни к чему не 
приводят, потому что контроллер не реализует операции 
этих кнопок. Представление можно было бы изменить, 
чтобы этот факт был отражен визуально.
Что нужно сделать
Тестовый запуск
5
4
3
2
1
Нормальный 
здоровый пульс
тестирование HeartModel
составные паттерны
дальше   561
В: Вы так усиленно убеждаете нас, 
что паттерн Компоновщик на самом деле 
присутствует в MVC... А он точно здесь 
есть?
О: Да, паттерн Компоновщик присутствует 
в MVC. Но на самом деле это очень хороший 
вопрос. Современные GUI-пакеты, такие как 
Swing, стали настолько сложными, что мы 
уже не видим их внутренней структуры и 
роли комбинаций в построении и обновлении изображения. Комбинации еще труднее 
разглядеть при использовании браузеров, 
которые получают язык разметки и преобразуют его в пользовательский интерфейс.
В те времена, когда архитектура MVC была 
открыта впервые, создание графического 
интерфейса требовало значительной ручной работы, а роль паттерна была более 
очевидной.
В: Контроллер реализует хоть какуюнибудь прикладную логику?
О: Нет, контроллер реализует поведение представления. Именно он решает 
задачу преобразования действий с представлением в действия с моделью. Модель 
получает эти действия и реализует прикладную логику для принятия решения о 
том, как следует поступить в ответ на эти 
действия. Возможно, контроллеру придется проделать некую работу для определения того, какой метод модели следует 
вызвать, но это к «прикладной логике» не 
относится. Прикладной логикой называется код управления и обработки данных, 
и этот код находится в модели.
В: Вы часто упоминали состояние модели. Означает ли это, что в архитектуре 
MVC задействован паттерн Состояние?
О: Нет, мы говорили о состоянии вообще. Но конечно, некоторые модели используют паттерн Состояние для управления 
своим внутренним состоянием.
В: Я видел описания MVC, в которых 
контроллер назывался «посредником» 
между представлением и моделью. Контроллер реализует паттерн Посредник?
О: Паттерн Посредник в книге еще не 
рассматривался (хотя его краткое описание приведено в приложении), поэтому 
сейчас мы не будем углубляться в подробности, но паттерн Посредник предназначен для инкаписуляции взаимодействий 
между объектами и устранения жестких 
связей, обусловленных явными ссылками 
объектов друг на друга. Таким образом, 
контроллер в определенной степени может 
рассматриваться как посредник, так как 
представление никогда не задает состояние непосредственно в модели, а всегда 
действует через контроллер. Однако следует помнить, что представление хранит 
ссылку на модель для получения информации состояния. Если бы контроллер был 
полноценным посредником, то представлению пришлось бы обращаться к контроллеру и за информацией состояния модели.
В: Представление всегда должно обращаться к модели за информацией состояния? Почему бы не использовать 
модель активной передачи и не отправлять состояние модели с оповещениями 
об обновлениях?
О: Да, безусловно, модель может отправлять свое состояние с оповещениями, 
и мы могли бы сделать нечто подобное с 
BeatModel, отправляя только состояние, 
в котором заинтересовано представление. 
Но если вы еще помните главу, посвященную паттерну Наблюдатель, то поймете, 
что именно это мы и делаем. Вся модель 
передается в форме объекта JavaBean, который используется представлением для 
обращения к состоянию. Нечто похожее 
можно было сделать и с BeatModel. Однако 
в главе 2 упоминалась пара недостатков 
такого подхода. Если вы забыли, о чем 
идет речь, — вернитесь и посмотрите еще 
раз. Модель MVC была адаптирована для 
ряда похожих моделей (в частности, для 
среды «браузер/сервер»), так что у этого 
правила существует немало исключений.
В: Если в архитектуре задействовано 
несколько представлений, всегда ли в 
ней должно использоваться несколько 
контроллеров?
О: Как правило, во время выполнения 
для каждого представления создается 
один контроллер; тем не менее один класс 
контроллера может легко обслуживать сразу несколько представлений.
В: Представление не должно напрямую 
манипулировать с моделью; однако я заметил, что в вашей реализации представлению полностью доступны методы, изменяющие состояние модели. Разве это 
не опасно?
О: Вы правы; мы предоставили представлению полный доступ к набору методов 
модели. Мы сделали это для простоты, но 
возможны ситуации, в которых для представления должна быть доступна только 
небольшая часть API модели. Существует 
превосходный паттерн проектирования, который позволяет адаптировать интерфейс 
и ограничить доступ к нему небольшим 
подмножеством. А вы догадываетесь, о каком паттерне идет речь?
часто Задаваемые вопросы
562 глава 12
ваш инструментарий проектирования
Да!
Паттерн MVC настолько полезен, что он был адаптирован для многих веб-фреймворков. Конечно, веб-среда отличается от ваших 
стандартных приложений, поэтому существует несколько разных 
подходов к применению паттерна «MVC» в веб-приложениях.
У веб-приложений есть клиентская сторона (браузер) и серверная 
сторона. С учетом этого факта можно выбирать разные компромиссные решения в зависимости от того, где находится модель, представление и контроллер. В решениях, построенных по принципу 
тонкого клиента, модель, большая часть представления и контроллер размещаются на сервере, а браузер предоставляет средства отображения представления и передачи входных данных от браузера 
контроллеру. Другой подход ориентирован на построение одностраничных приложений, в которых почти все модели, представление 
и контроллер располагаются на стороне клиента. Это две разные 
границы спектра, и вам будут встречаться фреймворки, в которых 
каждый из компонентов — модель, представление, контроллер — в 
разной степени размещаются на стороне клиента или сервера. Также встречаются гибридные модели, где некоторые компоненты совместно используются клиентом и сервером.
Существует много популярных веб-фреймворков на базе MVC: 
Spring Web MVC, Django, ASP.NET MVC, AngularJS, EmberJS, 
JavaScriptMVC, Backbone… несомненно, появятся и другие. В основном каждый фреймворк выбирает свой неповторимый способ 
распределения модели, представления и контроллера между клиентом и сервером. Теперь, когда вы освоили паттерн «MVC», вы легко 
сможете «адаптировать» свои знания для выбранного вами фреймворка.
Почти все мои 
пользовательские 
интерфейсы предназначены 
для браузера. Мне все это 
вообще пригодится?
составные паттерны
дальше   563
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Концепции
Новые инструменты
К этому моменту ваш инструментарий достиг впечатляющих размеров. Только посмотрите, сколько 
в нем всевозможных принципов и паттернов!
Стратегия — определяет семейство алгоритмов, инкапсулирует 
и обеспечивает их взаимозаменяемость. Паттерн позволяет модифицировать алгоритмы 
независимо от их использования на стороне клиента.
Паттерны
Observer — defines 
a one-to-many 
dependency between 
objects so that when 
one object changes state, 
all its dependents are 
notified and updated 
automatically
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a 
flexible alternative to 
subclassing for extending 
functionality.
Abstract Factory — 
Provide an interface 
for creating families 
of related or depedent 
objects without 
specifying their concrete 
classes.
Factory Method — 
Define an interface for 
creating an object, but 
let subclasses decide 
which class to instantiate. 
Factory Method lets a 
class defer instantiation 
to the subclasses.
Singleton — Ensure 
a class only has one 
instance and provide a 
global point of access to 
it.
Command — 
Encapsulates a request 
as an object, thereby 
letting you parameterize 
clients with different 
requests, queue or log 
requests, and support 
undoable operations.
  Паттерн Модель-Представление-Контроллер (MVC) — составной паттерн, состоящий 
из паттернов Наблюдатель, 
Стратегия и Компоновщик.
  Модель использует паттерн Наблюдатель, чтобы наблюдатели оповещались об изменениях 
состояния, без формирования 
сильных связей.
  Контроллер определяет 
стратегию для представления. 
Представление может использовать разные реализации 
контроллера для обеспечения 
разного поведения.
  Представление использует 
паттерн Компоновщик для 
реализации пользовательского 
интерфейса, который обычно 
состоит из иерархии компонентов (панели, кнопки и т. д.).
  Совместная работа паттернов 
обеспечивает слабую связанность всех трех компонентов 
модели MVC, благодаря чему 
архитектура сохраняет гибкость 
и четкость.
  Паттерн MVC был адаптирован 
для веб-среды.
  Существует много вебфреймворков MVC, по-разному 
адаптирующих паттерн MVC 
в соответствии со структурой 
приложений «клиент/сервер».
Adapter — 
Encapsulates a request 
as an object, thereby 
letting you parameterize 
clients with different 
requests, queue or log 
requests, and support 
undoable operations.
Facade — Encapsulates 
a request as an object, 
thereby letting you 
parameterize clients 
with different requests, 
queue or log requests, 
and support undoable 
operations.
Новая категория! 
MVC и Модель 2 
являются составными паттернами. State — Allow an object to alter its behavior 
when its internal state 
changes. The object will 
appear to change its 
class.
Принципы
Заместитель предоставляет 
суррогатный объект, управляющий 
доступом к другому объекту.
Составной паттерн объединяет два и более базовых 
паттерна в решении типичной или общей задачи.
Составные 
паттерны
Инкапсулируйте то, что изменяется.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты 
для расширения, но закрыты для 
изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Взаимодействуйте только 
с «друзьями».
Не вызывайте нас — мы вас 
сами вызовем.
Класс должен иметь только 
одну причину для изменений.
КЛЮЧЕВЫЕ 
МОМЕНТЫ
564 глава 12
ответы к упражнениям
QuackCounter также реализует Quackable. Когда мы изменяем Quackable, 
расширяя QuackObservable, нам придется изменить каждый класс, реализующий Quackable, в том числе и QuackCounter:
public class QuackCounter implements Quackable {
 Quackable duck;
 static int numberOfQuacks;
 
 public QuackCounter(Quackable duck) {
 this.duck = duck;
 }
 
 public void quack() {
 duck.quack();
 numberOfQuacks++;
 }
 public static int getQuacks() {
 return numberOfQuacks;
 }
 public void registerObserver(Observer observer) {
 duck.registerObserver(observer);
 }
 public void notifyObservers() {
 duck.notifyObservers();
 }
}
QuackCounter реализует 
Quackable, так что теперь он также реализует 
и QuackObservable.
Весь этот код 
остается таким 
же, как в предыдущей версии 
QuackCounter.
Объект Duck, 
декорируемый 
QuackCounter.
Два метода 
QuackObservable. 
Оба вызова просто делегируются декорируемому объекту 
Duck.
Возьми в руку карандаш
 Решение
составные паттерны
дальше   565
public class Flock implements Quackable {
 List<Quackable> quackers = new ArrayList<Quackable>();
 
 public void add(Quackable duck) {
 ducks.add(duck);
 }
 
 public void quack() {
 Iterator<Quackable> iterator = quackers.iterator();
 while (iterator.hasNext()) {
 Quackable duck = iterator.next();
 duck.quack();
 }
 }
 
 public void registerObserver(Observer observer) {
 Iterator<Quackable> iterator = ducks.iterator();
 while (iterator.hasNext()) {
 Quackable duck = iterator.next();
 duck.registerObserver(observer);
 }
 }
 
 public void notifyObservers() { }
 
}
Класс Flock реализует Quackable, поэтому 
теперь он также реализует QuackObservable.
Объекты Quackable, 
входящие в контейнер 
Flock.
При регистрации Flock как 
наблюдателя автоматически регистрируется все, 
что содержится во Flock, 
то есть все реализации 
Quackable, будь то Duck
или другой объект Flock.
Перебираем все реализации Quackables в Flock 
и делегируем вызов каждому объекту. Если реализация Quackable представляет собой Flock, то 
же самое происходит на 
следующем уровне. Каждая реализация Quackable 
выполняет оповещение 
самостоятельно, поэтому Flock ничего 
делать не придется.
А если наблюдатель захочет понаблюдать за целой стаей? Как вообще это следует понимать? Понимайте так: наблюдение за комбинацией означает наблюдение за каждым
ее элементом. Таким образом, при регистрации комбинация Flock должна позаботиться 
о регистрации всех своих дочерних элементов, среди которых могут быть другие комбинации.
Возьми в руку карандаш
 Решение
566 глава 12
ответы к упражнениям
Головоломка
setBPM()
increaseBPM()
decreaseBPM()
<<interface>> 
ControllerInterface
createView()
updateBPM()
updateBeat()
createControls()
enableStopMenuItem()
disableStopMenuItem()
enableStartMenuItem()
disableStartMenuItem()
actionPerformed()
DJView
controller
setBPM()
increaseBPM()
decreaseBPM()
Controller
Интерфейс 
ControllerInterface 
(интерфейс 
стратегии) 
реализуется всеми 
конкретными 
контроллерами.
Подключая различные контроллеры, мы 
реализуем разные 
варианты поведения 
представления.
Представление 
делегирует контроллеру управление моделью на 
основании пользовательского ввода.
Можно включить в существующую фабрику метод createGooseDuck(). 
А можно создать отдельную фабрику для Goose. 
Однако экземпляры гусей по-прежнему создаются непосредственно, а код 
зависит от конкретных классов. Удастся ли вам написать абстрактную фабрику 
для гусей? Как она должна создавать «гусей, замаскированных под уток»?
Представление и контроллер совместно используют паттерн Стратегия. Можете ли вы 
нарисовать для них диаграмму классов, представляющую этот паттерн?
Возьми в руку карандаш
 Решение
Решение
составные паттерны
дальше   567
Далее приводится полная реализация DJView. В ней представлен весь MIDI-код, необходимый для генерирования 
звука, а также все компоненты Swing для создания представления. Этот код также можно загрузить на сайте 
http://www.wickedlysmart.com.
package headfirst.designpatterns.combined.djview;
 
public class DJTestDrive {
 public static void main (String[] args) {
 BeatModelInterface model = new BeatModel();
 ControllerInterface controller = new BeatController(model);
 }
}
package headfirst.designpatterns.combined.djview;
 
public interface BeatModelInterface {
 void initialize();
 
 void on();
 
 void off();
 
 void setBPM(int bpm);
 
 int getBPM();
 
 void registerObserver(BeatObserver o);
 
 void removeObserver(BeatObserver o);
 
 void registerObserver(BPMObserver o);
 
 void removeObserver(BPMObserver o);
}
BeatModel
Готово 
к употреблению
568 глава 12
готовый код: модель
package headfirst.designpatterns.combined.djview;
import java.util.*;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import java.io.*;
import javax.sound.sampled.Line;
public class BeatModel implements BeatModelInterface, Runnable {
List<BeatObserver> beatObservers = new ArrayList<BeatObserver>();
List<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();
int bpm = 90;
Thread thread;
boolean stop = false;
Clip clip;
public void initialize() {
 try {
 File resource = new File("clap.wav");
 clip = (Clip) AudioSystem.getLine(new Line.Info(Clip.class));
 clip.open(AudioSystem.getAudioInputStream(resource));
 }
 catch(Exception ex) {
 System.out.println("Error: Can’t load clip");
 System.out.println(ex);
 }
}
public void on() {
 bpm = 90;
 notifyBPMObservers();
 thread = new Thread(this);
 stop = false;
 thread.start();
}
public void off() {
 stopBeat();
 stop = true;
}
составные паттерны
дальше   569
Готово 
к употреблению
public void run() {
 while (!stop) {
 playBeat();
 notifyBeatObservers();
 try {
 Thread.sleep(60000/getBPM());
 } catch (Exception e) {}
 }
}
public void setBPM(int bpm) {
 this.bpm = bpm;
 notifyBPMObservers();
}
public int getBPM() {
 return bpm;
}
public void registerObserver(BeatObserver o) {
 beatObservers.add(o);
}
public void notifyBeatObservers() {
 for (int i = 0; i < beatObservers.size(); i++) {
 BeatObserver observer = (BeatObserver)beatObservers.get(i);
 observer.updateBeat();
 }
}
public void registerObserver(BPMObserver o) {
 bpmObservers.add(o);
}
public void notifyBPMObservers() {
 for (int i = 0; i < bpmObservers.size(); i++) {
 BPMObserver observer = (BPMObserver)bpmObservers.get(i);
 observer.updateBPM();
 }
}
570 глава 12
готовый код: модель
public void removeObserver(BeatObserver o) {
 int i = beatObservers.indexOf(o);
 if (i >= 0) {
 beatObservers.remove(i);
 }
}
public void removeObserver(BPMObserver o) {
 int i = bpmObservers.indexOf(o);
 if (i >= 0) {
 bpmObservers.remove(i);
 }
}
public void playBeat() {
 clip.setFramePosition(0);
 clip.start();
}
public void stopBeat() {
 clip.setFramePosition(0);
 clip.stop();
}
}
составные паттерны
дальше   571
package headfirst.designpatterns.combined.djview;
 
public interface BPMObserver {
 void updateBPM();
}
package headfirst.designpatterns.combined.djview;
 
public interface BeatObserver {
 void updateBeat();
}
Представление
package headfirst.designpatterns.combined.djview;
 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
public class DJView implements ActionListener, BeatObserver, BPMObserver {
 BeatModelInterface model;
 ControllerInterface controller;
 JFrame viewFrame;
 JPanel viewPanel;
 BeatBar beatBar;
 JLabel bpmOutputLabel;
 JFrame controlFrame;
 JPanel controlPanel;
 JLabel bpmLabel;
 JTextField bpmTextField;
 JButton setBPMButton;
 JButton increaseBPMButton;
 JButton decreaseBPMButton;
 JMenuBar menuBar;
 JMenu menu;
 JMenuItem startMenuItem;
 JMenuItem stopMenuItem;
 
 public DJView(ControllerInterface controller, BeatModelInterface model) { 
 this.controller = controller;
 this.model = model;
 model.registerObserver((BeatObserver)this);
 model.registerObserver((BPMObserver)this);
 }
 
Готово 
к употреблению
572 глава 12
готовый код: представление
 public void createView() {
 // Здесь создаются все компоненты Swing
 viewPanel = new JPanel(new GridLayout(1, 2));
 viewFrame = new JFrame("View");
 viewFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 viewFrame.setSize(new Dimension(100, 80));
 bpmOutputLabel = new JLabel("offline", SwingConstants.CENTER);
 beatBar = new BeatBar();
 beatBar.setValue(0);
 JPanel bpmPanel = new JPanel(new GridLayout(2, 1));
 bpmPanel.add(beatBar);
 bpmPanel.add(bpmOutputLabel);
 viewPanel.add(bpmPanel);
 viewFrame.getContentPane().add(viewPanel, BorderLayout.CENTER);
 viewFrame.pack();
 viewFrame.setVisible(true);
 }
 
 public void createControls() {
 // Здесь создаются все компоненты Swing
 JFrame.setDefaultLookAndFeelDecorated(true);
 controlFrame = new JFrame("Control");
 controlFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 controlFrame.setSize(new Dimension(100, 80));
 controlPanel = new JPanel(new GridLayout(1, 2));
 menuBar = new JMenuBar();
 menu = new JMenu("DJ Control");
 startMenuItem = new JMenuItem("Start");
 menu.add(startMenuItem);
 startMenuItem.addActionListener(new ActionListener() {
 public void actionPerformed(ActionEvent event) {
 controller.start();
 }
 });
 stopMenuItem = new JMenuItem("Stop");
 menu.add(stopMenuItem); 
 stopMenuItem.addActionListener(new ActionListener() {
 public void actionPerformed(ActionEvent event) {
 controller.stop();
 }
 });
 JMenuItem exit = new JMenuItem("Quit");
 exit.addActionListener(new ActionListener() {
 public void actionPerformed(ActionEvent event) {
 System.exit(0);
 }
 });
составные паттерны
дальше   573
 menu.add(exit);
 menuBar.add(menu);
 controlFrame.setJMenuBar(menuBar);
 bpmTextField = new JTextField(2);
 bpmLabel = new JLabel("Enter BPM:", SwingConstants.RIGHT);
 setBPMButton = new JButton("Set");
 setBPMButton.setSize(new Dimension(10,40));
 increaseBPMButton = new JButton(">>");
 decreaseBPMButton = new JButton("<<");
 setBPMButton.addActionListener(this);
 increaseBPMButton.addActionListener(this);
 decreaseBPMButton.addActionListener(this);
 JPanel buttonPanel = new JPanel(new GridLayout(1, 2));
 buttonPanel.add(decreaseBPMButton);
 buttonPanel.add(increaseBPMButton);
 JPanel enterPanel = new JPanel(new GridLayout(1, 2));
 enterPanel.add(bpmLabel);
 enterPanel.add(bpmTextField);
 JPanel insideControlPanel = new JPanel(new GridLayout(3, 1));
 insideControlPanel.add(enterPanel);
 insideControlPanel.add(setBPMButton);
 insideControlPanel.add(buttonPanel);
 controlPanel.add(insideControlPanel);
 
 bpmLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
 bpmOutputLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
 controlFrame.getRootPane().setDefaultButton(setBPMButton);
 controlFrame.getContentPane().add(controlPanel, BorderLayout.CENTER);
 controlFrame.pack();
 controlFrame.setVisible(true);
 }
 public void enableStopMenuItem() {
 stopMenuItem.setEnabled(true);
 }
 public void disableStopMenuItem() {
 stopMenuItem.setEnabled(false);
 }
Готово 
к употреблению
574 глава 12
готовый код: контроллер
 public void enableStartMenuItem() {
 startMenuItem.setEnabled(true);
 }
 public void disableStartMenuItem() {
 startMenuItem.setEnabled(false);
 }
 public void actionPerformed(ActionEvent event) {
 if (event.getSource() == setBPMButton) {
 int bpm = 90;
 String bpmText = bpmTextField.getText();
 if (bpmText == null || bpmText.contentEquals("")) {
 bpm = 90;
 } else {
 bpm = Integer.parseInt(bpmTextField.getText());
 }
 controller.setBPM(bpm);
 } else if (event.getSource() == increaseBPMButton) {
 controller.increaseBPM();
 } else if (event.getSource() == decreaseBPMButton) {
 controller.decreaseBPM();
 }
 }
 public void updateBPM() {
 int bpm = model.getBPM();
 if (bpm == 0) {
 bpmOutputLabel.setText("offline");
 } else {
 bpmOutputLabel.setText("Current BPM: " + model.getBPM());
 }
 }
 
 public void updateBeat() {
 beatBar.setValue(100);
 }
}
package headfirst.designpatterns.combined.djview;
 
public interface ControllerInterface {
 void start();
 void stop();
 void increaseBPM();
 void decreaseBPM();
 void setBPM(int bpm);
}
Контроллер
составные паттерны
дальше   575
package headfirst.designpatterns.combined.djview;
 
public class BeatController implements ControllerInterface {
 BeatModelInterface model;
 DJView view;
 
 public BeatController(BeatModelInterface model) {
 this.model = model;
 view = new DJView(this, model);
 view.createView();
 view.createControls();
 view.disableStopMenuItem();
 view.enableStartMenuItem();
 model.initialize();
 }
 
 public void start() {
 model.on();
 view.disableStartMenuItem();
 view.enableStopMenuItem();
 }
 
 public void stop() {
 model.off();
 view.disableStopMenuItem();
 view.enableStartMenuItem();
 }
 
 public void increaseBPM() {
 int bpm = model.getBPM();
 model.setBPM(bpm + 1);
 }
 
 public void decreaseBPM() {
 int bpm = model.getBPM();
 model.setBPM(bpm - 1);
 }
 
 public void setBPM(int bpm) {
 model.setBPM(bpm);
 }
}
Готово 
к употреблению
576 глава 12
готовый код: heart model
package headfirst.designpatterns.combined.djview;
public interface HeartModelInterface {
 int getHeartRate();
 void registerObserver(BeatObserver o);
 void removeObserver(BeatObserver o);
 void registerObserver(BPMObserver o);
 void removeObserver(BPMObserver o);
}
package headfirst.designpatterns.combined.djview;
 
public class HeartTestDrive {
 public static void main (String[] args) {
 HeartModel heartModel = new HeartModel();
 ControllerInterface model = new HeartController(heartModel);
 }
}
Heart Model
package headfirst.designpatterns.combined.djview;
import java.util.*;
public class HeartModel implements HeartModelInterface, Runnable {
 List<BeatObserver> beatObservers = new ArrayList<BeatObserver>();
 List<BPMObserver> bpmObservers = new ArrayList<BPMObserver>();
 int time = 1000;
 int bpm = 90;
 Random random = new Random(System.currentTimeMillis());
 Thread thread;
 public HeartModel() {
 thread = new Thread(this);
 thread.start();
 }
 public void run() {
 int lastrate = -1;
 for(;;) {
 int change = random.nextInt(10);
 if (random.nextInt(2) == 0) {
 change = 0 - change;
 }
 int rate = 60000/(time + change);
составные паттерны
дальше   577
 if (rate < 120 && rate > 50) {
 time += change;
 notifyBeatObservers();
 if (rate != lastrate) {
 lastrate = rate;
 notifyBPMObservers();
 }
 }
 try {
 Thread.sleep(time);
 } catch (Exception e) {}
 }
 }
 public int getHeartRate() {
 return 60000/time;
 }
 public void registerObserver(BeatObserver o) {
 beatObservers.add(o);
 }
 public void removeObserver(BeatObserver o) {
 int i = beatObservers.indexOf(o);
 if (i >= 0) {
 beatObservers.remove(i);
 }
 }
 public void notifyBeatObservers() {
 for(int i = 0; i < beatObservers.size(); i++) {
 BeatObserver observer = (BeatObserver)beatObservers.get(i);
 observer.updateBeat();
 }
 }
 public void registerObserver(BPMObserver o) {
 bpmObservers.add(o);
 }
 public void removeObserver(BPMObserver o) {
 int i = bpmObservers.indexOf(o);
 if (i >= 0) {
 bpmObservers.remove(i);
 }
 }
 public void notifyBPMObservers() {
 for(int i = 0; i < bpmObservers.size(); i++) {
 BPMObserver observer = (BPMObserver)bpmObservers.get(i);
 observer.updateBPM();
 }
 }
}
Готово 
к употреблению
578 глава 12
готовый код: heart adapter
package headfirst.designpatterns.combined.djview;
public class HeartAdapter implements BeatModelInterface {
 HeartModelInterface heart;
 public HeartAdapter(HeartModelInterface heart) {
 this.heart = heart;
 }
 public void initialize() {}
 
 public void on() {}
 
 public void off() {}
 
 public int getBPM() {
 return heart.getHeartRate();
 }
 
 public void setBPM(int bpm) {}
 
 public void registerObserver(BeatObserver o) {
 heart.registerObserver(o);
 }
 
 public void removeObserver(BeatObserver o) {
 heart.removeObserver(o);
 }
 
 public void registerObserver(BPMObserver o) {
 heart.registerObserver(o);
 }
 
 public void removeObserver(BPMObserver o) {
 heart.removeObserver(o);
 }
}
Heart Adapter
составные паттерны
дальше   579
package headfirst.designpatterns.combined.djview;
 
public class HeartController implements ControllerInterface {
 HeartModelInterface model;
 DJView view;
 
 public HeartController(HeartModelInterface model) {
 this.model = model;
 view = new DJView(this, new HeartAdapter(model));
 view.createView();
 view.createControls();
 view.disableStopMenuItem();
 view.disableStartMenuItem();
 }
 
 public void start() {}
 public void stop() {}
 
 public void increaseBPM() {}
 
 public void decreaseBPM() {}
 
 public void setBPM(int bpm) {}
}
Контроллер Готово 
к употреблению

Вы стоите на пороге дивного нового мира, населенного паттернами 
проектирования. Но прежде чем открывать дверь, желательно изучить некоторые технические тонкости, с которыми вы можете столкнуться, — в реальном мире 
жизнь немного сложнее, чем здесь, в Объектвиле. К счастью, у вас имеется хороший путеводитель, который упростит ваши первые шаги...
Паттерны
13 Паттерны для лучшей жизни
в реальном мире
582 глава 13
Руководство 
по эффективному 
использованию паттернов
Вашему вниманию предлагается руководство с полезными 
советами, которые помогут вам использовать паттерны 
в реальном программировании. В этом руководстве вы
 познакомитесь с распространенными заблуждениями 
относительно определения паттерна проектирования;
 узнаете, что такое каталоги паттернов и для чего они 
нужны;
 обойдете неприятности, связанные с несвоевременным 
использованием паттернов;
 изучите классификацию паттернов;
 увидите, что построение паттернов доступно не только 
экспертам: прочитайте нашу краткую сводку правил, 
и вы тоже сможете создавать свои паттерны;
 узнаете состав таинственной «Банды Четырех»;
 научитесь тренировать свой разум, как истинный мастер 
Дзен;
 освоите основную терминологию паттернов.
что вы узнаете из руководства
паттерны для лучшей жизни
дальше   583
Паттерн — решение задачи в контексте.
Определение паттерна проектирования
Вероятно, к концу книги вы уже достаточно хорошо представляете себе, 
что такое «паттерн проектирования». Однако мы нигде не приводили формальное определение паттерна проектирования. Возможно, широко распространенное определение вас слегка удивит:
Не самое понятное определение, вы не находите? Не беспокойтесь, мы 
разберем все его составляющие — все эти контексты, задачи и решения:
Контекстом называется ситуация, в которой применяется паттерн. Ситуация должна быть достаточно типичной 
и распространенной.
Задачей называется цель, которой вы хотите добиться 
в контексте, в совокупности со всеми ограничениями, 
присущими контексту.
Решением называется обобщенная архитектура, которая 
достигает заданной цели при соблюдении набора ограничений.
Возможно, вы не сразу усвоите суть этого определения; не торопитесь, 
продвигайтесь шаг за шагом.
Кто-то сочтет, что мы тратим слишком много времени, разбираясь с тем, 
что же такое «паттерн проектирования». В конце концов, мы уже знаем, 
что паттерны предназначены для решения типичных задач, возникающих 
в ходе проектирования. К чему такие формальности? Дело в том, что наличие формального механизма описания позволяет создавать чрезвычайно 
полезные каталоги паттернов.
Пример: имеется 
коллекция объектов.
Требуется перебрать 
объекты без раскрытия 
внутренней реализации 
коллекции.
Перебор инкапсулируется 
в отдельном классе.
584 глава 13
Возможно, вы правы; давайте подумаем... Необходимыми 
компонентами паттерна являются задача, решение и контекст.
Задача: Как мне вовремя попасть на работу?
Контекст: Я нечаянно закрыл ключи в машине.
Решение: Разбить окно, залезть в машину, 
запустить двигатель и поехать на работу.
В этом определении присутствуют все компоненты из определения: задача, которая включает в себя цель (попасть на 
работу) и ограничения по времени и расстоянию (и, вероятно, другие факторы). Также имеется контекст: недоступность ключей к машине. И есть решение, которое позволит 
нам добраться до ключей и справиться с ограничениями 
времени/расстояния. Мы создали паттерн! Верно?
Следуя определению паттерна проектирования, мы определили задачу, контекст и решение 
(которое работает!). Можно ли назвать такое решение паттерном? А если нет, то почему? Возможны ли аналогичные ошибки при определении паттернов ОО-проектирования?
определение паттернов
Мозговой
штурм
Я поразмыслил над 
определением из трех частей, 
и мне кажется, что оно вовсе 
не определяет паттерны.
паттерны для лучшей жизни
дальше   585
В: Так я не увижу описания паттернов, выраженные в понятиях задачи, 
контекста и решения?
О: Описания паттернов, приводимые 
в каталогах, обычно содержат более 
подробную информацию. В них больше 
внимания уделяется цели паттерна, причинам для его применения и ситуациям, 
в которых они уместны, а также архитектуре решения и возможным последствиям 
его применения (как положительным, так 
и отрицательным).
В: Можно ли слегка изменить паттерн, 
чтобы он лучше соответствовал моей 
архитектуре? Или необходимо четко 
придерживаться исходного определения?
О: Конечно, паттерны можно изменять. 
Как и принципы проектирования, паттерны 
не должны рассматриваться как непреложные правила; это рекомендации, которые вы можете изменять в соответствии 
со своими потребностями. Как вы уже видели, многие реальные примеры отличаются от классических определений.
В: Где найти каталог паттернов?
О: Первый и самый авторитетный каталог паттернов представлен в книге «Паттерны объектно-ориентированного проектирования» (Э. Гамма, Р. Хелм, Р. Джонсон, 
Дж. Влиссидес, издательство «Питер»). 
В этом каталоге приведены 23 фундаментальных паттерна. Вскоре мы поговорим об 
этой книге более подробно.
Сейчас публикуется немало других каталогов паттернов для конкретных предметных областей: параллельных систем, 
бизнес-систем и т. д.
Подробнее об определении 
паттерна проектирования
Наш пример внешне соответствует определению, 
но назвать его паттерном нельзя. Почему? Прежде 
всего мы знаем, что паттерн должен применяться 
для решения типичных, то есть часто встречающихся, задач. Хотя рассеянный владелец может часто забывать ключи в машине, разбитое окно вряд ли можно назвать решением, которое будет применяться 
снова и снова (по крайней мере, если мы установим 
еще одно ограничение: затраты).
У нашего решения также есть пара других недостатков: во-первых, если вы возьмете это описание 
и передадите его другому человеку, у него могут 
возникнуть трудности с решением его конкретной 
проблемы. Во-вторых, мы нарушили важное, хотя 
и простое свойство паттернов: не присвоили ему 
имя! Без имени паттерн не станет частью общего 
«языка», понятного другим разработчикам.
К счастью, паттерны не описываются в простых понятиях задачи, контекста и решения. Существуют 
более эффективные способы описания паттернов 
и их объединения в каталоги паттернов.
Паттерны
A-I
Паттерны
J-R
Паттерны
S-Z
часто Задаваемые вопросы
Когда вам кто-нибудь скажет, что 
паттерн — это решение задачи в контексте, просто улыбнитесь и кивните. 
Вы знаете, что они имеют в виду, хотя этой 
формулировки недостаточно для точного 
определения паттерна проектирования.
586 глава 13
Да пребудет с вами Сила
Из определения паттернов следует, что 
задача состоит из цели 
и набора ограничений. 
У экспертов в области паттернов существует специальный термин: они называют эти составляющие силами. 
Почему? Наверняка у них есть 
свои причины, но если вы помните фильм «Звездные войны», сила 
«определяет форму и управляет всем 
происходящим во Вселенной». Силы 
в паттернах тоже определяют форму и 
управляют решением. Только когда решение выдерживает баланс между двумя 
сторонами сил (светлая сторона — ваша 
цель, темная сторона — ограничения), можно сказать, что вы создали полезный паттерн.
Когда вы впервые встречаете термин «сила» 
при обсуждении паттернов, он выглядит довольно таинственно. Помните, что у сил есть две стороны (цели и ограничения) и что они должны быть 
сбалансированы для создания паттерна. Не бойтесь 
технического жаргона, и да пребудет с вами Сила! 
силы цели ограничения
Для любознательных
паттерны для лучшей жизни
дальше   587
Фрэнк: Расскажи, о чем идет речь, Джим. Я пока только прочитал несколько статей 
о паттернах.
Джим: В каталоге подробно описывается группа паттернов в контексте их отношений с другими паттернами.
Джо: Значит, существуют разные каталоги паттернов?
Джим: Ну конечно; в одних каталогах рассматриваются фундаментальные паттерны, 
а в других — паттерны конкретной предметной области (скажем, паттерны EJB).
Фрэнк: Какой каталог ты сейчас рассматриваешь?
Джим: Классический каталог «Банды Четырех»: в нем описаны 23 фундаментальных 
паттерна проектирования.
Фрэнк: «Банды Четырех»?
Джим: Да, именно. Это те парни, которые составили самый первый каталог паттернов.
Джо: И что в этом каталоге?
Джим: Набор взаимосвязанных паттернов. Для каждого паттерна приводится подробное описание, построенное по определенному шаблону. В частности, каждому паттерну присваивается имя.
Фрэнк: Просто потрясающе — имя! Кто бы мог подумать.
Фрэнк
Джим Джо
Как 
жаль, что я раньше 
не знал о каталогах 
паттернов...
588 глава 13
Джим: Не торопись, Фрэнк, имена важны. Они позволяют нам обсуждать этот паттерн в беседах с другими разработчиками; «единая номенклатура» и все такое.
Фрэнк: Ладно-ладно... Я пошутил. Что еще там есть?
Джим: Как я уже говорил, описания паттернов следуют определенному шаблону. 
Для каждого паттерна приводится имя и несколько разделов с дополнительной информацией о паттерне. Например, в разделе «Предназначение» рассказано, для чего 
применяется данный паттерн, а в разделах «Мотивация» и «Область применения» — 
где и когда данный паттерн может использоваться.
Джо: А как насчет самой архитектуры?
Джим: Далее описывается архитектура классов вместе с самими классами и их ролями. Также имеется раздел с описанием реализации паттерна и довольно часто — 
с примерами кода, показывающими, как это делается.
Фрэнк: Похоже, они ничего не упустили.
Джим: Но это не всё. Также приводятся примеры использования паттерна в реальных системах и раздел, который лично мне кажется самым полезным: отношения 
паттерна с другими паттернами.
Фрэнк: Где тебе объясняют, чем различаются паттерны Состояние и Стратегия?
Джим: Вот именно!
Джо: Скажи, а как ты работаешь с каталогом? Когда у тебя возникает проблема, ты 
заглядываешь в него в поисках решения?
Джим: Сначала я стараюсь ознакомиться со всеми паттернами и их отношениями. 
Когда мне понадобится паттерн, я уже в общих чертах представляю, что мне нужно. Я открываю в книге разделы «Мотивация» и «Область применения» и убеждаюсь 
в том, что я правильно себе представляю происходящее. Также есть еще один важный раздел — «Последствия». Я всегда заглядываю в него, чтобы избежать непредвиденного влияния моего паттерна на архитектуру.
Фрэнк: Что ж, логично. И когда ты решаешь, что паттерн выбран правильно, как ты 
подходишь к его реализации и включению в архитектуру?
Джим: Я пользуюсь диаграммой классов. Сначала я читаю раздел «Структура» с обзором диаграммы, а затем раздел «Участники», чтобы убедиться в том, что я правильно 
понимаю роль каждого класса. Далее я адаптирую диаграмму для своей архитектуры 
и вношу те изменения, которые считаю нужными. Наконец, разделы «Реализация» 
и «Примеры кода» помогают убедиться в том, что я знаю обо всех полезных приемах 
или ловушках, которые могут встретиться на этом пути.
Джо: Похоже, каталог сделает мою работу с паттернами более эффективной!
Фрэнк: Безусловно. Джим, можешь показать нам пример описания паттерна?
используем каталог паттернов
паттерны для лучшей жизни
дальше   589
Одиночка Object Creational
Предназначение
Et aliquat, velesto ent lore feuis acillao rperci tat, quat nonsequam il ea at nim nos do 
enim qui eratio ex ea faci tet, sequis dion utat, volore magnisi.
Мотивация
Et aliquat, velesto ent lore feuis acillao rperci tat, quat nonsequam il ea at nim nos 
do enim qui eratio ex ea faci tet, sequis dion utat, volore magnisi.Rud modolore dit 
laoreet augiam iril el dipis dionsequis dignibh eummy nibh esequat. Duis nulputem 
ipisim esecte conullut wissi.
Os nisissenim et lumsandre do con el utpatuero corercipis augue doloreet luptat 
amet vel iuscidunt digna feugue dunt num etummy nim dui blaor sequat num vel 
etue magna augiat.
Aliquis nonse vel exer se minissequis do dolortis ad magnit, sim zzrillut ipsummo 
dolorem dignibh euguer sequam ea am quate magnim illam zzrit ad magna feu facinit 
delit ut
Область применения
Duis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre 
dolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore 
min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam 
dolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem 
ing ea con eros autem diam nonullu tpatiss ismodignibh er.
Структура Singleton
static uniqueInstance
// Other useful Singleton data...
static getInstance()
// Other useful Singleton methods...
Участники
Duis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, conullandre 
dolore magna feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore 
min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam 
dolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem 
ing ea con eros autem diam nonullu tpatiss ismodignibh er
  A dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er
 – A feuis nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh eniat wisissec
 – Ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit
Взаимодействия
  Feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore.
Последствия
Duis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, 
conullandre:
1. Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros 
autem diam nonullu tpatiss ismodignibh er.
2. Modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore 
magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, 
conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem.
3. Dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros 
autem diam nonullu tpatiss ismodignibh er.
4. Modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore 
magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, 
conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem.
Реализация/Примеры кода
DuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, 
conullandre dolore magna feuis nos alit ad magnim quate modolore vent lut luptat 
prat. Dui blaore min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad 
mincinci blam dolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl 
ut ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er.
Nos alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit 
ing enit laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit 
irit, conse dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros 
autem diam nonullu tpatiss ismodignibh er.
public class Singleton {
 private static Singleton uniqueInstance;
 // other useful instance variables here
 private Singleton() {}
 public static synchronized Singleton getInstance() { if (uniqueInstance == null) {
 uniqueInstance = new Singleton();
 }
 return uniqueInstance;
 }
 // other useful methods here
}
Известные применения
DuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, 
conullandre dolore magna feuis nos alit ad magnim quate modolore vent lut luptat 
prat. Dui blaore min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad 
mincinci blam dolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl 
ut ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er.
DuDuis nulputem ipisim esecte conullut wissiEctem ad magna aliqui blamet, 
conullandre dolore magna feuis nos alit ad magnim quate modolore vent lut luptat 
prat. Dui blaore min ea feuipit ing enit laore magnibh eniat wisissecte et, suscilla ad 
mincinci blam dolorpe rcilit irit, conse dolore dolore et, verci enis enit ip elesequisl ut 
ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er. alit ad magnim 
quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit laore magnibh 
eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse dolore dolore et, 
verci enis enit ip elesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss 
Связанные паттерны
Elesequisl ut ad esectem ing ea con eros autem diam nonullu tpatiss ismodignibh er. 
alit ad magnim quate modolore vent lut luptat prat. Dui blaore min ea feuipit ing enit 
laore magnibh eniat wisissecte et, suscilla ad mincinci blam dolorpe rcilit irit, conse 
dolore dolore et, verci enis enit ip elesequisl ut ad esectem ing ea con eros autem 
diam nonullu tpatiss ismodignibh er.
Диаграмма отношений 
между классами, 
участвующими 
в паттерне.
Классы и объекты, задействованные в архитектуре; описание их ролей и обязанностей 
в паттерне.
Схема взаимодействия Описание возможных участников паттерна. последствий от применения 
этого паттерна (как 
положительных, так 
и отрицательных).
Каждый паттерн в каталоге 
обладает именем. Без имени 
паттерн не сможет стать 
частью единой номенклатуры, 
понятной другим 
разработчикам.
Категория, к которой 
относится паттерн. 
Мы поговорим о 
категориях чуть 
позднее.
Короткое описание 
сути паттерна. Также 
может рассматриваться 
как определение (аналог 
определений, приводимых 
в этой книге).
Конкретный сценарий 
с описанием задачи
и способа ее решения.
Ситуации, в которых 
применяется этот 
паттерн.
Приемы, которые 
понадобятся для реализации 
этого паттерна, а также 
общие аспекты, на которые 
следует обратить внимание.
Фрагменты кода, 
которые могут 
пригодиться в вашей 
реализации.
Примеры использования 
паттерна в реальных 
системах.
Описание отношений 
между этим и другими 
паттернами.
590 глава 13
В: Можно ли создавать собственные паттерны? 
Или на это способны только «гуру» в области паттернов?
О: Прежде всего запомните, что паттерны открываются, а не создаются. Кто угодно может найти новый 
паттерн и составить его описание; тем не менее это 
довольно трудно, и такие открытия происходят нечасто. Работа первооткрывателя паттернов требует целеустремленности и терпения.
Подумайте, зачем вам это нужно. Большинство разработчиков не определяет паттерны, а использует их. Но 
возможно, вы работаете в специализированной области, в которой новые паттерны могли бы пригодиться, 
или обнаружили решение проблемы, которая, на ваш 
взгляд, является типичной, или просто хотите участвовать в жизни сообщества паттернов.
В: Я готов! С чего начинать?
О: Как и в любой научной дисциплине, чем больше вы знаете — тем лучше. Изучайте существующие 
паттерны, разбирайтесь в том, как они работают и как 
связаны с другими паттернами. Это очень важно — вы 
не только поймете, как создаются паттерны, но и не 
будете «изобретать велосипед».
В: Как я узнаю, что у меня действительно получился паттерн?
О: Вы можете быть уверены в этом только после 
того, как другие разработчики опробуют ваше решение 
и убедятся в его работоспособности. В общем случае 
следует руководствоваться «правилом трех»: оно гласит, что паттерн может быть признан таковым только 
после того, как он будет применен в реальных программах не менее трех раз.
Хотите быть экспертом по 
созданию паттернов? Тогда 
слушайте, что я вам скажу.
Выберите каталог паттернов 
и не жалейте времени на его 
изучение. А когда вы сможете 
правильно сформулировать 
определение и три разработчика 
воспользуются вашим решением, 
значит, это действительно 
паттерн.
создание собственных паттернов
часто Задаваемые вопросы
паттерны для лучшей жизни
дальше   591
Определите свой паттерн 
по одному из существующих 
шаблонов. Эти шаблоны были 
тщательно продуманы, а их 
формат хорошо знаком 
разработчикам, пользующимся 
паттернами.
Хотите создавать паттерны?
Название
Предназначение
Мотивация
Область применения
Структура
Участники
Взаимодействие
 ...
Изучайте матчасть. Прежде чем создать новый паттерн, 
необходимо хорошо разбираться в уже существующих 
паттернах. Многие паттерны, которые кажутся новыми, 
в действительности представляют собой разновидности 
существующих паттернов. Изучая паттерны, вы научитесь 
узнавать их и связывать с другими паттернами.
Анализируйте и оценивайте. Идеи паттернов рождаются 
из практического опыта — задач, с которыми вы сталкиваетесь, и примененных вами решений. Выделите время на то, 
чтобы проанализировать свой опыт и преобразовать его в 
новаторские решения типичных задач. Помните, что большинство архитектурных решений строится на разновидностях существующих паттернов, а не на новых. И даже когда 
вы обнаруживаете действительно новое решение, обычно 
выясняется, что его область применения слишком узка, 
чтобы его можно было признать полноценным паттерном.
Изложите свои идеи на бумаге. Изобретение нового паттерна не принесет особой пользы, если другие не смогут 
воспользоваться вашей находкой; вы должны документировать потенциальный паттерн, чтобы другие люди могли 
прочитать ваше описание, понять и применить его в своем 
решении, а потом предоставить обратную связь. К счастью, 
вам не придется изобретать собственную систему записи 
паттернов. Как было показано на примере шаблона «Банды 
Четырех», процесс описания паттернов и их характеристик хорошо проработан.
Предложите другим использовать ваши паттерны, улучшите их... и продолжайте улучшать. Не надейтесь, что паттерн будет правильно сформулирован с первого раза. Относитесь к своим паттернам как к текущей работе, котoрая 
должна совершенствоваться со временем. Пусть другие разработчики проанализируют ваше предложение, опробуют 
его и выскажут свое мнение. Включите данные обратной 
связи в описание и попробуйте снова. Ваше описание никогда не окажется идеальным, но в какой-то момент оно 
будет достаточно хорошо проработано, чтобы другие разработчики смогли прочитать и понять его.
592 глава 13
Соедините каждый паттерн с его описанием:
Паттерн Описание
Упаковывает объект и предоставляет другой 
интерфейс к нему.
Обеспечивает создание одного (и только одного!) 
экземпляра класса.
Инкапсулирует взаимозаменяемые варианты поведения 
и выбирает один из них посредством делегирования.
Клиент выполняет однородные операции с объектами 
и коллекциями.
Инкапсулирует поведение, связанное с состоянием, 
с делегированием поведения объекту текущего 
состояния.
Обеспечивает механизм перебора коллекций объектов 
без раскрытия реализации.
Упрощает интерфейс группы классов.
Упаковывает объект для реализации нового поведения.
Позволяет клиенту создавать семейства объектов 
без указания их конкретных классов.
Обеспечивает оповещение объектов об изменении 
состояния.
Упаковывает объект для управления доступом к нему.
Инкапсулирует запрос в виде объекта.
Декоратор
Состояние
Итератор
Фасад
Стратегия
Заместитель
Фабричный Метод
Адаптер
Наблюдатель
Шаблонный Метод
Компоновщик
Одиночка
Абстрактная Фабрика
Команда
кто и что делает?
Кто и что делает?
Субклассы решают, как реализовать шаги в алгоритме.
Субклассы решают, какие конкретные классы должны создаваться.
паттерны для лучшей жизни
дальше   593
Классификация паттернов проектирования
С ростом количества общепринятых паттернов появляется необходимость в их классификации, чтобы мы могли структурировать их, сократить поиск до небольшого подмножества паттернов и выполнять сравнение внутри групп. В большинстве каталогов используется одна из нескольких общепринятых схем классификации. Самая распространенная схема, выбранная в самом первом каталоге 
паттернов, разбивает паттерны на три категории в зависимости от их цели: порождающие, поведенческие и структурные.
Паттерны, принадлежащие 
к поведенческой категории, 
относятся к взаимодействиям 
и распределению обязанностей 
между классами и объектами.
Структурные паттерны 
объединяют классы или 
объекты в более крупные 
структуры.
Абстрактная Фабрика
Фабричный Метод Одиночка Адаптер
Компоновщик
Декоратор
Фасад
Команда Заместитель
Итератор
Наблюдатель
Состояние
Стратегия
Шаблонный Метод
Поведенческие Порождающие
Структурные
Порождающие паттерны связаны 
с созданием экземпляров объектов; 
все они обеспечивают средства 
логической изоляции клиента от 
создаваемых объектов.
Sharpen your pencil
Прочитайте описание каждой категории и попробуйте распределить 
паттерны по категориям. Задача не из 
простых! Приложите максимум усилий 
и сверьтесь с ответами на следующей 
странице.
Каждый паттерн относится 
к одной из этих категорий.
Возьми в руку карандаш
594 глава 13
Абстрактная Фабрика
Фабричный Метод
Одиночка
Адаптер
Компоновщик
Декоратор Фасад
Заместитель
Команда
Итератор
Наблюдатель
Состояние
Стратегия
Шаблонный Метод
Порождающие Поведенческие
Структурные
Прототип
Строитель
Интерпретатор
Цепочка Обязанностей
Посредник
Хранитель
Посетитель
Приспособленец Мост
Серым цветом 
выделены паттерны, 
которых мы еще не 
видели. Краткий 
обзор этих 
паттернов приведен 
в приложении.
Классификация паттернов
Перед вами паттерны, сгруппированные по категориям. Вероятно, это упражнение 
было довольно трудным, потому что многие паттерны можно отнести сразу к нескольким категориям. Не беспокойтесь, проблемы с выбором правильной категории возникают у всех разработчиков.
категории паттернов
Паттерны, относящиеся 
к поведенческой категории, 
относятся к взаимодействиям 
и распределению обязанностей 
между классами и объектами.
Структурные паттерны 
объединяют классы или 
объекты в более крупные 
структуры.
Порождающие паттерны связаны 
с созданием экземпляров объектов; 
все они обеспечивают средства 
логической изоляции клиента от 
создаваемых объектов.
Возьми в руку карандаш
 Решение
паттерны для лучшей жизни
дальше   595
Абстрактная Фабрика
Фабричный Метод
Одиночка
Адаптер Компоновщик
Декоратор
Фасад Заместитель
Команда
Итератор
Наблюдатель
Состояние
Стратегия
Шаблонный Метод
Объекты Классы
Прототип
Строитель
Интерпретатор
Цепочка Обязанностей
Посредник
Хранитель
Посетитель
Мост
Приспособленец
Паттерны также часто классифицируются по другому 
атрибуту: в зависимости от того, относится паттерн 
к классам или объектам.
Паттерны объектов описывают 
отношения между объектами, прежде 
всего относящиеся к композиции. 
Отношения в паттернах объектов 
обычно определяются на стадии 
выполнения, а следовательно, 
обладают большей динамичностью 
и гибкостью.
Обратите внимание: 
паттернов объектов 
намного больше, чем 
паттернов классов!
В: Существуют только эти схемы классификации?
О: Нет, есть и другие. Некоторые схемы начинаются с трех 
основных категорий, а затем вводят субкатегории (скажем, «Паттерны логической изоляции»). Желательно знать основные схемы 
организации паттернов, но ничто не мешает вам создавать собственные схемы, если они помогут вам лучше понять паттерны.
В: Деление паттернов на категории действительно помогает их запомнить?
О: Бесспорно, классификация формирует основу для сравнения. Однако многие разработчики путаются в категориях порождающих, структурных и поведенческих паттернов: многие 
паттерны могут быть отнесены к нескольким категориям. Главное — знать сами паттерны и отношения между ними. Но если 
классификация вам поможет, используйте ее!
В: Почему паттерн Декоратор отнесен к структурной категории? На мой взгляд, это скорее поведенческий паттерн, ведь 
он добавляет новое поведение!
О: Да, так считают многие разработчики! Классификация 
«Банды Четырех» базировалась на следующих соображениях: 
структурные паттерны описывают способы объединения классов 
и объектов для создания новых структур и новой функциональности. Паттерн Декоратор упаковывает один объект в другой для 
расширения его функциональности. Таким образом, его основной 
сутью является динамическое объединение объектов для расширения функциональности, а не взаимодействия между объектами, являющиеся содержанием поведенческих паттернов. Следует помнить о различиях между целями этих паттернов; в них 
часто кроется ключ к пониманию того, к какой категории следует 
отнести тот или иной паттерн.
Паттерны классов описывают определение 
отношений между классами посредством наследования. Отношения в паттернах классов определяются на стадии компиляции.
часто Задаваемые вопросы
596 глава 13
 Гуру и ученик...
Гуру: Ты чем-то обеспокоен?
Ученик: Да, я только что узнал 
о классификации паттернов, и мой 
разум пребывает в смятении.
Гуру: Продолжай...
Ученик: После всего, что я узнал о паттернах, 
мне говорят, что каждый паттерн относится 
к одной из трех категорий: порождающие, 
структурные и поведенческие. Зачем нужна эта 
классификация?
Гуру: Имея дело с большой коллекцией чего угодно, 
мы естественным образом ищем категории 
для классификации ее элементов, чтобы 
рассматривать их на более абстрактном уровне.
Ученик: Учитель, вы можете привести пример?
Гуру: Конечно. Возьмем машины; существует 
много разных моделей, а мы делим их на категории: 
малолитражки, спортивные, внедорожники, 
грузовики и так далее... Тебя что-то удивляет? 
Ученик: Учитель, я потрясен тем, что вы 
столько знаете о машинах!
Гуру: Нельзя же все сравнивать с цветком лотоса 
или чашкой риса. Я могу продолжать?
Ученик: Да-да, прошу прощения, продолжайте.
Гуру: Наличие классификации упрощает описание 
различий между разными категориями: «Если ты 
собираешься ехать из Кремниевой долины в СантаКрус по горной дороге, лучшим вариантом будет 
спортивная машина с хорошим управлением». Или: 
«С нынешними ценами на бензин лучше купить 
малолитражку, они эффективнее расходуют 
топливо».
Ученик: Следовательно, категории позволяют 
нам говорить о группе паттернов как о едином 
целом. Допустим, мы знаем, что нам нужен 
порождающий паттерн, — хотя и не знаем, какой 
именно.
классификация паттернов
паттерны для лучшей жизни
дальше   597
Гуру: Да, а также сравнивать элемент 
с остальными элементами категории («Мини — 
самая стильная машина из малолитражек») 
и сужать поиск («Мне нужна машина 
с эффективным расходом топлива»).
Ученик: Понимаю. Получается, я могу сказать, 
что Адаптер — лучший структурный паттерн для 
изменения интерфейса объекта.
Гуру: Да. Категории также используются еще 
для одной цели: для планирования выхода в новые 
области (скажем, «Мы хотим создать спортивный 
автомобиль с характеристиками Ferrari и по цене 
Honda»).
Ученик: Так не бывает.
Гуру: Извини, ты что-то сказал?
Ученик: Я говорю: «Да, понятно». Значит, 
категории помогают нам уяснить отношения 
между группами паттернов и между паттернами 
в пределах одной группы. Кроме того, они 
упрощают экстраполяцию новых паттернов. 
Но почему именно три категории — не четыре 
и не пять?
Гуру: Категории подобны звездам в ночном небе — 
их столько, сколько ты захочешь видеть. Три — 
удобное число. Многие люди считают, что такая 
классификация паттернов оптимальна. Впрочем, 
другие предпочитают четыре, пять и более 
категорий.
598 глава 13
Мыслить паттернами
Мозг, мыслящий 
паттернами
Контексты, ограничения, силы, каталоги, классификация... Начинает отдавать академической скукой, вы не находите? Конечно, все это важно, а знание — сила, но давайте признаем: даже если 
вы обладаете академическими познаниями, но не имеете опыта
и практики использования паттернов, это никак не повлияет на 
вашу жизнь.
Далее приводится краткое руководство, которое поможет вам 
научиться мыслить паттернами. Что мы имеем в виду? Состояние, в котором вы смотрите на архитектуру и сразу находите 
в ней естественные возможности для применения паттернов.
Будьте проще
Прежде всего при проектировании следует использовать самые простые решения. Вашей целью должна быть простота, а не «как бы применить паттерн в этой задаче». Не стоит думать, что без использования паттернов вас не будут считать грамотным специалистом. Другие разработчики по достоинству 
оценят простоту архитектуры. Впрочем, иногда самые простые и гибкие решения основаны на применении паттернов.
Паттерны ¦ не панацея
Как вы знаете, паттерны представляют собой общие решения типичных задач. Важное преимущество 
паттернов заключается в том, что они были проверены многими разработчиками. Таким образом, когда вы видите возможность для применения паттерна, будьте уверены: многие разработчики уже побывали в вашей ситуации и решили задачу аналогичными средствами.
И все же паттерны — не панацея. Не надейтесь, что вы включите паттерн в свое решение, откомпилируете программу и отправитесь на обед пораньше. Чтобы использовать паттерн, необходимо продумать все последствия для остальных аспектов архитектуры.
Используйте паттерн, когда...
Самый важный вопрос: когда использовать паттерн? Тогда, когда вы уверены, что он необходим для 
решения задачи из вашей архитектуры. Если может сработать более простое решение, проанализируйте эту возможность до выбора паттерна.
Понять, когда следует применять паттерны, — вам помогут опыт и знания. Если вы твердо уверены, что 
простое решение не соответствует вашим потребностям, проанализируйте задачу вместе с ограничениями на решение — это упростит выбор паттерна для задачи. Если вы хорошо разбираетесь в паттернах, возможно, вам уже известен хороший кандидат, а если нет — переберите паттерны, которые могли бы подойти для нее. В этом вам пригодятся разделы «Предназначение» и «Область применения». 
Обнаружив подходящий паттерн, убедитесь в том, что его последствия приемлемы в вашей ситуации, 
и проанализируйте его влияние на другие аспекты архитектуры. И если все хорошо — действуйте! 
мыслить паттернами
паттерны для лучшей жизни
дальше   599
В одной ситуации паттерны используются даже при наличии более простого решения: если вы ожидаете, что некоторые аспекты 
вашей системы будут изменяться. Как вы уже знаете, идентификация областей возможных изменений в архитектуре часто является верным признаком необходимости применения паттернов. 
Только следите за тем, чтобы паттерны были ориентированы на 
реальные, а не на чисто теоретические изменения.
Рефакторинг ¦ время применения паттернов!
Рефакторингом называется процесс изменения кода для совершенствования его структуры. Он направлен на улучшение организации кода, а не на изменение поведения. Рефакторинг идеально 
подходит для анализа архитектуры и возможностей улучшения 
ее структуры с применением паттернов. Например, обилие условных конструкций может свидетельствовать о необходимости 
применения паттерна Состояние. А может быть, пришло время 
избавиться от привязки к конкретным классам при помощи паттерна Фабрика. На тему рефакторинга с использованием паттернов были написаны целые книги, и по мере накопления практического опыта вам стоит дополнительно изучить эту тему.
Убирайте то, без чего можно обойтись. Не бойтесь исключать 
паттерны из своей архитектуры.
Никто не говорит о том, когда следует исключать паттерны из 
архитектуры, словно это какое-то святотатство! Но мы взрослые 
люди, мы это переживем.
В каких случаях паттерны следует исключать из архитектуры? 
Если ваша система стала чрезмерно сложной, а изначально запланированная гибкость оказалась излишней... Проще говоря, когда 
более простое решение предпочтительно.
Не делайте сейчас то, что может понадобиться потом.
Паттерны проектирования обладают большими возможностями. 
Разработчики любят создавать красивые архитектуры, готовые 
к изменениям в любом направлении.
Боритесь с искушением. Если поддержка изменений в архитектуре обусловлена практической необходимостью, используйте 
паттерн, который эти изменения упростит. Но если изменения 
являются чисто гипотетическими, паттерн лишь приведет к напрасному усложнению системы.
Твои мысли должны 
быть сосредоточены на 
архитектуре, а не на паттернах. 
Используй паттерны там, 
где в них есть естественная 
потребность. Если существует 
более простое решение — 
используй его.
600 глава 13
Гуру и ученик...
Гуру: Твое обучение почти завершено. Чем ты собираешься 
заняться?
Ученик: Съезжу в Диснейленд! А потом буду писать длинный 
код с паттернами!
Гуру: Постой, не торопись. Оружие не следует применять без необходимости.
Ученик: Что вы имеете в виду? Я потратил столько сил на изучение 
паттернов, а теперь не должен использовать их в своих разработках для 
достижения максимальной мощи, гибкости и удобства управления?
Гуру: Нет. Паттерны — инструмент, который следует применять только 
при необходимости. Ты потратил много времени на изучение принципов 
проектирования. Всегда начинай с принципов и пиши самый простой код, который 
позволит решить задачу. Но если ты видишь необходимость в использовании 
паттерна — тогда и используй его.
Ученик: Значит, я не должен строить свои архитектуры на базе паттернов?
Гуру: Это не должно быть твоей изначальной целью. Пусть паттерны 
появляются естественным образом в ходе проектирования. 
Ученик: Если паттерны так хороши, почему я должен осторожничать с их 
использованием?
Гуру: Паттерны усложняют архитектуру, а лишняя сложность никому не 
нужна. С другой стороны, при правильном применении паттерны обладают 
выдающейся мощью. Как известно, в них воплощен проверенный временем 
опыт проектирования, который помогает избежать типичных ошибок. Кроме 
того, паттерны определяют единую номенклатуру для обсуждения концепций 
проектирования с другими разработчиками.
Ученик: Так когда же в архитектуре уместно применять паттерны?
Гуру: Тогда, когда ты уверен в их необходимости для решения текущей задачи 
или в их необходимости для адаптации будущих изменений в требованиях 
к приложению.
Ученик: Похоже, мне еще придется многому научиться, хотя я уже понимаю 
многие паттерны.
Гуру: Да, умению адаптироваться к сложности и изменениям приходится 
учиться всю жизнь. Но теперь ты знаешь довольно много паттернов и сможешь 
применять их в своих архитектурах, продолжая изучение других паттернов.
Ученик: Погодите, выходит, я знаю НЕ ВСЕ паттерны?
Гуру: Ты узнал лишь самые основные паттерны, однако их гораздо 
больше, включая паттерны специализированных областей (параллельного 
программирования, enterprise-систем и т. д.). Но теперь, когда ты владеешь 
основами, тебе будет намного проще изучать их!
о естественности паттернов
паттерны для лучшей жизни
дальше   601
Просветленный 
разум
Разум опытного 
разработчика
Разум и паттерны
Новичок использует паттерны повсюду. И это не 
так плохо: он накапливает опыт их практического 
применения. Кроме того, новичок думает: «Чем 
больше паттернов я использую, тем лучше будет 
архитектура». Со временем он узнает, что это не 
так, а архитектуры должны быть по возможности 
простыми. Сложность и паттерны уместны 
только тогда, когда они реально необходимы для 
решения будущих проблем расширения.
По мере обучения разум опытного
разработчика начинает понимать, 
где паттерны уместны, а где нет.
Разработчик все еще нередко выбирает 
неподходящие паттерны для решения 
тех или иных задач, но он уже понимает, 
что паттерны можно адаптировать к тем 
ситуациям, для которых канонические 
определения не подойдут.
Просветленный разум видит паттерны там, где их
применение наиболее естественно. Просветленный 
разум не зациклен на использовании паттернов; 
он ищет простые решения, которые лучше всего 
подходят для конкретной задачи. Он мыслит объектноориентированными принципами и их достоинствами/
недостатками. Обнаружив естественную необходимость 
в использовании паттерна, просветленный разум 
применяет его, адаптируя при необходимости. 
Просветленный разум сродни разуму новичка — он не 
позволяет своим знаниям о паттернах слишком сильно 
влиять на архитектурные решения.
«Мне нужен паттерн для 
программы „Hello World“».
«Вероятно, здесь можно 
использовать Адаптер».
«Естественная ситуация 
для паттерна Декоратор».
Разум новичка
602 глава 13
ВНИМАНИЕ!!! Злоупотребление паттернами проектирования приводит к чрезмерному усложнению 
кода. Всегда выбирайте самое простое решение 
и используйте паттерны только в случае необходимости.
Но мы еще больше хотим, чтобы вы были хорошим 
ОО-проектировщиком.
Когда архитектура требует применения паттерна, вы пользуетесь решением, проверенным многими разработчиками. 
Ваше решение хорошо документировано, к тому же оно 
будет понятно другим разработчикам (помните: единая номенклатура и все такое).
Однако у паттернов проектирования существует и оборотная сторона. Паттерны часто вводят в решение дополнительные классы и объекты, а иногда и увеличивают сложность ваших архитектур. Кроме того, в решении могут 
появиться дополнительные логические уровни, которые 
отражаются не только на сложности, но и на эффективности решения.
Наконец, применение паттернов иногда оказывается явным «перебором». Руководствуясь принципами проектирования, можно найти более простое решение исходной 
задачи. Если вы оказались в такой ситуации — не сопротивляйтесь. Используйте более простое решение.
Но пусть все сказанное не погасит ваш энтузиазм. Паттерн 
проектирования, правильно выбранный для конкретной задачи, обладает множеством преимуществ.
Конечно, мы хотим, чтобы вы 
использовали паттерны!
когда не следует использовать паттерны
Одну минуту — 
я прочитала всю книгу, 
а теперь вы говорите, чтобы 
я НЕ ИСПОЛЬЗОВАЛА 
паттерны?
паттерны для лучшей жизни
дальше   603
И не забудьте о единстве номенклатуры
Пространно
Неполно Невразумительно
В этой книге так долго обсуждались технические тонкости ОО-проектирования, что за этим занятием можно было легко упустить «человеческую» сторону паттернов: они не только предоставляют готовые решения, 
но и формируют единую номенклатуру, понятную другим разработчикам. 
Не стоит недооценивать силу единой номенклатуры, это одно из величайших преимуществ паттернов проектирования.
С того момента, когда мы в последний раз говорили о единстве номенклатуры, произошло нечто важное: у вас появилась своя номенклатура. Кроме того, изученный вами полный набор паттернов ОО-проектирования 
поможет легко понять мотивацию и принципы работы любых новых 
паттернов, с которыми вы столкнетесь.
Теперь, когда вы овладели основами паттернов проектирования, начинайте распространять свои знания среди коллег. Почему? Потому что когда 
ваши коллеги будут знать паттерны и владеть той же единой номенклатурой, это улучшит качество проектирования, повысит эффективность 
общения и, что самое ценное, сэкономит немало времени, которое можно 
потратить с большей пользой.
И тогда я создал класс, который ведет 
список всех объектов-слушателей 
и при поступлении новых данных 
отправляет сообщение каждому слушателю. 
Причем слушатели могут в любой момент 
присоединяться к рассылке или отсоединяться 
от нее. А в качестве слушателя может 
зарегистрироваться любой объект, 
реализующий нужный интерфейс.
604 глава 13
Пять способов использования единой номенклатуры
1. На обсуждениях архитектуры. Когда группа встречается для 
обсуждения архитектуры продукта, паттерны проектирования помогут вам оставаться в курсе происходящего. Обсуждение архитектуры с точки зрения паттернов и ОО-принципов поможет вам не 
увязнуть в подробностях реализации, а также предотвратит многие недоразумения.
2. С другими разработчиками. Использование паттернов в общении с другими разработчиками способствует формированию сообщества и распространению информации о паттернах. И конечно, 
самое приятное, когда вы учите чему-то других, — услышать от 
собеседника «Ага, я понял!».
3. В документации. Когда вы описываете свою архитектуру в документации, упоминание паттернов уменьшает объем текста и дает 
читателю более четкое понимание архитектуры. 
4. В комментариях и именах. При написании кода следует упоминать использованные паттерны в комментариях. Также паттерны 
должны отражаться в именах классов и методов. Другие разработчики, читающие ваш код, будут благодарны вам за то, что вы помогли им так быстро разобраться в вашей реализации.
5. Среди заинтересованных разработчиков. Делитесь знаниями. 
Многие разработчики что-то слышали о паттернах, но плохо понимают, о чем идет речь. Вызовитесь провести семинар, посвященный паттернам, или выступите с докладом на собрании.
пять способов использования единой номенклатуры
Наблюдатель Точно
Лаконично
Исчерпывающе
паттерны для лучшей жизни
дальше   605
Ричард Хелм
Паттерны — 
рабочие инструменты, 
а не догмы. 
Адаптируйте их для 
своих задач.
Эрик Гамма
Прогулка по Объектвилю с «Бандой Четырех»
В Объектвиле нет рокеров и уличных хулиганов, но зато 
в нем есть «Банда Четырех». Как вы, вероятно, уже заметили, в мире паттернов трудно далеко уйти, не встретившись с ними. Кто же эти таинственные люди?
В двух словах, «Банда Четырех» — Эрик Гамма, Ричард 
Хелм, Ральф Джонсон и Джон Влиссидес — это люди, которые составили первый каталог паттернов, а попутно 
породили новое движение в области программирования!
Откуда взялось это название? Точно неизвестно, но оно 
прижилось. Впрочем, участники этой «Банды» — на редкость славные люди. Они даже согласились встретиться 
с нами и поделиться полезными советами...
Экскурсия
по паттернам
«Банда Четырех» породила движение 
паттернов программирования, 
но значительный вклад в него внесли 
и другие люди, в числе которых Уорд 
Каннингем, Кент Бек, Джим Коплин, 
Грэди Буч, Брюс Андерсон, Ричард 
Гэбриел, Дуг Ли, Питер Коуд и Дуг 
Шмидт.
Джон Влиссидес*
Выбирайте простые решения 
и не увлекайтесь. Если 
существует простое решение 
без использования паттерна — 
выбирайте его.
Ральф Джонсон
Сейчас 
появилось много 
новых паттернов, 
не описанных в книге 
«Банды Четырех»; 
изучайте их.
* Джона Влиссидеса не стало в 2005 г. Большая потеря для профессионального сообщества.
Не гонитесь за 
теоретической 
универсальностью, 
ориентируйтесь на 
реальные возможности 
расширения.
606 глава 13
Наше путешествие только начинается...
Авторы книги «Паттерны 
объектно-ориентированного 
проектирования» также известны 
как «Банда Четырех».
Что ж, ну а теперь, когда вы изучили эту книгу и готовы развиваться дальше, мы можем порекомендовать еще три издания, которые просто необходимо иметь на книжной полке любому программисту, 
занимающемуся разработкой паттернов.
Эта книга, изданная в далеком 1995 году, послужила основным толчком роста популярности паттернов проектирования. Здесь вы найдете все базовые и классические 
шаблоны. И в самом деле, именно она является основой 
для набора паттернов, использованных в этой книге. 
Книгу «Банды Четырех» вряд ли можно назвать последним словом в области паттернов проектирования, поскольку эта сфера существенно изменилась с момента ее 
первого издания. Но она, безусловно, является основополагающей.
Паттерны начались не с «Банды Четырех», 
начало им положил Кристофер Александер, профессор архитектуры Университета Беркли. Совершенно верно, Александер 
был архитектором, а не программистом и использовал паттерны для проектирования 
жилых пространств (домов, городов и мегаполисов). 
Если вы хотите более углубленно изучить 
паттерны, обратите внимание на две его 
книги: The Timeless Way of Building и A Pattern 
Language. Здесь вы узнаете об истоках паттернов и найдете много общего между строительством жилых зданий и разработкой 
программного обеспечения. Так что налейте чашечку кофе Starbuzz, устройтесь поудобнее и получайте удовольствие…
Классическая книга о паттернах 
проектирования
Базовые книги о паттернах
Кристофер Александр изобрел 
паттерны, которые можно 
использовать и для разработки 
программного обеспечения.
источники о паттернах
паттерны для лучшей жизни
дальше   607
Другие ресурсы, посвященные паттернам
Интернет-сайты
The Portland Patterns Repository, проект, который ведет Уорд Каннингем, представляет собой WIKI-портал, 
касающийся всех аспектов разработки и использования паттернов. Каждый может стать автором сайта и 
принять участие в дискуссиях о паттернах и объектноориентированном программировании.
c2.com/cgi/wiki?WelcomeVisitors
The Hillside Group специализируется на практике 
программирования и проектирования ПО и является 
одним из основных ресурсов, посвященных использованию паттернов. На этом сайте вы найдете массу статей, 
книг и средств для работы с паттернами.
hillside.net
O’Reilly Online Learning предоставляет электронные 
книги о паттернах проектирования, курсы и живое обучение. Также проводится учебный курс, основанный на 
материале этой книги.
oreilly.com
Вы готовы присоединиться к дружественному сообществу разработчиков паттернов проектирования? Вот несколько ресурсов, с которых вам стоит начать.
Конференции и семинары
Если вам захочется пообщаться с сообществом паттернов, 
поищите информацию о многочисленных конференциях и 
семинарах по этой теме. На сайте Hillside ведется полный 
список. Обратите внимание на PLoP (Pattern Languages 
of Programs) и конференцию ACM по OOPSLA (ObjectOriented Systems, Languages and Applications), которая стала 
частью конференции SPLASH.
Другие ресурсы
И не стоит забывать о Google, Stack Overflow, Quora и многих других сайтах и сервисах — здесь можно задавать вопросы, искать ответы и обсуждать 
паттерны проектирования. Конечно, полученную информацию стоит лишний раз проверить (как и любую информацию, полученную в интернете).
608 глава 13
Разновидности паттернов
Архитектурные 
паттерны используются 
для создания живой, 
современной архитектуры 
зданий, городков и целых 
городов. Здесь зародилась 
сама концепция паттернов.
Прикладные паттерны 
используются при 
создании архитектур 
системного уровня. Многие 
многоуровневые архитектуры 
относятся к этой категории.
Область обитания: здания, в которых вам 
хотелось бы жить. Смотрите и заходите.
Первые паттерны появились не в архитектуре программных продуктов, а в архитектуре зданий и городов. Более 
того, сама концепция паттернов может быть применена 
в самых разных областях. Давайте прогуляемся по зоопарку Объектвиля и познакомимся с некоторыми из паттернов...
Область обитания: 
трехуровневые 
архитектуры, системы 
«клиент-сервер», Веб.
Примечание: MVC иногда 
относят к категории 
прикладных паттернов.
Узкоспециализированные 
паттерны предназначены 
для решения задач 
в конкретных областях 
(параллельное 
программирование, системы 
реального времени и т. д.).
Помогите найти область 
обитания
Enterprise Computing 
разновидности паттернов
паттерны для лучшей жизни
дальше   609
Паттерны бизнес-процессов 
описывают взаимодействия 
между предприятиями, 
клиентами и данными; 
могут применяться для 
решения таких проблем, 
как эффективное принятие 
и передача решений.
Организационные 
паттерны описывают 
структуру и порядок 
деятельности 
организаций. 
Большинство современных 
разработок относится 
к организациям, 
занимающимся созданием 
и (или) поддержкой 
программных продуктов.
Паттерны 
пользовательского 
интерфейса 
решают проблемы 
проектирования 
интерактивных программ.
Встречаются в залах 
заседаний крупных корпораций 
и на собраниях, посвященных 
управлению проектами.
Запишите здесь свои наблюдения по поводу разновидностей паттернов.
Область обитания: 
проектирование видеоигр, 
графические интерфейсы.
Помогите найти область 
обитания
Группа разработки
Группа технической поддержки
610 глава 13
Антипаттерны и борьба со злом
Вселенная попросту была бы неполной, если бы существовали одни паттерны без антипаттернов. 
Если паттерн проектирования предоставляет общее решение распространенной задачи в конкретном контексте, то что же делает антипаттерн? Антипаттерн всегда выглядит как хорошее решение, 
но после применения оказывается плохим.
Документирование антипаттернов поможет другим 
разработчикам распознавать плохие решения до 
того, как они будут реализованы.
У антипаттернов, как и 
у паттернов, существует 
много разновидностей: 
антипаттерны разработки, 
ОО-проектирования, организационные, узкоспециализированные и т. д.
Антипаттерн описывает ПЛОХОЕ решение 
задачи.
Резонно спросить: зачем тратить время на документирование плохих решений?
Если у типичной задачи имеется распространенное плохое решение, то его документирование поможет другим 
разработчикам избежать повторения ошибки. И если на 
то пошло, предотвращение плохих решений может принести не меньше пользы, чем поиск хороших!
Рассмотрим основные свойства антипаттерна:
Антипаттерн показывает, почему плохое решение выглядит привлекательно. Согласитесь, никто бы не стал 
выбирать плохое решение, если бы оно изначально не 
казалось привлекательным. Одна из самых важных задач антипаттернов — обратить ваше внимание на соблазны антипаттернов.
Антипаттерн объясняет, почему данное решение плохо в долгосрочной перспективе. Чтобы понять, почему решение относится к антипаттернам, необходимо 
видеть все отрицательные последствия его применения.
Антипаттерн предлагает паттерны, которые могут
привести к хорошему решению. Чтобы антипаттерн 
был действительно полезным, он должен направить вас 
в верном направлении, то есть предложить другие возможности, которые ведут к хорошим решениям.
Рассмотрим пример антипаттерна.
антипаттерны
паттерны для лучшей жизни
дальше   611
Антипаттерн
Название: Золотой молоток.
Проблема: требуется выбрать технологию для 
разработки. Вы полагаете, что вся архитектура 
должна быть построена на фундаменте ровно 
одной технологии. 
Контекст: технология, с которой хорошо знакома 
группа, плохо соответствует требованиям 
разрабатываемой системы или программного 
продукта.
Факторы:
• группа разработки стремится 
использовать знакомую технологию;
• группа разработки не знакома 
с другими технологиями;
• переход на незнакомую технологию 
сопряжен с определенным риском;
• знакомая технология упрощает 
планирование и оценку разработки.
Предлагаемое решение: использовать знакомую 
технологию, несмотря ни на что. Технология 
упорно применяется для решения любых 
задач — даже там, где это совершенно очевидно 
неуместно. 
Рекомендуемое решение: повышение 
квалификации разработчиков посредством 
обучения и участия в семинарах, которые 
знакомят разработчиков с новыми решениями.
Примеры: некоторые веб-компании продолжают 
использовать и поддерживать самостоятельно 
разработанные системы кэширования, несмотря 
на наличие альтернативных решений с открытым 
кодом.
По материалам Portland Pattern Repository 
WIKI (https://wiki.c2.com/?WelcomeVisitors). 
Плохое, но внешне привлекательное решение.
Факторы, способствующие 
выбору данного решения.
Пути перехода к хорошему 
решению.
Задача и контекст как 
в описании паттерна.
Антипаттерн тоже обладает 
именем, а следовательно, 
закладывает основу для единой 
номенклатуры.
Пример антипаттерна разработки.
Ситуации, в которых
был замечен антипаттерн.
612 глава 13
Новые инструменты
Сейчас вы знаете столько же, сколько знаем 
мы. Пора выбираться в реальный мир и заняться 
самостоятельным изучением паттернов...
Концепции
Стратегия — определяет семейство алгоритмов, 
инкапсулирует и обеспечивает их взаимозаменяемость. 
Паттерн позволяет модифицировать алгоритмы независимо от их использования на стороне клиента.
Паттерны
Observer — defines 
a one-to-many 
dependency between 
objects so that when 
one object changes state, 
all its dependents are 
notified and updated 
automatically
Decorator — Attach 
additional responsibilities 
to an object dynamically. 
Decorators provide a 
flexible alternative to 
subclassing for extending 
functionality.
Abstract Factory — 
Provide an interface 
for creating families 
of related or depedent 
objects without 
specifying their concrete 
classes.
Factory Method — 
Define an interface for 
creating an object, but 
let subclasses decide 
which class to instantiate. 
Factory Method lets a 
class defer instantiation 
to the subclasses.
Singleton — Ensure 
a class only has one 
instance and provide a 
global point of access to 
it.
Command — 
Encapsulates a request 
as an object, thereby 
letting you parameterize 
clients with different 
requests, queue or log 
requests, and support 
undoable operations.
  Решение об использовании 
паттернов должно естественно 
следовать из архитектуры. Не 
используйте паттерны только 
ради паттернов.
  Паттерны проектирования — не догма; адаптируйте 
и подстраивайте их для своих 
потребностей.
  Всегда выбирайте самое 
простое решение, соответствующее вашим потребностям, 
даже если в нем не используются паттерны.
  Изучайте каталоги паттернов, 
чтобы поближе познакомиться 
с паттернами и отношениями 
между ними.
  Классификация паттернов 
обеспечивает их логическую 
группировку.
  Для создания новых паттернов 
необходимо время и терпение. 
Приготовьтесь вносить многократные изменения в свою 
работу.
  Большинство «новых» паттернов, с которыми вы столкнетесь, будет представлять 
собой модификации существующих паттернов.
  Формируйте общую терминологию вашей рабочей группы. 
Это одно из важнейших преимуществ паттернов.
  В сообществе паттернов, как 
и в любом другом сообществе, 
существует свой жаргон. Пусть 
он вас не пугает — после прочтения этой книги вы знаете 
большую часть терминов.
Adapter — 
Encapsulates a request 
as an object, thereby 
letting you parameterize 
clients with different 
requests, queue or log 
requests, and support 
undoable operations.
Facade — Encapsulates a request as an object, 
thereby letting you 
parameterize clients 
with different requests, 
queue or log requests, 
and support undoable 
operations.
Пора переходить к самостоятельному изучению паттернов. 
Многие паттерны, относящиеся 
к конкретным областям, в книге не рассматривались. Также 
найдется немало фундаментальных паттернов, не упоминаемых 
в книге. Наконец, ничто не мешает вам создавать собственные 
паттерны.
State — Allow an object to alter its behavior 
when its internal state 
changes. The object will 
appear to change its 
class.
Заместитель — предоставляет 
суррогатный объект, управляющий доступом к другому объекту.
В приложении описаны 
другие фундаментальные паттерны, заслуживающие вашего 
внимания.
инструментарий проектирования
Абстракция
Инкапсуляция
Полиморфизм
Наследование
Принципы
Инкапсулируйте то, что изменяетсяа.
Отдавайте предпочтение композиции перед наследованием.
Программируйте на уровне интерфейсов.
Стремитесь к слабой связанности взаимодействующих объектов.
Классы должны быть открыты 
для расширения, но закрыты для 
изменения.
Код должен зависеть от абстракций, а не от конкретных 
классов.
Взаимодействуйте только с 
«друзьями».
Не вызывайте нас — мы вас сами 
вызовем.
Класс должен иметь только одну 
причину для изменений.
Составной паттерн объединяет два и более базовых 
паттерна в решении типичной или общей задачи.
Составные паттерны
____________________
____________________
_____________________
Для ваших 
паттернов:
КЛЮЧЕВЫЕ 
МОМЕНТЫ
паттерны для лучшей жизни
дальше   613
Конечно, мы будем по вам скучать. Но не огорчайтесь — вы и оглянуться 
не успеете, как в серии Head First выйдет новая книга и мы встретимся 
снова. О чем будет следующая книга? Хм-м, хороший вопрос! Может, 
хотите поделиться своим мнением? Отправляйте пожелания по адресу 
booksuggestions@wickedlysmart.com
Как хорошо, что вы к нам заехали...
Покидая Объективиль...
614 глава 13
Соедините каждый паттерн с его описанием:
Паттерн Описание
ответы к упражнениям
Декоратор
Состояние
Итератор
Фасад
Стратегия
Заместитель
Фабричный Метод
Адаптер
Наблюдатель
Шаблонный Метод
Компоновщик
Одиночка
Абстрактная Фабрика
Команда
Упаковывает объект и предоставляет другой интерфейс 
к нему.
Субклассы решают, как реализовать шаги в алгоритме.
Субклассы решают, какие конкретные классы должны 
создаваться.
Обеспечивает создание одного (и только одного!) экземпляра 
класса.
Инкапсулирует взаимозаменяемые варианты поведения 
и выбирает один из них посредством делегирования.
Клиент выполняет однородные операции с объектами 
и коллекциями.
Инкапсулирует поведение, связанное с состоянием, с делегированием поведения объекту текущего состояния.
Обеспечивает механизм перебора коллекций объектов 
без раскрытия реализации.
Упрощает интерфейс группы классов.
Упаковывает объект для реализации нового поведения.
Позволяет клиенту создавать семейства объектов 
без указания их конкретных классов.
Обеспечивает оповещение объектов об изменении состояния.
Упаковывает объект для управления доступом к нему.
Инкапсулирует запрос в виде объекта.
Кто и что делает?
решение
Не каждому суждено оставаться на пике популярности. За последние 
10 лет многое изменилось. С момента выхода первого издания книги «Банды 
Четырех» разработчики тысячи раз применяли эти паттерны в своих проектах. 
В этом приложении представлены полноценные, первосортные паттерны от 
«Банды Четырех» — они используются реже других паттернов, которые рассматривались ранее. Однако эти паттерны ничем не плохи, и если они уместны 
в вашей ситуации, применяйте их без малейших сомнений. В этом приложении 
мы постараемся дать общее представление о сути этих паттернов.
14 Приложение
Другие паттерны
616 приложение
Мост
Используйте паттерн Мост, если изменяться может не только реализация, но и абстракции.
Представьте, что вы пишете код для нового эргономичного ДУ для телевизора. Вы 
уже знаете, что в программировании необходимо использовать принципы ООпроектирования: хотя архитектура базируется на одной абстракции, в ней будет 
задействовано множество реализаций — по 
одной для каждой модели телевизора.
Сценарий
Дилемма
Вы знаете, что интерфейс пульта не будет определен в окончательном виде с первого раза. Более того, предполагается, 
что продукт будет совершенствоваться с получением данных обратной связи от пользователей.
Таким образом, меняться будут как пульты, так и телевизоры. Вы уже абстрагировали пользовательский интерфейс, 
чтобы иметь возможность изменения реализации для многочисленных моделей телевизоров, принадлежащих пользователям. Но, как ожидается, абстракция тоже будет изменяться со временем на основании полученных отзывов 
пользователей.
Как же создать ОО-архитектуру, которая позволяла бы изменять как реализацию, так и абстракцию?
Все модели 
основаны на одной 
абстракции.
RemoteControl
on()
off()
setChannel()
// Другие методы
Множество 
реализаций 
для разных 
телевизоров.
SonyControl
on()
off()
setChannel()
// Другие методы
RCAControl
on()
off()
setChannel()
// Другие методы
Абстракция (интерфейс 
или абстрактный класс).
{
 tuneChannel(channel);
}
В этой архитектуре 
изменяться может только 
реализация, но не интерфейс.
паттерн мост
другие паттерны
дальше   617
 Преимущества Моста 
  Логическое отделение реализации от интерфейса.
  Абстракция и реализация могут расширяться 
независимо друг от друга.
  Изменения в конкретных классах абстракции не 
отражаются на стороне клиента.
  Используется в графических и оконных системах, 
которые должны работать на разных платформах.
  Полезен в ситуациях с возможностью 
независимого изменения интерфейса 
и реализации.
  Повышает сложность. 
Область применения и недостатки
Как использовать паттерн Мост
Паттерн Мост позволяет изменять реализацию и абстракцию, для чего они размещаются в двух 
разных иерархиях классов.
TV
on()
off()
tuneChannel()
// more methods
Sony
on()
off()
tuneChannel()
// more methods
RCA
on()
off()
tuneChannel()
// more methods
ConcreteRemote
on()
off()
setStation()
nextChannel()
previousChannel()
// more methods
RemoteControl
implementor
on()
off()
setChannel()
// more methods
Содержит
 implementor.tuneChannel(channel);
Иерархия классов 
абстракции.
Иерархия классов 
реализации.
Отношение между 
двумя иерархиями 
называется Мостом.
Все методы абстракции 
формулируются 
в контексте реализации.
setChannel(currentStation + 1);
currentStation
Архитектура состоит из двух иерархий: для пультов и для конкретных телевизоров (реализаций). 
Паттерн Мост позволяет изменять каждую из двух иерархий независимо от другой иерархии.
Конкретные субклассы реализуются 
в контексте абстракции, а не реализации.
618 приложение
Строитель
Паттерн Строитель инкапсулирует конструирование продукта и позволяет разделить его на этапы.
Вам предложено создать систему планирования экскурсий по Паттернленду — новому парку развлечений неподалеку от Объектвиля. Гости парка могут выбрать гостиницу, заказать билеты на аттракционы, зарезервировать места в ресторане и даже заказать специальные мероприятия. Запланированная 
экскурсия выглядит примерно так:
Сценарий
Необходима гибкая архитектура
Поездки могут различаться по количеству дней и составу развлекательной программы. Например, 
местный житель не нуждается в гостинице, но хочет заказать обед и специальные мероприятия. Другой гость прилетает в Объектвиль самолетом, и ему необходимо забронировать номер в гостинице, 
столик в ресторане и билеты на мероприятия.
Таким образом, нам нужна гибкая структура данных, которая может представлять программу посещения со всеми возможными вариациями; кроме того, построение программы может состоять из нескольких (возможно, нетривиальных) шагов. Как предоставить способ построения сложной структуры данных, не смешивая его с отдельными этапами ее создания?
Каждый день возможна 
произвольная комбинация 
резервирования номеров 
в гостинице, билетов, обедов 
и специальных мероприятий.
Каждый отпуск 
планируется 
на определенное 
количество дней.
Отпуск День 1
День 2
День 3
Питание
Специальное
Билеты в парк
Билеты в парк
Билеты в парк
Гостиница
Гостиница
Обед
Паттерны на льду
Гостиница
Питание
Обед
Специальное Цирк паттернов
паттерн строитель
другие паттерны
дальше   619
 Преимущества Строителя
  Инкапсуляция процесса создания сложного объекта.
  Возможность поэтапного конструирования объекта с переменным набором этапов (в отличие 
от «одноэтапных» фабрик).
  Сокрытие внутреннего представления продукта 
от клиента. 
  Реализации продуктов могут свободно изменяться, потому что клиент имеет дело только с аб- страктным интерфейсом.
  Часто используется для создания составных 
структур.
  Конструирование объектов с использованием 
паттерна Фабрика требует от клиента 
дополнительных знаний.
 Область применения и недостатки
Как использовать паттерн Строитель
Помните паттерн Итератор? Мы инкапсулировали перебор в отдельном объекте и скрыли внутреннее 
представление коллекции от клиента. Здесь используется та же идея: создание программы посещения 
инкапсулируется в объекте (назовем его «строителем»), а клиент использует этот объект для конструирования структуры данных.
Клиент приказывает 
строителю 
сконструировать 
программу.
AbstractBuilder
buildDay()
addHotel()
addReservation()
addSpecialEvent()
addTickets()
getVacationPlanner()
Client
constructPlanner()
builder.buildDay(date);
builder.addHotel(date, “Grand Facadian”);
builder.addTickets(“Patterns on Ice”);
 // Планирование других мероприятий
Planner yourPlanner = 
 builder.getVacationPlanner();
Клиент использует 
абстрактный интерфейс 
для построения 
программы посещения.
Конкретный 
строитель 
создает реальные 
продукты 
и сохраняет 
их в сложной 
структуре.
Клиент руководит действиями Строителя 
по созданию программы, а затем вызывает 
метод getVacationPlanner() для получения 
объекта.
VacationBuilder
vacation
buildDay()
addHotel()
addReservation()
addSpecialEvent()
addTickets()
getVacationPlanner()
 
builder
620 приложение
Цепочка Обязанностей
Паттерн Цепочка Обязанностей используется, когда вы хотите предоставить нескольким объектам возможность обработать запрос.
паттерн цепочка обязанностей
Фирма Mighty Gumball не может справиться с сообщениями, поступающими после 
выпуска торгового автомата с поддержкой Java. Анализ показывает, что сообщения делятся на четыре вида: выражения 
восхищения от поклонников, которым 
нравится новая игра «1 из 10»; жалобы 
от родителей, дети которых не на шутку 
увлеклись игрой, и просьбы об установке 
автоматов в новых местах. К четвертому 
виду, естественно, относится спам.
Все сообщения поклонников должны поступать руководству, все жалобы — в юридический отдел, а запросы на установку — 
в отдел коммерческого развития. Спам 
просто удаляется.
Сценарий
Ваша задача
Фирма Mighty Gumball уже разработала эвристические детекторы, которые определяют, к какому виду относится сообщение. 
Теперь вы должны создать архитектуру, 
использующую эти детекторы для обработки входящей почты.
Помогите нам 
справиться с потоком почты, 
которую мы получаем после 
выхода новых торговых 
автоматов.
другие паттерны
дальше   621
 Преимущества Цепочки Обязанностей
  Логическая изоляция отправителя запроса от 
получателей.
  Объект упрощается, поскольку ему не нужно ни 
знать структуру цепочки, ни хранить прямые ссылки на ее элементы.
  Возможность динамического добавления или 
удаления обязанностей посредством изменения 
элементов цепочки или их порядка.
  Часто используется в графических средах для 
обработки событий (щелчки мышью, события 
клавиатуры и т. д.).
  Обработка запроса не гарантирована; если событие не будет обработано ни одним объектом, оно 
просто выходит с конца цепочки (это может быть 
как достоинством, так и недостатком).
  Цепочки могут усложнять отслеживание запросов 
и отладку.
 Область применения и недостатки
Как использовать паттерн Цепочка Обязанностей
В паттерне Цепочка Обязанностей создается цепочка объектов, последовательно анализирующих запрос. Каждый объект 
получает запрос и либо обрабатывает его, либо передает следующему объекту в цепочке.
Handler
successor
handleRequest()
SpamHandler
handleRequest()
FanHandler
handleRequest()
ComplaintHandler
handleRequest()
NewLocHandler
handleRequest()
Spam 
Handler
Fan 
Handler
Complaint 
Handler
NewLoc 
Handler
Каждый объект в цепочке 
проверяет запрос. Если объект 
может обработать запрос, он это 
делает; в противном случае запрос 
передается преемнику (следующему 
объекту в цепочке).
Полученное сообщение передается первому обработчику, 
SpamHandler. Если SpamHandler не может обработать запрос, то последний передается FanHandler. И так далее...
Каждое сообщение передается
первому обработчику.
Сообщение, добравшееся до конца 
цепочки, остается необработанным — 
хотя вы всегда можете реализовать 
обработчик по умолчанию.
622 приложение
Приспособленец
Используйте паттерн Приспособленец, если один экземпляр класса 
может предоставлять много «виртуальных экземпляров».
Вы хотите включить деревья в свое новое приложение ландшафтного дизайна. В вашем приложении деревья обладают минимальной функциональностью; они имеют координаты X-Y и могут динамически пририсовывать 
себя в зависимости от возраста. Проблема в том, что рано или поздно клиент захочет включить в свой дизайн множество деревьев. Это будет выглядеть примерно так:
Сценарий
Дилемма
Важный клиент, которого вы обхаживали в течение 
многих месяцев, собирается купить 1000 комплектов 
вашего приложения для планирования ландшафтов 
в крупных сообществах. Поработав с приложением 
в течение недели, клиент жалуется, что при создании большого количества деревьев приложение начинает «тормозить»...
Дерево
Дерево Дерево
Дерево
Дерево
Дерево
Дерево
Дом
Каждый экземпляр 
Tree поддерживает 
свое состояние.
паттерн приспособленец
Tree
xCoord
yCoord
age
display() {
 // Координаты
 // и возраст
 // используются
 // для прорисовки
}
другие паттерны
дальше   623
 Преимущества Приспособленца
  Сокращение количества экземпляров класса во 
время выполнения (экономия памяти).
  Централизованное хранение состояния многих 
«виртуальных» объектов.
  Приспособленец используется в том случае, когда 
класс имеет много экземпляров, которыми можно 
управлять одинаково.
  Недостаток паттерна Приспособленец заключается в том, что после его реализации отдельные 
экземпляры класса уже не смогут обладать 
собственным поведением, независимым от других 
экземпляров.
 Область применения и недостатки
Как использовать паттерн Приспособленец
А если вместо создания тысяч объектов Tree переработать систему, чтобы в ней был только один экземпляр Tree и клиентский объект, хранящий состояние 
ВСЕХ деревьев? Это и есть паттерн Приспособленец!
Единственный объект 
Tree, не обладающий 
состоянием.
Всё состояние ВСЕХ виртуальных 
объектов Tree хранится 
в двумерном массиве.
Tree
display(x, y, age) {
 // Координаты
 // и возраст
 // используются
 // для прорисовки
 }
TreeManager
treeArray
displayTrees() {
 // для всех деревьев
 // Чтение данных
 // из массива
 display(x, y, age);
 }
}
624 приложение
паттерн интерпретатор
Паттерн Интерпретатор 
требует некоторого знания теории 
формальной грамматики. Впрочем, 
если вы никогда не изучали 
формальную грамматику, все равно 
прочитайте описание паттерна; суть 
будет понятна.
Интерпретатор
Паттерн Интерпретатор используется для 
создания языковых интерпретаторов.
Помните имитатор утиного пруда? На его основе можно 
создать программу, которая будет обучать детишек программированию. Ребенок получает в свое распоряжение 
одну утку и управляет ею, отдавая команды на простом языке. Пример:
Сценарий
Что дальше?
Грамматика готова; теперь необходим механизм представления и интерпретации серий, чтобы ученики видели, как 
введенные ими команды действуют на виртуальных уток.
Припомнив теорию создания грамматик, которую вам излагали на одной из вводных лекций по программированию, вы записываете определение грамматики:
Повернуть направо.
Лететь весь день...
...потом крякнуть.
Программа представляет собой 
выражение, состоящие из серии 
команд и повторений («while»).
Конструкция while состоит 
из управляющей переменной 
и выражения.
right;
while (daylight) fly;
quack;
expression ::= <command> | <sequence> | <repetition>
sequence ::= <expression> ‘;’ <expression>
command ::= right | quack | fly
repetition ::= while ‘(‘ <variable> ‘)’<expresion>
variable ::= [A-Z,a-z]+
Серия представляет 
собой последовательность выражений, 
разделенных символом «;».
Три команды: right, quack и fly.
РАССЛАБЬТЕСЬ
другие паттерны
дальше   625
 Преимущества Интерпретатора
  Представление правил грамматики в виде классов 
упрощает реализацию языка.
  Так как грамматика представлена классами, вы 
можете легко изменять и расширять язык.
  Включение дополнительных методов в структуру 
классов позволяет добавлять новое поведение, 
не связанное с интерпретацией. Скажем, фор- матированный вывод или проверку корректности 
интерпретируемого кода.
  Используйте интерпретатор для реализации простого языка.
  Паттерн уместен для языков с простой грамматикой, когда простота важнее эффективности.
  Может использоваться как со сценарными языками, так и с языками программирования.
  При большом количестве грамматических правил 
реализация становится громоздкой и неуклюжей. 
В таких случаях лучше воспользоваться парсе- ром/компилятором.
 Область применения и недостатки 
Как реализовать Интерпретатор
В паттерне Интерпретатор определяется представление своей грамматики в виде класса вместе с интерпретатором для обработки серий. В архитектуру 
вводится класс, представляющий каждое правило 
языка. На диаграмме изображен «утиный» язык, преобразованный в иерархию классов. Обратите внимание на прямое соответствие классов элементам 
грамматики:
Интерпретация языка осуществляется вызовом метода 
interpret() для каждого типа выражения. Метод получает контекст (содержащий входной поток разбираемой 
программы), идентифицирует входные данные и обрабатывает их.
Expression
interpret(context)
Sequence
expression1
expression2
interpret(context)
Repetition
variable
expression
interpret(context)
FlyCommand
interpret(context)
Variable QuackCommand RightCommand
interpret(context) interpret(context) interpret(context)
626 приложение
Посредник
Паттерн Посредник используется для централизации сложных взаимодействий и управляющих операций между объектами.
Календарь
паттерн посредник
Боб живет в «умном доме» из недалекого будущего: все домашние приборы и устройства 
сконструированы так, чтобы сделать его жизнь как можно более комфортной. Когда Боб 
отключает сигнал будильника, то будильник приказывает кофеварке приступить к приготовлению кофе. Но несмотря на все удобства, Боб и другие клиенты всегда хотят чего-то 
нового: не варить кофе по выходным... Отключить дождеватель за 15 минут до принятия 
душа... Ставить будильник на более раннее время в дни вывоза мусора...
Сценарий
Система 
орошения
Кофеварка
Будильник
Дилемма
Создателям дома становится все труднее следить за тем, в каких объектах находятся те 
или иные правила и как разные объекты связаны друг с другом.
Alarm
onEvent() {
 checkCalendar()
 checkSprinkler()
 startCoffee()
 // И т. д.
}
Calendar
onEvent() {
 checkDayOfWeek()
 doSprinkler()
 doCoffee()
 doAlarm()
 // И т. д.
} 
CoffeePot
onEvent() {
 checkCalendar()
 checkAlarm()
 // И т. д.
}
Sprinkler
onEvent() {
 checkCalendar()
 checkShower()
 checkTemp()
 checkWeather()
 // И т. д.
}
другие паттерны
дальше   627
 Преимущества Посредника
  Расширение возможностей повторного использования кода объектов, находящихся под управлением посредника.
  Упрощение сопровождения системы за счет централизации управляющей логики.
  Упрощение сообщений, передаваемых между 
объектами в системе.
  Посредник часто используется для координации 
работы взаимосвязанных компонентов графического интерфейса.
  Недостаток паттерна Посредник состоит в том, 
что без должного проектирования объект Посредник может стать излишне сложным.
 Область применения и недостатки
Посредник
Календарь
Система 
орошения
Кофеварка Будильник
Посредник в действии...
Включение Посредника в систему 
значительно упрощает все объекты 
устройств:
 	 Объекты устройств оповещают 
Посредник об изменении своего 
состояния.
 	 Объекты устройств отвечают на 
запросы Посредника.
Перед добавлением Посредника все 
объекты устройств должны были 
знать о существовании друг друга... 
Между ними существовала жесткая 
привязка. В архитектуре с Посредником объекты устройств полностью 
отделены друг от друга.
Посредник содержит всю управляющую логику системы. Когда существующему устройству потребуется 
добавить новое правило или в систему 
добавляется новое устройство, вся необходимая логика будет размещаться 
в Посреднике.
Mediator 
if(alarmEvent){
 checkCalendar()
 checkShower()
 checkTemp()
}
if(weekend) {
 checkWeather()
 // И т. д.
}
if(trashDay) {
 resetAlarm()
 // И т. д.
}
Как хорошо —
мне теперь не надо 
разбираться в правилах 
будильника!
628 приложение
Хранитель
Паттерн Хранитель используется для реализации возврата к одному из предыдущих состояний (например, если пользователь выполнил команду «Отменить»).
Ваша ролевая игра пользуется огромным успехом, и у нее появился целый легион поклонников. Все они пытаются добраться до знаменитого 
«13-го уровня». По мере того как пользователи переходят на более сложные уровни, вероятность 
внезапного завершения игры растет. Человек 
потратил несколько дней на проход к сложным 
уровням, а его персонаж вдруг пропадает, и все 
приходится начинать заново... Естественно, это 
никого не обрадует. Игроки хором требуют ввести команду сохранения, чтобы в случае гибели 
они могли восстановить хотя бы б?ольшую часть 
своих игровых достижений. Команда сохранения должна возвращать воскресшего персонажа на последний успешно пройденный уровень.
Сценарий
Только будь внимателен 
с сохранением состояния. 
Программа довольно сложная, и я 
не хочу, чтобы кто-то испортил мой 
замечательный код.
паттерн хранитель
другие паттерны
дальше   629
Хранитель за работой
Паттерн Хранитель имеет две цели:
  Сохранение важного состояния ключевого 
объекта системы.
  Должная инкапсуляция ключевого объекта.
 Преимущества Хранителя
  Хранение состояния отдельно от ключевого объекта улучшает связность системы.
  Инкапсуляция данных ключевого объекта.
  Простая реализация восстановления.
  Хранитель используется для сохранения состояния.
  Сохранение и восстановление состояния может 
быть довольно продолжительной операцией.
  В системах на базе Java для сохранения текущего 
состояния иногда можно воспользоваться сериа- лизацией.
 Область применения и недостатки 
В соответствии с принципом единой обязанности 
состояние желательно хранить отдельно от ключевого объекта. Отдельный объект, в котором хранится состояние, называется хранителем.
Обратите 
внимание: при 
такой реализации 
клиент не имеет 
доступа к данным 
хранителя.
Клиент
// при достижении нового уровня
Object saved = 
 (Object) mgo.getCurrentState();
// когда требуется восстановление
mgo.restoreState(saved);
GameMemento
savedGameState
MasterGameObject
gameState
Object getCurrentState() {
 // Получение состояния
 return(gameState);
}
restoreState(Object savedState) {
 // Восстановление состояния
}
// Другие операции
630 приложение
В вашей ролевой игре герои, странствующие по динамически генерируемому ландшафту, встречают бесконечную череду врагов. Характеристики 
монстров должны зависеть от изменяющегося ландшафта — согласитесь, 
крылатая тварь не очень уместна в подводном царстве. Наконец, вы хотите, 
чтобы опытные игроки могли создавать собственных монстров.
Прототип
Паттерн Прототип используется в тех случаях, когда создание экземпляра класса требует больших затрат ресурсов или занимает 
много времени.
Сценарий
Архитектура станет намного 
чище, если технический код 
создания чудовищ будет отделен от 
кода, непосредственно создающего 
экземпляры в ходе игры.
Сам акт создания всех этих 
разных экземпляров весьма непрост... 
Размещение всех подробностей 
состояния в конструкторах ухудшит связанность 
системы. Хорошо бы инкапсулировать все 
подробности создания экземпляров 
в одном месте...
паттерн прототип
другие паттерны
дальше   631
<<interface>>
 Monster
На помощь приходит Прототип 
Паттерн Прототип позволяет создавать новые экземпляры посредством копирования существующих экземпляров. (В языке Java для этой цели обычно применяется метод clone() или десериализация, если требуется 
выполнить глубокое копирование.) Ключевой момент 
этого паттерна заключается в том, что клиентский код 
может создавать новые экземпляры, не зная, экземпляр какого конкретного класса при этом создается.
 Преимущества Прототипа
  Сложности создания новых экземпляров остаются 
скрытыми от клиента.
  У клиента появляется возможность генерировать 
объекты, тип которых ему неизвестен.
  В некоторых обстоятельствах копирование эффективнее создания нового объекта.
  Прототип обычно применяется в системах, соз- дающих новые объекты разных типов из сложной 
иерархии классов.
  Создание копии объекта иногда бывает нетриви- альной операцией.
 Область применения и недостатки
Находит подходящего 
монстра, создает его 
дубликат и возвращает его.
Клиенту нужен новый 
монстр, подходящий 
для текущей ситуации. 
(Клиент не знает, какого 
именно монстра он 
получит).
WellKnownMonster DynamicPlayerGeneratedMonster
MonsterMaker
makeRandomMonster() {
 Monster m = 
 MonsterRegistry.getMonster();
}
MonsterRegistry
Monster getMonster() {
 // Поиск подходящего монстра
 return correctMonster.clone();
}
632 приложение
Посетитель
Паттерн Посетитель используется для расширения 
возможностей комбинации объектов в том случае, 
если инкапсуляция несущественна.
Посетители бистро и блинной из Объектвиля стали следить за своим здоровьем. Теперь они желают знать калорийность блюд перед 
оформлением заказа. Поскольку оба заведения предлагают блюда 
на заказ, некоторые посетители даже хотят получить информацию 
о калорийности отдельных ингредиентов.
Сценарий
Решение, 
предложенное Лу:
MenuItem
Menu
Ingredient
MenuItem
Ingredient
Мэл обеспокоен...
«Кажется, мы открываем ящик Пандоры. Кто знает, какие 
новые методы нам еще придется добавить, и каждый раз изменения будут вноситься в двух местах. А если мы захотим 
дополнить базовое приложение классом рецептов? Тогда 
изменения придется вносить уже в трех разных местах...»
паттерн посетитель
// Новые методы
getHealthRating
getCalories
getProtein
getCarbs
// Новые методы
getHealthRating
getCalories
getProtein
getCarbs
другие паттерны
633
Заходит Посетитель
Посетитель должен посетить каждый элемент составной структуры; 
эта функциональность сосредоточена в объекте Traverser. Последний управляет перемещениями Посетителя, чтобы тот мог получить данные состояния от всех объектов комбинации. После того 
как данные состояния будут получены, посетитель может по поручению клиента выполнить различные операции с состоянием. При 
добавлении новой функциональности изменения будут вноситься 
только в посетитель.
 Преимущества Посетителя
  Возможность добавления операций в составную 
стурктуру без изменения самой структуры.
  Добавление новых операций выполняется относи- тельно просто.
  Централизация кода операций, выполняемых по- сетителем.
  Использование паттерна Посетитель нарушает 
инкапсуляцию составной структуры.
  Усложнение возможных изменений составной 
структуры.
 Недостатки Посетителя
MenuItem
Menu
Ingredient
MenuItem
Ingredient
Visitor
 Client / 
Traverser
Этим классам 
остается лишь 
добавить метод 
getState().
Клиент запрашивает 
у посетителя информацию 
из составной структуры... 
Новые методы включаются 
в посетитель без изменения 
составной структуры.
Посетитель вызывает методы 
getState() разных классов; именно 
здесь добавляются новые методы, 
используемые клиентом.
Traverser знает, как 
управлять действиями 
посетителя с составной структурой.
getHealthRating()
getCalories()
getProtein()
getCarbs()
getState()
getState()
getState()
getState()
getState()
Не знаете о веб-сайте? У нас 
есть обновления, видео, 
проекты, авторские блоги 
и многое другое!
Загляните на сайт 
wickedlysmart.com
Загляните на сайт 
wickedlysmart.com
Эрик Фримен, Элизабет Робсон, Кэти Сьерра, Берт Бейтс
Head First. Паттерны проектирования
2-е издание
Перевел с английского Е. Матвеев
Заведующая редакцией Ю. Сергиенко
Ведущий редактор К. Тульцева
Художественный редактор В. Мостипан
Корректор С. Беляева
Верстка Н. Лукьянова
Изготовлено в России. Изготовитель: ООО «Прогресс книга».
Место нахождения и фактический адрес: 194044, Россия, г. Санкт-Петербург,
Б. Сампсониевский пр., д. 29А, пом. 52. Тел.: +78127037373.
Дата изготовления: 08.2021. Наименование: книжная продукция. Срок годности: не ограничен.
Налоговая льгота — общероссийский классификатор продукции ОК 034-2014, 58.11.12.000 — Книги печатные 
профессиональные, технические и научные.
Импортер в Беларусь: ООО «ПИТЕР М», 220020, РБ, г. Минск, ул. Тимирязева, д. 121/3, к. 214, тел./факс: 208 80 01.
Подписано в печать 22.07.21. Формат 84?108/16. Бумага офсетная. Усл. п. л. 72,240. Тираж 1700. Заказ 0000.
Джей Макгаврен 
HEAD FIRST. ИЗУЧАЕМ GO
Go упрощает построение простых, надежных и эффективных программ. 
А эта книга сделает его доступным для обычных программистов. Основная задача Go — эффективная работа с сетевыми коммуникациями и многопроцессорной обработкой, но код на этом языке пишется и читается не 
сложнее чем на Python и JavaScript. Простые примеры позволят познакомиться с языком в действии и сразу приступить к программированию на 
Go. Так что вы быстро освоите общепринятые правила и приемы, которые 
позволят вам называть себя гофером.
Дон Гриффитс, Дэвид Гриффитс 
HEAD FIRST. KOTLIN
Вот и настало время изучить Kotlin. В этом вам поможет уникальная методика Head First, выходящая за рамки синтаксиса и инструкций по решению 
конкретных задач. Хотите мыслить, как выдающиеся разработчики Kotlin? 
Эта книга даст вам все необходимое — от азов языка до продвинутых методов. А еще вы сможете попрактиковаться в объектно-ориентированном 
и функциональном программировании. Если вы действительно хотите понять, как устроен Kotlin, то эта книга для вас! 
Почему эта книга не похожа на другие? 
Подход Head First основан на новейших исследованиях в области когнитивистики и теории обучения. Визуальный формат позволяет вовлечь в обучение мозг читателя лучше, чем длинный текст, который вгоняет в сон. 
Зачем тратить время на борьбу с новыми концепциями? Head First задействует разные каналы получения информации и разрабатывался с учетом 
особенностей работы вашего мозга. 
Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес 
ПАТТЕРНЫ ОБЪЕКТНО-ОРИЕНТИРОВАННОГО 
ПРОЕКТИРОВАНИЯ
Больше 25 лет прошло с момента выхода первого тиража книги Design Patterns. За это время книга 
из популярной превратилась в культовую. Во всем мире ее рекомендуют прочитать каждому, кто 
хочет связать жизнь с информационными технологиями и программированием. «Русский» язык, на 
котором разговаривают айтишники, поменялся, многие англоязычные термины стали привычными, паттерны вошли в нашу жизнь. 
Перед вами юбилейное издание с обновленным переводом книги, ставшей must-read для каждого 
программиста. «Паттерны объектно-ориентированного проектирования» пришли на смену «Приемам объектно-ориентированного проектирования».
Четыре первоклассных разработчика — Банда четырех — представляют вашему вниманию опыт 
ООП в виде двадцати трех паттернов. Паттерны появились потому, что разработчики искали пути 
повышения гибкости и степени повторного использования своих программ. Авторы не только дают 
принципы использования шаблонов проектирования, но и систематизируют информацию. Вы узнаете о роли паттернов в архитектуре сложных систем и сможете быстро и эффективно создавать 
собственные приложения с учетом всех ограничений, возникающих при разработке больших проектов. Все шаблоны взяты из реальных систем и основаны на реальной практике. Для каждого паттерна приведен код на C ++ или Smalltalk, демонстрирующий его возможности.
Гэйл Лакман Макдауэлл 
КАРЬЕРА ПРОГРАММИСТА
6-е издание
Очередное собеседование обернулось разочарованием… в очередной раз. Никто из десяти кандидатов не получил работу. Может быть, «экзаменаторы» были слишком строги?
Увы, для поступления на работу в ведущую IT-компанию академического образования недостаточно. Учебники — это замечательно, но они не помогут вам пройти собеседование, для этого нужно 
готовиться на реальных вопросах. Нужно решать реальные задачи и изучать встречающиеся закономерности. Главное — разработка новых алгоритмов, а не запоминание существующих задач.
«Карьера программиста» основана на опыте практического участия автора во множестве собеседований, проводимых лучшими компаниями. Это квинтэссенция сотен интервью со множеством 
кандидатов, результат ответов на тысячи вопросов, задаваемых кандидатами и интервьюерами 
в ведущих мировых корпорациях. Из тысяч возможных задач и вопросов в книгу были отобраны 
189 наиболее интересных и значимых.
Шестое издание этого мирового бестселлера поможет вам наилучшим образом подготовиться к собеседованию при приеме на работу программистом или руководителем в крупную IT-организацию 
или перспективный стартап. Основную часть книги составляют ответы на технические вопросы 
и задания, которые обычно получают соискатели на собеседовании в таких компаниях, как Google, 
Microsoft, Apple, Amazon и других. Рассмотрены типичные ошибки, а также эффективные методики поготовки к собеседованию. Используя материал этой книги, вы с легкостью подготовитесь 
к устройству на работу в Google, Microsoft или любую другую ведущую IT-компанию.
Джувел Лёве
СОВЕРШЕННЫЙ СОФТ
«Совершенный софт» — это проверенный, структурированный и высокотехнологичный подход к разработке программного обеспечения. Множество компаний уже используют идеи Лёве в сотнях систем, но раньше эти мысли нигде не публиковались. 
Методология Лёве объединяет разработку систем и дизайн проектов, используя базовые принципы разработки ПО, корректные наборы инструментов и эффективные методы. Автор подробно описывает основы, на которых прокалываются многие архитекторы ПО, и показывает, как разложить систему на мелкие блоки или службы. Вы узнаете 
как вывести эффективный дизайн проекта из дизайна системы, как рассчитать время, 
необходимое на запуск проекта, его стоимость и риски, и даже как разработать несколько вариантов выполнения.
Метод и принципы «совершенного софта» можно применять независимо от размера 
проекта, компании, технологии, платформы или отрасли. Цель этой книги — решение 
важнейших задач современной разработки ПО, требующих исправления программных 
систем и проектов, ваш карьерный рост и, возможно, изменение всей IT-индустрии. 
Рекомендации и знания, которые вы получите, сэкономят десятилетия вашего опыта 
и спасут многие проекты. Эта книга принесет большую пользу разработчикам, архитекторам, руководителям проектов или менеджерам на любом этапе карьеры.